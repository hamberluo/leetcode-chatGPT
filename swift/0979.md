题目编号：979

题目：在二叉树中分配硬币

难度：中等

考察范围：二叉树、递归、贪心算法

题干：

给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。

在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。 

(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。

返回使每个结点上只有一枚硬币所需的移动次数。

解题思路：

对于每个节点，我们需要计算它的过载量，即它的硬币数减去它应该有的硬币数（即 1）。然后，我们可以在递归中将这些过载量向上传递，从而计算每个父节点的过载量。

对于一个节点而言，它的过载量等于它左右子节点的过载量之和，再加上它自己的硬币数减 1。对于左右子节点而言，它们的过载量也可以通过同样的方式计算。

当我们递归到一个叶节点时，我们计算出它的过载量，这个过载量等于它的硬币数减 1。我们将这个过载量向上传递给父节点，从而计算出父节点的过载量。我们也可以在递归过程中统计答案，即移动次数。

解决方案：

```swift
class Solution {
    var ans = 0

    func distributeCoins(_ root: TreeNode?) -> Int {
        dfs(root)
        return ans
    }

    func dfs(_ node: TreeNode?) -> Int {
        guard let node = node else {
            return 0
        }
        let left = dfs(node.left)
        let right = dfs(node.right)
        ans += abs(left) + abs(right)
        return node.val + left + right - 1
    }
}
```

算法复杂度：时间复杂度为 O(n)，其中 n 是二叉树中的节点个数。在递归过程中，每个节点最多只会被访问一次。空间复杂度为 O(H)，其中 H 是二叉树的高度。空间复杂度主要取决于递归调用的栈空间。