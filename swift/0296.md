题目编号：296

题目：最佳的会议安排

难度：困难

考察范围：贪心算法、排序算法

题干：

假设你是一位行政助理，正在为公司安排会议室。你需要安排 N 次会议，这些会议用一个二维数组 intervals 表示，其中每个 intervals[i] = [starti, endi] 表示第 i 次会议的开始时间和结束时间（均为整数）。

会议室永远只能同时容纳一场会议。如果你可以安排多场会议同时开始，但这些会议必须在同一时间结束，那么就可以安排这些会议在同一会议室中。返回至少需要安排多少个会议室才能满足这些会议安排的要求。

解题思路：

这道题目可以使用贪心算法来解决。我们可以按照会议的开始时间对所有会议进行排序，然后使用一个最小堆来维护当前正在进行的会议。具体来说，我们首先将第一个会议加入最小堆中，然后从第二个会议开始遍历，对于每个会议，我们首先将堆顶的会议结束时间与当前会议的开始时间进行比较，如果堆顶的会议已经结束，我们就将其弹出堆，将当前会议加入堆中。否则，我们就需要再开一个会议室，将当前会议加入新的会议室中。最后，我们返回开的会议室的数量即可。

解决方案：

```swift
func minMeetingRooms(_ intervals: [[Int]]) -> Int {
    let n = intervals.count
    if n == 0 {
        return 0
    }
    // 按照会议的开始时间进行排序
    let sortedIntervals = intervals.sorted { 0[0] < 1[0] }
    // 使用一个最小堆来维护当前正在进行的会议
    var heap = [sortedIntervals[0][1]]
    for i in 1..<n {
        let start = sortedIntervals[i][0]
        let end = sortedIntervals[i][1]
        if start >= heap[0] {
            // 如果堆顶的会议已经结束，我们就将其弹出堆，将当前会议加入堆中
            heap.removeFirst()
        }
        // 将当前会议加入堆中
        heap.append(end)
        // 对堆进行排序
        heap.sort()
    }
    // 返回开的会议室的数量
    return heap.count
}
```

算法复杂度：时间复杂度为 O(nlogn)，其中 n 是会议的数量。排序的时间复杂度为 O(nlogn)，每个会议最多只会被加入和弹出堆一次，堆的操作的时间复杂度为 O(logn)，因此总时间复杂度为 O(nlogn)。空间复杂度为 O(n)，即为堆的大小。