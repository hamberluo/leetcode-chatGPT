题目编号：630

题目：课程表 III

难度：中等

考察范围：贪心算法、堆

题干：

这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时才能完成，你将会从第 1 天开始。

给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。

示例：

输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 200 天关闭课程。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 且第 1250 天是它的关闭时间。
第三, 修第四门课时, 它会耗时 2000 天，所以你将会在第 2300 天时完成它, 在第 3200 天关闭课程。
第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。

提示：

整数 1 <= d, t, n <= 10,000 。
你不能同时修两门课程。

解题思路：

首先，我们需要对课程按照关闭时间进行排序，因为我们需要尽可能多地修课程，所以我们需要先修关闭时间早的课程。

然后，我们需要维护一个当前已经修的课程的总时间和一个最大堆，堆中存储的是已经修的课程的持续时间。我们遍历每个课程，如果当前已经修的课程的总时间加上当前课程的持续时间小于等于当前课程的关闭时间，那么我们就可以修这门课程，将其持续时间加入堆中，并且更新当前已经修的课程的总时间。如果当前已经修的课程的总时间加上当前课程的持续时间大于当前课程的关闭时间，那么我们需要判断当前堆中的最大值是否大于当前课程的持续时间，如果是，那么我们就可以用当前课程替换堆中的最大值，因为当前课程的持续时间更小，可以让我们有更多的时间去修其他课程。

最后，堆中的元素个数就是我们最多可以修的课程数。

解决方案：

```swift
class Solution {
    func scheduleCourse(_ courses: [[Int]]) -> Int {
        let sortedCourses = courses.sorted { 0[1] < 1[1] }
        var totalTime = 0
        var maxHeap = [Int]()
        for course in sortedCourses {
            let duration = course[0]
            let closeTime = course[1]
            if totalTime + duration <= closeTime {
                totalTime += duration
                maxHeap.append(duration)
                maxHeap.sort(by: >)
            } else if !maxHeap.isEmpty && maxHeap[0] > duration {
                totalTime += duration - maxHeap[0]
                maxHeap[0] = duration
                maxHeap.sort(by: >)
            }
        }
        return maxHeap.count
    }
}
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。