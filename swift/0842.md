题目编号：842

题目：将数组拆分成斐波那契序列

难度：中等

考察范围：回溯算法、字符串处理

题干：

给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。

形式上，斐波那契式序列是一个非负整数列表 F，且满足：

0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；
F.length >= 3；
对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。
另外，注意：可以认为斐波那契式序列中不含有任何前导零，且不能使用 2^31 - 1 作为其中一个元素。

给定一个形如 "123456579" 的数字字符串，写一个函数，以字符串形式返回所有可能的斐波那契式序列，顺序为：

[123, 456, 579]
[123, 579, 702]
解题思路：

这道题目可以使用回溯算法来解决。我们可以从字符串的第一个位置开始，枚举前两个数，然后判断是否符合斐波那契数列的定义，如果符合，就继续往下枚举，否则就回溯到上一个状态，重新枚举前两个数。

在枚举前两个数的时候，我们可以使用两个指针来指向当前位置和下一个位置，然后将这两个位置之间的子串转换成数字，作为第一个数和第二个数。

在枚举第三个数的时候，我们可以使用一个指针来指向当前位置，然后将这个位置之后的子串转换成数字，作为第三个数。然后判断第三个数是否等于前两个数的和，如果相等，就继续往下枚举，否则就回溯到上一个状态，重新枚举第二个数和第三个数。

在枚举第三个数的时候，我们需要注意一些细节问题。首先，如果第三个数的长度大于第一个数和第二个数的长度之和，那么就可以直接回溯，因为第三个数的长度不可能小于等于第一个数和第二个数的长度之和。其次，如果第三个数以 0 开头，那么就可以直接回溯，因为斐波那契数列中不含有前导零。

解决方案：

```swift
class Solution {
    func splitIntoFibonacci(_ S: String) -> [Int] {
        var res = [Int]()
        dfs(S, 0, &res)
        return res
    }
    
    func dfs(_ S: String, _ start: Int, _ res: inout [Int]) -> Bool {
        if start == S.count && res.count >= 3 {
            return true
        }
        for i in start..<S.count {
            if i > start && S[start] == "0" {
                break
            }
            let num = Int(String(S[start...i]))!
            if num > Int32.max {
                break
            }
            if res.count < 2 || num == res[res.count - 1] + res[res.count - 2] {
                res.append(num)
                if dfs(S, i + 1, &res) {
                    return true
                }
                res.removeLast()
            } else if num < res[res.count - 1] + res[res.count - 2] {
                continue
            } else {
                break
            }
        }
        return false
    }
}
```

算法复杂度：时间复杂度为 O(n^2)，其中 n 是字符串的长度。在枚举前两个数的时候，需要枚举的位置是 O(n)，在枚举第三个数的时候，需要枚举的位置是 O(n)，因此总时间复杂度是 O(n^2)。空间复杂度为 O(n)，其中 n 是字符串的长度。空间复杂度主要取决于递归调用栈的深度，最坏情况下递归调用栈的深度是 O(n)。