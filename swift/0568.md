题目编号：568

题目：最大休假天数

难度：困难

考察范围：动态规划

题干：给定一个城市的旅游日历，包含了来自旅游者的 N 天的计划，计划用 [i, j] 表示，表示从第 i 天到第 j 天的旅游计划。城市需要给游客提供一些旅游活动，这些活动可以用编号 0, 1, 2, ..., n-1 表示。每个旅游计划都可以用一个含有 n 个非负整数的数组 days 表示，其中 days[k] 表示在这个计划中第 k 天需要参加旅游活动的编号。从城市出发时，旅游者总是从第 0 天开始旅游。旅游者想要在旅游期间参加尽可能多的不同旅游活动，并且每个活动最多只能参加一次。给定旅游计划，你可以安排旅游者的行程计划列表 seq，其中 seq[i] 表示旅游者在第 i 天时参加的旅游活动编号。旅游者在参加某个旅游活动编号为 k 的活动时，可以在这一天内参加所有计划中包含编号 k 的旅游活动。如果两个活动在同一天举行，那么旅游者无法同时参加这两个活动。旅游者可以在旅游期间的任意一天结束行程，不过他们必须在旅游期间至少参加一个旅游活动。你需要帮助城市规划旅游者的行程计划列表 seq，使得旅游者能够参加尽可能多的旅游活动，并且在旅游期间结束行程。返回旅游者能够参加的最大不同旅游活动数量。

解题思路：这是一道动态规划的题目。我们可以用 dp[i][j] 表示在第 i 天到第 j 天内，旅游者能够参加的最大不同旅游活动数量。对于每个 dp[i][j]，我们可以枚举旅游者在第 i 天参加的旅游活动编号 k，然后在第 i+1 天到第 j 天内寻找下一个旅游活动编号 k'，使得 k' != k 并且在第 i+1 天到第 j 天内没有被选择过。如果找到了这样的 k'，那么 dp[i][j] 就可以转移为 dp[i][j] = max(dp[i][j], dp[i+1][k'] + 1)。最终的答案就是 dp[0][N-1]。

解决方案：

```swift
func maxVacationDays(_ flights: [[Int]], _ days: [[Int]]) -> Int {
    let N = days.count
    let K = days[0].count
    var dp = Array(repeating: Array(repeating: 0, count: N), count: N)
    for i in 0..<N {
        dp[i][N-1] = days[i][K-1]
    }
    for j in (0..<N-1).reversed() {
        for i in 0..<N {
            dp[i][j] = days[i][j] + dp[i][j+1]
            for k in 0..<N {
                if flights[i][k] == 1 {
                    dp[i][j] = max(dp[i][j], days[k][j] + dp[k][j+1])
                }
            }
        }
    }
    var ans = 0
    for i in 0..<N {
        if flights[0][i] == 1 {
            ans = max(ans, dp[i][0])
        }
    }
    return ans
}
```

算法复杂度：时间复杂度为 O(N^3)，空间复杂度为 O(N^2)。