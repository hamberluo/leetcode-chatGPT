题目编号：10

题目：正则表达式匹配

难度：困难

考察范围：动态规划、字符串匹配

题干：给定一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符
- '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。

说明:

- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 可以匹配任意数量的 a。

示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以匹配零个 'a'，'*' 可以匹配两个 'a'。

示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

解题思路：动态规划

首先，我们需要明确一个问题：如何判断 s 和 p 是否匹配？

我们可以从 s 和 p 的最后一个字符开始，逐个向前匹配。如果 s 和 p 的最后一个字符相同，或者 p 的最后一个字符是 '.'，那么它们是匹配的。否则，如果 p 的最后一个字符是 '*'，那么它可以匹配零个或多个 s 的最后一个字符。因此，我们需要考虑 p 的倒数第二个字符是什么，来决定是否匹配。

接下来，我们考虑如何使用动态规划来解决这个问题。我们可以定义一个二维数组 dp，其中 dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配。根据上面的分析，我们可以得到状态转移方程：

- 如果 p[j-1] 不是 '*'，那么 dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
- 如果 p[j-1] 是 '*'，那么 dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))

其中，dp[i-1][j-1] 表示 s 的前 i-1 个字符和 p 的前 j-1 个字符已经匹配，现在只需要判断 s 的第 i 个字符和 p 的第 j 个字符是否匹配。dp[i][j-2] 表示 p 的前 j-2 个字符和 s 的前 i 个字符已经匹配，现在只需要判断 p 的最后两个字符是否匹配。dp[i-1][j] 表示 s 的前 i-1 个字符和 p 的前 j 个字符已经匹配，现在只需要判断 s 的第 i 个字符和 p 的最后一个字符是否匹配。

最终的答案就是 dp[s.count][p.count]。

解决方案：

```swift
class Solution {
    func isMatch(_ s: String, _ p: String) -> Bool {
        let s = Array(s)
        let p = Array(p)
        var dp = Array(repeating: Array(repeating: false, count: p.count + 1), count: s.count + 1)
        dp[0][0] = true
        for j in 1...p.count {
            if p[j-1] == "*" {
                dp[0][j] = dp[0][j-2]
            }
        }
        for i in 1...s.count {
            for j in 1...p.count {
                if p[j-1] != "*" {
                    dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == ".")
                } else {
                    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == "."))
                }
            }
        }
        return dp[s.count][p.count]
    }
}
```

算法复杂度：时间复杂度为 O(mn)，其中 m 和 n 分别是字符串 s 和 p 的长度。空间复杂度为 O(mn)。