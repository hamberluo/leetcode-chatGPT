题目编号：799

题目：香槟塔

难度：困难

考察范围：动态规划

题干：

我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，依此类推。（如果最底层的玻璃杯满了，就会将香槟溢出）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放了一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯：顶层的一个和第二层的两个，但第二层的两个玻璃杯平分了一杯香槟。在倒第四杯香槟后，第二层的香槟又满了。

如果我们继续倒更多的香槟，会发生什么呢？

从这个例子中，我们可以看出，在倾倒第i杯香槟时，流向左右两侧的香槟量相等。而且，一个满的玻璃杯会等流量的流向左右两侧的玻璃杯，直到所有的玻璃杯都平衡了。

请你根据总香槟杯数N和倾倒香槟杯数p，计算出第i行j个玻璃杯盛放的香槟量。

注意：

i 行 j 个玻璃杯所盛放的香槟总量不超过 250ml。
在这个问题中，我们将认为流出边缘的香槟也会被无限期地保留在杯子里。
答案在 10^-4 范围内会被视为是正确的。

解题思路：

这是一道动态规划的题目，我们可以用一个二维数组dp[i][j]表示第i行j个杯子中的香槟量。在倾倒第p杯香槟时，我们需要更新dp数组。

首先，我们将第1个杯子中的香槟全部倒入，即dp[1][1] = poured。

然后，我们从第2行开始，依次计算每个杯子中的香槟量。对于第i行j个杯子，它的香槟量等于上一行左右两个杯子中溢出的香槟量之和的一半，即：

dp[i][j] = max(0, (dp[i-1][j-1]-1)/2) + max(0, (dp[i-1][j]-1)/2)

其中，max(0, x)表示x和0中的较大值，因为溢出的香槟量不能为负数。

最后，我们返回dp[target_row][target_glass]即可。

解决方案：

```swift
class Solution {
    func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double {
        var dp = Array(repeating: Array(repeating: 0.0, count: 101), count: 101)
        dp[1][1] = Double(poured)
        for i in 2...100 {
            for j in 1...i {
                dp[i][j] = max(0, (dp[i-1][j-1]-1)/2) + max(0, (dp[i-1][j]-1)/2)
            }
        }
        return min(1.0, dp[query_row+1][query_glass+1])
    }
}
```

算法复杂度：时间复杂度为O(N^2)，空间复杂度为O(N^2)。