题目编号：639

题目：解码方法 II

难度：困难

考察范围：动态规划

题干：

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'，可以表示从 1 到 9 的任意数字（不包括 0）。例如，字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18"、"19"。相应地，字符串 "2*" 可以表示 "21"、"22"、"23"、"24"、"25"、"26"。给定一个字符串 s，返回解码该字符串的方法数。由于答案数目可能非常大，所以返回答案对 109 + 7 取余的结果。

示例 1：

输入：s = "*"
输出：9
解释：这里有 9 种可能的解码：1, 2, 3, 4, 5, 6, 7, 8, 9 对应 "*"

示例 2：

输入：s = "1*"
输出：18
解释：这里有 9 种可能的解码：11, 12, 13, 14, 15, 16, 17, 18, 19 和 1*，以及 9 种可能的解码：21, 22, 23, 24, 25, 26, 27, 28, 29 对应 "1*"
因此，"1*" 总共有 9 + 9 = 18 种解码方法。

解题思路：

本题是一道动态规划的题目，我们可以定义 dp[i] 表示字符串 s 的前 i 个字符的解码方法数。对于第 i 个字符，我们需要考虑以下几种情况：

1. 如果 s[i] 是数字 1-9，那么它可以单独作为一个字符解码，此时 dp[i] += dp[i-1]。

2. 如果 s[i] 是字符 *，那么它可以表示 1-9 中的任意一个数字，此时 dp[i] += 9 * dp[i-1]。

3. 如果 s[i-1] 是数字 1，那么 s[i] 可以和 s[i-1] 组成一个 10-19 的数字，此时 dp[i] += dp[i-2]。

4. 如果 s[i-1] 是数字 2，那么 s[i] 可以和 s[i-1] 组成一个 20-26 的数字，此时 dp[i] += dp[i-2]。

5. 如果 s[i-1] 是字符 *，那么 s[i] 可以和 s[i-1] 组成 10-19 或 20-26 的数字，此时 dp[i] += (s[i] <= '6' ? 2 : 1) * dp[i-2]。

最终的答案即为 dp[n]，其中 n 是字符串 s 的长度。

解决方案：

```swift
class Solution {
    func numDecodings(_ s: String) -> Int {
        let mod = 1000000007
        let n = s.count
        let s = Array(s)
        var dp = Array(repeating: 0, count: n+1)
        dp[0] = 1
        if s[0] == "*" {
            dp[1] = 9
        } else if s[0] != "0" {
            dp[1] = 1
        }
        for i in 2...n {
            if s[i-1] == "*" {
                dp[i] += 9 * dp[i-1]
            } else if s[i-1] != "0" {
                dp[i] += dp[i-1]
            }
            if s[i-2] == "1" {
                if s[i-1] == "*" {
                    dp[i] += dp[i-2] * 9
                } else {
                    dp[i] += dp[i-2]
                }
            } else if s[i-2] == "2" {
                if s[i-1] == "*" {
                    dp[i] += dp[i-2] * 6
                } else if s[i-1] <= "6" {
                    dp[i] += dp[i-2]
                }
            } else if s[i-2] == "*" {
                if s[i-1] == "*" {
                    dp[i] += dp[i-2] * 15
                } else if s[i-1] <= "6" {
                    dp[i] += dp[i-2] * 2
                } else {
                    dp[i] += dp[i-2]
                }
            }
            dp[i] %= mod
        }
        return dp[n]
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。