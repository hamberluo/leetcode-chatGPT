题目编号：808

题目：分汤

难度：中等

考察范围：递归、动态规划

题干：有 A 和 B 两个汤，初始时，A 和 B 均有 N 毫升汤。有四种操作：

1. 提供 100ml 的汤A 和 0ml 的汤B。
2. 提供 75ml 的汤A 和 25ml 的汤B。
3. 提供 50ml 的汤A 和 50ml 的汤B。
4. 提供 25ml 的汤A 和 75ml 的汤B。

当我们把两种汤分别喝掉一些时，剩下的汤就会组合在一起。如果我们倾倒任意一种汤，剩下的汤将被一起倾倒。

例如，如果我们倾倒了 A，那么剩下的汤将是 B 和 0ml 的汤。

如果我们将两种汤都倾倒，剩下的汤将是 0ml 的A 和 B。

假设我们无限制地执行以下操作（不一定按顺序）：

1. 如果剩下的汤总量不足 50 毫升，那么我们将其丢弃。
2. 否则，我们选择将其倾倒。注意，我们可以将汤 A 或汤 B 倾倒至少一点点（例如，7 毫升汤A 和 32 毫升汤B）。

请注意，我们想要执行的操作可以在任何时间点进行，并且我们无需等待操作完成。所有剩余的汤应该一起倾倒。

求出在倾倒操作结束后，我们可以得到多少毫升 A 和 B 的汤在容器中。

解题思路：递归、动态规划

这道题可以用递归或者动态规划来解决。

递归的思路是，每次选择四种操作中的一种，然后递归调用函数，直到剩余的汤总量不足 50 毫升。最后将剩余的汤倾倒，得到最终的结果。

动态规划的思路是，用一个二维数组 dp[i][j] 表示剩余 i 毫升 A 汤和 j 毫升 B 汤时，最终能得到多少毫升 A 和 B 的汤。然后根据四种操作的规则，更新 dp 数组，最终得到 dp[N][N] 的值。

解决方案：动态规划

```swift
func soupServings(_ N: Int) -> Double {
    if N >= 4800 {
        return 1.0
    }
    let n = (N + 24) / 25
    var dp = Array(repeating: Array(repeating: 0.0, count: n + 1), count: n + 1)
    dp[0][0] = 0.5
    for i in 1...n {
        dp[0][i] = 1.0
        dp[i][0] = 0.0
    }
    for i in 1...n {
        for j in 1...n {
            dp[i][j] = 0.25 * (dp[max(i - 4, 0)][j] + dp[max(i - 3, 0)][max(j - 1, 0)] + dp[max(i - 2, 0)][max(j - 2, 0)] + dp[max(i - 1, 0)][max(j - 3, 0)])
        }
    }
    return dp[n][n]
}
```

算法复杂度：时间复杂度 O(N^2)，空间复杂度 O(N^2)。