题目编号：891

题目：子序列宽度之和

难度：困难

考察范围：动态规划、数学

题干：

给定一个整数数组 A ，考虑 A 的所有非空子序列。

对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。

返回 A 的所有子序列的宽度之和。

由于答案可能非常大，请返回答案模 10^9+7。

示例：

输入：[2,1,3]
输出：6
解释：
子序列为 [2]，[1]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。
相应的宽度是 0，0，0，1，1，2，2 。
这些宽度之和是 6 。

提示：

1 <= A.length <= 20000
1 <= A[i] <= 20000

解题思路：

首先，我们可以将数组 A 排序，这样最大值和最小值就可以确定了。

对于每个数 A[i]，它在多少个子序列中是最大值或最小值呢？

我们可以考虑它在多少个子序列中是最大值，然后再考虑它在多少个子序列中是最小值，最后将两者相乘即可。

对于 A[i]，它在以它自己为最大值的子序列中，最小值可以是 A[0] 到 A[i-1] 中的任意一个数，所以有 i 种选择；同理，它在以它自己为最小值的子序列中，最大值可以是 A[i+1] 到 A[n-1] 中的任意一个数，所以有 n-i-1 种选择。

因此，A[i] 在子序列中的贡献为 A[i] * (2^i - 2^(n-i-1))。

最后将所有数的贡献相加即可。

解决方案：

```swift
class Solution {
    func sumSubseqWidths(_ A: [Int]) -> Int {
        let mod = 1000000007
        let n = A.count
        var pow2 = [1]
        for i in 1..<n {
            pow2.append(pow2[i-1] * 2 % mod)
        }
        var ans = 0
        let sortedA = A.sorted()
        for i in 0..<n {
            ans = (ans + sortedA[i] * (pow2[i] - pow2[n-i-1])) % mod
        }
        return ans
    }
}
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。