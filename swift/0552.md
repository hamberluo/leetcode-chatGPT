题目编号：552

题目：学生出勤记录 II

难度：困难

考察范围：动态规划

题干：给定一个正整数 n，表示学生的出勤记录表的大小。记录表中第 i 条记录代表第 i 天学生的出勤情况，共有三个字符（"A", "L", "P"）：

"A" : Absent，缺勤
"L" : Late，迟到
"P" : Present，到场

如果学生能够同时满足下面两个条件，则可以获得出勤奖励：

按总出勤计，学生缺勤（"A"）严格少于两天。
学生不会存在连续 3 天或 3 天以上的迟到（"L"）记录。
给定一个整数 n，返回记录长度为 n 时，可能获得出勤奖励的记录情况数量。答案可能非常大，所以返回结果 mod 109 + 7。

解题思路：本题可以使用动态规划来解决。我们可以定义一个三维数组 dp[i][j][k]，其中 i 表示当前考虑到第 i 天，j 表示当前缺勤的天数，k 表示当前连续迟到的天数。那么状态转移方程如下：

dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2] // 今天不迟到
dp[i][j][1] = dp[i-1][j][0] // 今天迟到，但不连续
dp[i][j][2] = dp[i-1][j][1] // 今天迟到，且连续

需要注意的是，当 j=0 时，dp[i][j][0] 的值还需要加上 dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]，因为此时学生没有缺勤。

最终的答案即为 dp[n][0][0] + dp[n][0][1] + dp[n][0][2]。

解决方案：

```swift
class Solution {
    func checkRecord(_ n: Int) -> Int {
        let mod = 1000000007
        var dp = Array(repeating: Array(repeating: Array(repeating: 0, count: 3), count: 2), count: n+1)
        dp[0][0][0] = 1
        for i in 1...n {
            // 今天不缺勤
            dp[i][0][0] = (dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % mod
            dp[i][1][0] = (dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2]) % mod
            // 今天缺勤
            dp[i][0][1] = dp[i-1][0][0]
            dp[i][1][1] = dp[i-1][1][0]
            dp[i][0][2] = dp[i-1][0][1]
            dp[i][1][2] = dp[i-1][1][1]
        }
        var res = 0
        for i in 0...1 {
            for j in 0...2 {
                res = (res + dp[n][i][j]) % mod
            }
        }
        return res
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。