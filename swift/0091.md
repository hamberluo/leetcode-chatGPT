题目编号：91

题目：解码方法

难度：中等

考察范围：动态规划

题干：一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26

给定一个只包含数字的非空字符串，请计算解码方法的总数。

解题思路：动态规划

对于字符串 s，我们可以定义一个数组 dp，其中 dp[i] 表示字符串 s 的前 i 个字符 s[0..i-1] 的解码方法总数。

考虑如何进行状态转移：

1. 如果 s[i-1] 是 1~9，那么 s[i-1] 可以单独作为一个编码，此时 dp[i] 至少可以增加 dp[i-1] 种解码方法，即：

dp[i] += dp[i-1]

2. 如果 s[i-2] 和 s[i-1] 组成的数字在 10~26 之间，那么 s[i-2] 和 s[i-1] 可以作为一个编码，此时 dp[i] 至少可以增加 dp[i-2] 种解码方法，即：

dp[i] += dp[i-2]

需要注意的是，如果 s[i-1] 是 0，那么它只能和 s[i-2] 组成 10 或 20，此时 dp[i] 至少可以增加 dp[i-2] 种解码方法，即：

if s[i-2] == "1" || s[i-2] == "2" {
    dp[i] += dp[i-2]
}

最终的答案即为 dp[n]，其中 n 是字符串 s 的长度。

解决方案：

```swift
func numDecodings(_ s: String) -> Int {
    let n = s.count
    let s = Array(s)
    var dp = [Int](repeating: 0, count: n+1)
    dp[0] = 1
    dp[1] = s[0] == "0" ? 0 : 1
    for i in 2...n {
        if s[i-1] != "0" {
            dp[i] += dp[i-1]
        }
        if s[i-2] == "1" || (s[i-2] == "2" && s[i-1] >= "0" && s[i-1] <= "6") {
            dp[i] += dp[i-2]
        }
    }
    return dp[n]
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。