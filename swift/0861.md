题目编号：861

题目：翻转矩阵后的得分

难度：中等

考察范围：贪心算法、位运算

题干：有一个二维矩阵，每个位置上的值只能是 0 或 1。现在你可以将这个矩阵进行两种操作中的一种：

1. 将矩阵的一行进行翻转，即将 0 变为 1，1 变为 0。
2. 将矩阵的一列进行翻转，即将 0 变为 1，1 变为 0。

翻转后，矩阵的得分是所有行中的数值之和，即每一行都看作一个二进制数，转化为十进制后相加。请你输出在一系列操作后，矩阵能够得到的最高分数。

解题思路：贪心算法

首先，我们需要明确一个贪心策略：为了使得得分最高，我们应该尽可能地让高位为 1。

具体来说，我们可以分为以下两步：

1. 首先，对于每一行，如果这一行的第一个数不为 1，那么我们就翻转这一行。这样做的原因是，对于一个 m 行 n 列的矩阵，如果第一列中 0 的个数大于 n / 2，那么我们就可以通过翻转第一列来使得第一列中 1 的个数大于等于 0 的个数，从而使得第一列的贡献为 2^(n-1)。

2. 其次，对于每一列，如果这一列中 0 的个数大于 1 的个数，那么我们就翻转这一列。这样做的原因是，对于一个 m 行 n 列的矩阵，如果第 j 列中 0 的个数大于 m / 2，那么我们就可以通过翻转第 j 列来使得第 j 列中 1 的个数大于等于 0 的个数，从而使得第 j 列的贡献为 2^(n-j-1)。

解决方案：Swift 代码

```swift
class Solution {
    func matrixScore(_ A: [[Int]]) -> Int {
        let m = A.count, n = A[0].count
        var res = m * (1 << (n - 1))
        for j in 1..<n {
            var cnt = 0
            for i in 0..<m {
                cnt += A[i][j] == A[i][0] ? 1 : 0
            }
            res += max(cnt, m - cnt) * (1 << (n - j - 1))
        }
        return res
    }
}
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(1)。