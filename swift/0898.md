题目编号：898

题目：子数组按位或操作

难度：中等

考察范围：位运算、动态规划

题干：

给定一个整数数组 `A`，找到 `A` 中最大的连续子数组，使得该子数组中的每个元素对应的位都是相同的。

如果不存在这样的子数组，返回 0。

示例 1:

输入: [0]
输出: 0
示例 2:

输入: [1,1,2]
输出: 3
解释: 最大的连续子数组是 [1,1]，每个元素对应的位都是 1。
示例 3:

输入: [1,2,4]
输出: 6
解释: 最大的连续子数组是 [1,2,4]，每个元素对应的位都是 0b100（即 4）。

解题思路：

本题可以使用动态规划来解决。我们可以定义一个二维数组 `dp[i][j]`，表示以 `A[i]` 结尾的、所有元素都与 `A[j]` 相或的最大子数组的长度。其中 `0 <= i <= j < n`，`n` 是数组 `A` 的长度。

那么我们可以得到状态转移方程：

- 当 `A[i]` 与 `A[j]` 相或的结果为 `0` 时，`dp[i][j] = j - i + 1`；
- 当 `A[i]` 与 `A[j]` 相或的结果不为 `0` 时，`dp[i][j] = 0`。

最终的答案就是所有 `dp[i][j]` 中的最大值。

解决方案：

```swift
class Solution {
    func largestSubarray(_ nums: [Int]) -> Int {
        let n = nums.count
        var dp = Array(repeating: Array(repeating: 0, count: n), count: n)
        var res = 0
        for i in 0..<n {
            dp[i][i] = 1
            for j in (i+1)..<n {
                if (nums[i] | nums[j]) == nums[j] {
                    dp[i][j] = dp[i][j-1] + 1
                }
                res = max(res, dp[i][j])
            }
        }
        return res
    }
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。