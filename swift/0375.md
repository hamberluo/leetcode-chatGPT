题目编号：375

题目：猜数字大小 II

难度：中等

考察范围：动态规划

题干：我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，才算游戏结束。

例如，n = 10，我选择了8。

你猜测 5，我会告诉你，我选的数字比你的大了，然后你需要支付 5 元。

你猜测 7，我再次告诉你，我选的数字比你的大了，你现在还需要支付 7 元。

你猜测 9，我告诉你，我选的数字比你的小了，你需要支付 9 元。

游戏结束，因为你猜到了我选的数字 8 ，所以你不需要再支付任何费用。

根据你所猜测的数字，我会选择告诉你，我选的数字是大于还是小于你所猜测的数字。

请你编写一个函数，来计算最坏情况下你需要支付的最小金额。

解题思路：动态规划

这道题可以使用动态规划来解决。我们可以定义一个二维数组 dp，其中 dp[i][j] 表示从数字 i 到 j 猜中任意一个数字最少需要花费的钱数。

在进行状态转移时，我们枚举这段区间内的所有数字作为猜测的数 x（i≤x≤j），并计算出在选择 x 作为猜测数字时的最小花费。由于我们要保证最坏情况下的最小花费，所以最终的答案即为所有 dp[i][j] 中的最大值。

具体而言，我们可以先枚举区间长度 len（从小到大），再枚举区间左端点 i，最后计算出区间右端点 j=i+len−1。此时我们尝试枚举 k（i≤k<j），其中 k 表示我们在区间 [i,j] 中进行猜测的数，则有状态转移方程：

dp[i][j] = min(dp[i][j], k + max(dp[i][k-1], dp[k+1][j]))

其中 k + max(dp[i][k-1], dp[k+1][j]) 表示在 k 这个位置猜测，需要花费 k 的钱数，加上左右两个区间的最大值，表示最坏情况下的花费。

最终的答案即为 dp[1][n]。

解决方案：

```swift
class Solution {
    func getMoneyAmount(_ n: Int) -> Int {
        var dp = Array(repeating: Array(repeating: 0, count: n+1), count: n+1)
        for len in 2...n {
            for i in 1...n-len+1 {
                let j = i + len - 1
                dp[i][j] = Int.max
                for k in i...j {
                    dp[i][j] = min(dp[i][j], k + max(dp[i][k-1], dp[k+1][j]))
                }
            }
        }
        return dp[1][n]
    }
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。