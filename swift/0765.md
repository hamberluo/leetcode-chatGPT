题目编号：765

题目：情侣牵手

难度：困难

考察范围：贪心算法

题干：有 n 对情侣坐在一排，每个人都有一个唯一的编号，编号从 0 到 2n - 1。 他们想要站起来并手牵手。 无论是左手还是右手都可以，但是他们的编号必须按顺序挨着。 也就是说，编号为 0 和 1 的情侣手牵着手，编号为 2 和 3 的情侣手牵着手，以此类推，直到编号为 2n - 2 和 2n - 1 的情侣手牵着手。

这些情侣的初始坐位顺序是 row[i] = x，其中 i 是情侣的编号，x 是他们的位置。 最开始，所有人都是坐着的，因此手牵手的位置是随意的。 返回情侣可以站起来并手牵手的最小交换次数。

解题思路：本题可以使用贪心算法来解决。我们可以从左到右遍历每一对情侣，如果他们没有手牵手，那么我们就需要进行交换。我们可以将每个情侣的编号和位置存储在一个字典中，这样我们就可以快速地找到每个情侣的位置。对于每一对情侣，我们需要找到他们手牵手的位置，如果他们没有手牵手，那么我们就需要进行交换。我们可以将他们手牵手的位置存储在一个数组中，然后使用双指针来找到他们手牵手的位置。如果他们手牵手的位置不在正确的位置上，那么我们就需要进行交换。我们可以使用一个计数器来记录交换的次数，最后返回计数器的值即可。

解决方案：

```swift
class Solution {
    func minSwapsCouples(_ row: [Int]) -> Int {
        var dict = [Int: Int]()
        for i in 0..<row.count {
            dict[row[i]] = i
        }
        var swaps = 0
        for i in stride(from: 0, to: row.count, by: 2) {
            let x = row[i]
            let y = x % 2 == 0 ? x + 1 : x - 1
            if row[i + 1] != y {
                let j = dict[y]!
                row.swapAt(i + 1, j)
                dict[row[i + 1]] = i + 1
                dict[row[j]] = j
                swaps += 1
            }
        }
        return swaps
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。