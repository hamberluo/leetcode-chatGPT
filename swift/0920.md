题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：你的音乐播放器里有 n 首不同的歌，在旅途中，你的旅伴想要听这些歌，但你的播放列表中这些歌曲的顺序是打乱的。请你根据下面的条件返回可以满足旅伴的请求的播放列表的数量：

每首歌都至少播放一次。
一首歌只有在其他 K 首歌播放完之后才能再次播放。
返回可以满足旅伴的请求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

解题思路：动态规划

我们可以使用动态规划来解决这个问题。我们定义 dp[i][j] 表示在播放列表中有 i 首歌，其中有 j 首歌已经播放过的方案数。我们可以考虑最后一首歌是哪一首，如果最后一首歌是一首新歌，那么我们可以从 dp[i-1][j-1] 转移而来，如果最后一首歌是一首已经播放过的歌，那么我们可以从 dp[i-1][j] * (i-1) 转移而来，因为在播放列表中有 i-1 首歌，其中有 j 首歌已经播放过，我们可以选择一首已经播放过的歌，将其放置在最后面，此时有 i-1 种选择方案，因为最后一首歌不能和前面的已经播放过的歌相同。

最终的答案即为 dp[n][L]，其中 L 表示所有歌曲都至少播放一次的情况下已经播放过的歌曲数量。

解决方案：

```swift
func numMusicPlaylists(_ n: Int, _ goal: Int, _ k: Int) -> Int {
    let mod = Int(1e9) + 7
    var dp = [[Int]](repeating: [Int](repeating: 0, count: n+1), count: goal+1)
    dp[0][0] = 1
    for i in 1...goal {
        for j in 1...n {
            dp[i][j] = (dp[i-1][j-1] * (n-j+1)) % mod
            if j > k {
                dp[i][j] = (dp[i][j] + (dp[i-1][j] * (j-k)) % mod) % mod
            }
        }
    }
    return dp[goal][n]
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。