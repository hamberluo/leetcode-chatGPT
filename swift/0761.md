题目编号：761

题目：特殊的二进制序列

难度：困难

考察范围：字符串、递归

题干：一个字符串 S 是特殊的，它满足规则如下：

1. S 长度为偶数
2. S 中的每一个前缀的 0 的数量都要大于等于 1 的数量。
3. S 中 0 和 1 的数量相等。

把一个特殊的二进制序列按照字典序排列，可以得到一个新的特殊的二进制序列。给定一个特殊的二进制序列 S，输出按字典序排列后的第 K 个特殊的二进制序列。

解题思路：本题可以使用递归的思路来解决。首先，我们需要将 S 拆分成若干个特殊的二进制序列，然后对这些序列进行排序，最后将它们拼接起来即可。

具体来说，我们可以将 S 拆分成若干个特殊的二进制序列，然后对这些序列进行排序，最后将它们拼接起来即可。拆分的方法是，找到 S 中最外层的特殊二进制序列，将其拆分成三部分，即 1 开头的特殊二进制序列、0 和剩余部分组成的特殊二进制序列。然后对这两个特殊二进制序列进行递归，直到序列长度为 1。

解决方案：

```swift
class Solution {
    func makeLargestSpecial(_ S: String) -> String {
        var i = 0, count = 0, res = ""
        for j in 0..<S.count {
            count += S[j] == "1" ? 1 : -1
            if count == 0 {
                let sub = S[i+1..<j]
                res += "1" + makeLargestSpecial(sub) + "0"
                i = j + 1
            }
        }
        return String(res.sorted().reversed())
    }
}
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。其中 n 为字符串 S 的长度。