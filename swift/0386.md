题目编号：386

题目：字典序排数

难度：中等

考察范围：递归、深度优先搜索

题干：给定一个整数 n, 返回从 1 到 n 的字典顺序。

例如，给定 n = 13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9]。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。

解题思路：本题可以使用递归或深度优先搜索来解决。我们可以将数字 1 到 9 看作是一棵树的根节点，每个节点的子节点是该节点乘以 10 加上 0 到 9 的结果。例如，节点 1 的子节点为 10、11、12、...、19，节点 2 的子节点为 20、21、22、...、29，以此类推。我们可以使用深度优先搜索来遍历这棵树，并将遍历到的数字加入结果数组中。

解决方案：

```swift
class Solution {
    func lexicalOrder(_ n: Int) -> [Int] {
        var res = [Int]()
        for i in 1...9 {
            dfs(i, n, &res)
        }
        return res
    }
    
    func dfs(_ cur: Int, _ n: Int, _ res: inout [Int]) {
        if cur > n {
            return
        }
        res.append(cur)
        for i in 0...9 {
            if cur * 10 + i > n {
                return
            }
            dfs(cur * 10 + i, n, &res)
        }
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。