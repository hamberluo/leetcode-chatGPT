题目编号：798

题目：得分最高的最小轮调

难度：困难

考察范围：贪心算法

题干：

给定一个数组 A，我们可以将它按一个非负整数 K 进行轮调，这样每个索引对应的值就变成了原数组上移动 K 个位置后的新值。

我们定义一个「轮调操作」为将数组 A 轮调 K 个位置的执行过程。你可以执行任意次数的轮调操作。

返回数组 A 中得分最高的一个方案。

示例 1：

输入：[2,3,1,4,0]
输出：3
解释：
得分最高的方案为 K = 3：
- 将 A[0] 移动到 A[3]，A 数组由 [2,3,1,4,0] 变为 [0,3,1,2,4]
- 将 A[1] 移动到 A[4]，A 数组由 [0,3,1,2,4] 变为 [0,4,1,2,3]
- 将 A[2] 移动到 A[0]，A 数组由 [0,4,1,2,3] 变为 [1,4,0,2,3]
此时得分最高，为 3 分。

解题思路：

本题需要用到贪心算法，我们需要先了解一下题目中的得分规则。

得分规则：

- 对于 A 中的每个元素 A[i]，初始位置为 i，目标位置为 j。
- 每次轮调操作可以将 A 中的一个元素移动到相邻的位置上。
- 如果 A[i] 在 A[j] 的左侧且 A[i] > A[j]，或者 A[i] 在 A[j] 的右侧且 A[i] < A[j]，则称 (i, j) 是一对逆序对。
- 得分为逆序对的数量。

我们可以发现，对于一个元素 A[i]，它的得分只与它的位置和它左右两侧的元素大小有关。因此，我们可以将得分的计算转化为对每个元素的得分计算。

对于一个元素 A[i]，我们需要将它移动到它应该在的位置上，使得它左侧的元素都小于它，右侧的元素都大于它。我们可以先将数组 A 排序，然后将排序后的数组记为 B。对于 B 中的每个元素 B[i]，我们需要将它移动到它在 A 中的位置上，使得它左侧的元素都小于它，右侧的元素都大于它。我们可以用贪心算法来实现这个过程。

具体来说，我们可以从左到右遍历 B，对于每个元素 B[i]，我们需要将它移动到它在 A 中的位置上。我们可以找到 A 中第一个大于等于 B[i] 的元素 A[j]，然后将 B[i] 移动到 A[j] 的左侧。如果不存在这样的元素 A[j]，则将 B[i] 移动到 A 的最右侧。这样可以保证 B[i] 左侧的元素都小于它，右侧的元素都大于它。

解决方案：

```swift
class Solution {
    func bestRotation(_ A: [Int]) -> Int {
        let n = A.count
        var bad = Array(repeating: 0, count: n)
        for i in 0..<n {
            let left = (i - A[i] + 1 + n) % n
            let right = (i + 1) % n
            bad[left] -= 1
            bad[right] += 1
            if left > right {
                bad[0] -= 1
            }
        }
        var bestK = 0
        var cur = 0
        var maxScore = 0
        for i in 0..<n {
            cur += bad[i]
            if cur > maxScore {
                maxScore = cur
                bestK = i + 1
            }
        }
        return bestK
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。