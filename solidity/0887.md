题目编号：887

题目：鸡蛋掉落

难度：困难

考察范围：动态规划、二分查找

题干：

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你需要确定这栋建筑物在最坏情况下，最少需要多少次才能找到鸡蛋恰好摔不碎的楼层。

在最坏情况下确保最少的扔鸡蛋次数。

解题思路：

这是一道经典的动态规划问题，但是直接使用动态规划会超时，因此需要使用二分查找进行优化。

首先，我们定义状态 dp[i][j] 表示有 i 个鸡蛋，最多可以尝试 j 次，最多可以确定的楼层数。

对于每一次尝试，我们可以选择在第 k 层楼扔鸡蛋，如果鸡蛋碎了，那么我们需要在下面的 k-1 层楼中继续尝试，如果鸡蛋没碎，那么我们需要在上面的 N-k 层楼中继续尝试。

因此，我们可以得到状态转移方程：

dp[i][j] = dp[i-1][j-1] + dp[i][j-1] + 1

其中，dp[i-1][j-1] 表示在第 k 层楼扔鸡蛋，鸡蛋碎了，我们需要在下面的 k-1 层楼中继续尝试，因此剩余 i-1 个鸡蛋和 j-1 次尝试机会；dp[i][j-1] 表示在第 k 层楼扔鸡蛋，鸡蛋没碎，我们需要在上面的 N-k 层楼中继续尝试，因此剩余 i 个鸡蛋和 j-1 次尝试机会；1 表示在第 k 层楼扔鸡蛋。

但是，直接使用动态规划会超时，因此需要使用二分查找进行优化。

我们可以将状态转移方程改写为：

dp[i][j] = dp[i-1][j-1] + dp[i][j-1] + 1
         = dp[i-1][j-1] + dp[i-1][j-2] + dp[i][j-1] + 1 - dp[i-1][j-2]
         = dp[i-1][j-1] + dp[i-1][j-2] + dp[i][j-1] + 1 - dp[i-1][j-1] - dp[i][j-2] + dp[i-1][j-2]

我们可以发现，dp[i][j] 只与 dp[i-1][j-1]、dp[i-1][j-2]、dp[i][j-1] 有关，因此可以使用二分查找进行优化。

具体来说，我们可以枚举 k，然后分别计算在第 k 层楼扔鸡蛋时，鸡蛋碎了和没碎两种情况下的最少尝试次数，然后取两种情况下的最大值，即为在第 k 层楼扔鸡蛋时的最少尝试次数。然后，我们可以在剩余的楼层中继续使用二分查找进行递归计算。

解决方案：

```solidity
pragma solidity ^0.8.0;

contract Solution {
    function superEggDrop(uint256 k, uint256 n) public pure returns (uint256) {
        uint256[][] memory dp = new uint256[][](k + 1);
        for (uint256 i = 0; i <= k; i++) {
            dp[i] = new uint256[](n + 1);
        }
        for (uint256 j = 1; j <= n; j++) {
            dp[1][j] = j;
        }
        for (uint256 i = 2; i <= k; i++) {
            uint256 x = 1;
            for (uint256 j = 1; j <= n; j++) {
                while (x < j && dp[i - 1][x - 1] < dp[i][j - x]) {
                    x++;
                }
                dp[i][j] = dp[i - 1][x - 1] + 1;
                if (x > 1) {
                    dp[i][j] = min(dp[i][j], dp[i][j - x] + 1);
                }
            }
        }
        return dp[k][n];
    }

    function min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
}
```

算法复杂度：时间复杂度为 O(knlogn)，空间复杂度为 O(kn)。