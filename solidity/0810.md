题目编号：810

题目：黑板异或游戏

难度：中等

考察范围：位运算、数学

题干：

有一个长度为 n 的非空整数数组，初始时每个数均为正整数。

现在你需要执行 m 个操作，每个操作可以对这个数组进行以下两种修改之一：

1.将数组中下标为偶数的元素都除以 2（下标从 0 开始）。

2.将数组中下标为奇数的元素都减去 1。

你可以执行任意次这两个操作（每个操作都可以使用任意次），请你返回将数组所有元素全部变为 0 的最小操作次数。

解题思路：

我们可以通过数学方法来解决这个问题。我们可以发现，对于一个二进制数，如果它的最后一位是 0，那么将它除以 2 相当于将它右移一位，如果它的最后一位是 1，那么将它减去 1 相当于将它的最后一位变成 0，然后将它右移一位。

因此，我们可以考虑每个数的二进制表示，对于每一位，如果这一位上的数都是偶数，那么我们可以将这一位上的数都右移一位，否则我们需要将这一位上的数都减去 1，然后再右移一位。我们可以用一个数组来记录每一位上的数是否都是偶数，然后根据这个数组来进行操作。

解决方案：

```
pragma solidity ^0.8.0;

contract Solution {
    function minOperations(uint[] memory nums) public view returns (uint) {
        uint n = nums.length;
        uint[] memory bits = new uint[](32);
        for (uint i = 0; i < n; i++) {
            for (uint j = 0; j < 32; j++) {
                if ((nums[i] >> j) & 1 == 1) {
                    bits[j]++;
                }
            }
        }
        uint ans = 0;
        for (uint j = 0; j < 32; j++) {
            if (bits[j] == 0) {
                continue;
            }
            if (j == 0) {
                ans += bits[j];
            } else {
                ans += bits[j] * (1 << j);
                if (bits[j] < n && bits[j - 1] == n - bits[j]) {
                    ans -= (1 << j) - 1;
                }
            }
        }
        return ans;
    }
}
```

算法复杂度：时间复杂度为 O(nlogm)，空间复杂度为 O(logm)，其中 m 为数组中最大的数的二进制位数。