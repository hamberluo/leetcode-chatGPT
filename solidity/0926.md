题目编号：N/A（LeetCode 926）

题目：将字符串中的所有 0 和 1 变成相反的数，使得相邻的数不相同。

难度：中等

考察范围：字符串处理，贪心算法

题干：

给定一个字符串 S，包含若干个 0 和 1。你需要将其中的所有 0 和 1 变成相反的数，使得相邻的数不相同。请你返回能否完成这个任务的最少操作次数。如果不可能完成任务，返回 -1。

解题思路：

这道题可以使用贪心算法来解决。我们可以从左到右遍历字符串，对于每个位置，我们需要判断它应该是 0 还是 1。如果它前面的数是 0，那么它应该是 1；如果它前面的数是 1，那么它应该是 0。如果前面的数还没有确定，那么我们可以随便选一个数。

在确定了当前位置的数之后，我们需要判断它是否和前面的数相同。如果相同，那么我们需要将当前位置的数变成另一个数。这里我们可以选择将当前位置的数变成前面的数的相反数，也可以选择将前面的数变成当前位置的相反数。这里我们选择将当前位置的数变成前面的数的相反数，因为这样可以保证我们只需要修改当前位置的数。

最后，我们需要判断是否存在无法完成任务的情况。如果存在相邻的数相同的情况，那么无论怎么修改都无法满足要求，此时我们需要返回 -1。

解决方案：

```solidity
function minFlipsMonoIncr(string memory S) public view returns (int) {
    int n = int(bytes(S).length);
    int cnt0 = 0; // 统计 0 的个数
    int cnt1 = 0; // 统计 1 的个数
    int ans = n; // 最少操作次数
    for (int i = 0; i < n; i++) {
        if (S[i] == '0') {
            cnt0++;
        } else {
            cnt1++;
        }
        if (cnt1 < cnt0) { // 如果存在相邻的数相同的情况，无法完成任务
            return -1;
        }
        ans = min(ans, cnt1 + n - i - 1 - cnt0); // 更新最少操作次数
    }
    return ans;
}

function min(int a, int b) private pure returns (int) {
    return a < b ? a : b;
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。