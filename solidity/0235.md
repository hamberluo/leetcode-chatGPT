题目编号：235

题目：二叉搜索树的最近公共祖先

难度：简单

考察范围：二叉搜索树、递归

题干：给定一个二叉搜索树（BST），找到 BST 中两个指定节点的最近公共祖先（LCA）。 

解题思路：由于二叉搜索树的特性，左子树的所有节点都小于根节点，右子树的所有节点都大于根节点。因此，我们可以通过比较两个节点的值与当前节点的值的大小关系，来判断它们在当前节点的左子树还是右子树中。如果它们分别在当前节点的左右子树中，那么当前节点就是它们的最近公共祖先。如果它们都在当前节点的左子树中，那么我们继续在左子树中寻找它们的最近公共祖先。如果它们都在当前节点的右子树中，那么我们继续在右子树中寻找它们的最近公共祖先。

解决方案：

```
pragma solidity ^0.8.0;

contract Solution {
    struct TreeNode {
        uint val;
        TreeNode left;
        TreeNode right;
    }

    function lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) public view returns (TreeNode) {
        if (root == null || root == p || root == q) {
            return root;
        }
        if (p.val < root.val && q.val < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        if (p.val > root.val && q.val > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        return root;
    }
}
```

算法复杂度：时间复杂度为 O(h)，其中 h 为树的高度。在最坏的情况下，树是一条链，h=n，时间复杂度为 O(n)。空间复杂度为 O(h)，递归调用的栈空间。