题目编号：N/A

题目：LeetCode 639. Decode Ways II

难度：困难

考察范围：动态规划

题干：

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26

除了上述的条件以外，现在加入了 '*' 这个字符，可以表示 1 到 9 的任意数字。例如，'*' 可以表示 1、2、3、4、5、6、7、8、9 中的任意一个数字。

给定一串数字，返回解码方法的总数。

由于答案数可能非常大，所以返回答案对 10^9 + 7 取余的结果。

示例 1：

输入: "*"
输出: 9
解释: 这个编码可以表示任意数字 1-9 。

示例 2：

输入: "1*"
输出: 18
解释: 这个编码可以表示任意数字 11，12，13，14，15，16，17，18，19。

示例 3：

输入: "2*"
输出: 15
解释: 这个编码可以表示任意数字 21，22，23，24，25，26，27，28，29。
注意，"*" 可以被视为任何数字从 0 到 9 。

解题思路：

这道题是 LeetCode 91. Decode Ways 的升级版，增加了 '*' 这个字符的情况。我们可以使用动态规划来解决这个问题。

我们定义 dp[i] 表示字符串 s 的前 i 个字符的解码方法总数。对于第 i 个字符，我们需要考虑以下情况：

- 如果 s[i] 是数字 1-9，那么它可以单独解码成一个字母，也可以和前面的数字组成一个字母。如果 s[i-1] 是数字 1-9，那么 s[i] 可以和 s[i-1] 组成一个字母，此时 dp[i] = dp[i-1] + dp[i-2]，否则 dp[i] = dp[i-1]。
- 如果 s[i] 是 '*'，那么它可以表示 1-9 中的任意一个数字。如果 s[i-1] 是数字 1-9，那么 s[i] 可以和 s[i-1] 组成一个字母，此时 dp[i] = 9 * dp[i-1] + 2 * dp[i-2]，否则 dp[i] = 9 * dp[i-1] + 15 * dp[i-2]。

最终的答案就是 dp[n]，其中 n 是字符串 s 的长度。

解决方案：

solidity 代码如下：

```solidity
pragma solidity ^0.8.0;

contract Solution {
    function numDecodings(string memory s) public pure returns (uint256) {
        uint256 n = bytes(s).length;
        uint256 mod = 10**9 + 7;
        uint256 dp0 = 1;
        uint256 dp1 = s[0] == '0' ? 0 : (s[0] == '*' ? 9 : 1);
        for (uint256 i = 2; i <= n; i++) {
            uint256 dp2 = 0;
            if (s[i-1] >= '1' && s[i-1] <= '9') {
                dp2 = dp1;
            }
            if (s[i-2] == '1' || (s[i-2] == '2' && s[i-1] >= '0' && s[i-1] <= '6')) {
                dp2 = (dp2 + dp0) % mod;
            }
            if (s[i-2] == '*') {
                dp2 = (dp2 + (s[i-1] >= '0' && s[i-1] <= '6' ? 2 : 1) * dp0) % mod;
            }
            if (s[i-1] == '*') {
                dp2 = (dp2 + 9 * dp1) % mod;
                if (s[i-2] == '1') {
                    dp2 = (dp2 + 9 * dp0) % mod;
                } else if (s[i-2] == '2') {
                    dp2 = (dp2 + 6 * dp0) % mod;
                } else if (s[i-2] == '*') {
                    dp2 = (dp2 + 15 * dp0) % mod;
                }
            }
            dp0 = dp1;
            dp1 = dp2;
        }
        return dp1;
    }
}
```

算法复杂度：

时间复杂度：O(n)，其中 n 是字符串 s 的长度。

空间复杂度：O(1)。