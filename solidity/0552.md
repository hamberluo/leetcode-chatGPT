题目编号：552

题目：学生出勤记录 II

难度：困难

考察范围：动态规划

题干：给定一个正整数 n，表示学生的出勤记录表的大小。记录表中第 i 条记录代表第 i 天学生的出勤情况，共有三个字符（"A", "L", "P"），分别表示“Absent"，"Late" 和 “Present”。如果学生能够同时满足下面两个条件，则被认为是出勤记录良好：

1. 学生不会被处于连续的三个 "A" 记录中。
2. 学生不会同时有两个以上的连续的 "L" 记录。

如果学生记录表中的记录不良好，则需要进行记录修改，以使学生记录表中的记录变得良好。一条记录被视为是可以修改的，如果它不是 "A" 记录，或者是 "L" 记录的最后一个字符，并且其修改后仍然保持记录良好。

编写一个函数来计算学生记录表中记录良好的数量。给定一个整数 n，表示记录的长度（1 ≤ n ≤ 100,000），返回记录中记录良好的数量。答案可能非常大，所以需要返回对 10^9 + 7 取模的结果。

解题思路：本题可以使用动态规划来解决。我们可以定义三个状态：

1. dp[i][0] 表示前 i 天中，A 的数量为 0，且结尾没有连续的 L 的记录的数量。
2. dp[i][1] 表示前 i 天中，A 的数量为 1，且结尾没有连续的 L 的记录的数量。
3. dp[i][2] 表示前 i 天中，A 的数量为 0 或 1，且结尾有一个连续的 L 的记录的数量。

对于第一个状态，我们可以从以下两种状态转移而来：

1. 前一天是 P，今天是 P 或 L。
2. 前一天是 O，今天是 P、L 或 A。

对于第二个状态，我们可以从以下两种状态转移而来：

1. 前一天是 A，今天是 P 或 L。
2. 前一天是 O，今天是 P、L 或 A。

对于第三个状态，我们可以从以下三种状态转移而来：

1. 前一天是 P，今天是 L。
2. 前一天是 O，今天是 L。
3. 前一天是 L，今天是 L。

最终的答案就是 dp[n][0] + dp[n][1] + dp[n][2]。

解决方案：

```solidity
pragma solidity ^0.8.0;

contract Solution {
    function checkRecord(uint n) public pure returns (uint) {
        uint mod = 1e9 + 7;
        uint[3][2] memory dp;
        dp[0][0] = 1;
        for (uint i = 1; i <= n; i++) {
            uint[3][2] memory newDp;
            newDp[0][0] = (dp[0][0] + dp[0][1] + dp[0][2]) % mod;
            newDp[0][1] = dp[0][0];
            newDp[0][2] = dp[0][1];
            newDp[1][0] = (dp[0][0] + dp[0][1] + dp[0][2] + dp[1][0] + dp[1][1] + dp[1][2]) % mod;
            newDp[1][1] = dp[1][0];
            newDp[1][2] = dp[1][1];
            dp = newDp;
        }
        return (dp[0][0] + dp[0][1] + dp[0][2] + dp[1][0] + dp[1][1] + dp[1][2]) % mod;
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。