题目编号：N/A（LeetCode 89）

题目：格雷编码

难度：中等

考察范围：位运算

题干：

给定一个非负整数 n ，表示该数字在格雷编码序列中所处的位置，请输出该数字对应的格雷编码序列。

格雷编码序列必须以 0 开头。

解题思路：

格雷编码是一种二进制编码方式，相邻的两个数只有一位二进制数不同。例如，当 n=2 时，格雷编码序列为 [0,1,3,2]。其中，0 的二进制表示为 00，1 的二进制表示为 01，3 的二进制表示为 11，2 的二进制表示为 10。

我们可以通过位运算来生成格雷编码序列。具体来说，对于给定的 n，我们可以先生成 n-1 的格雷编码序列，然后将其每个数的二进制表示左移一位，并在最高位加上 1，得到新的一半编码序列。然后将新的一半序列与原来的一半序列拼接起来，即可得到 n 的格雷编码序列。

例如，当 n=3 时，我们可以先生成 n=2 的格雷编码序列 [0,1,3,2]，然后将其每个数的二进制表示左移一位，并在最高位加上 1，得到新的一半编码序列 [4,5,7,6]。最后将新的一半序列与原来的一半序列 [0,1,3,2] 拼接起来，即可得到 n=3 的格雷编码序列 [0,1,3,2,6,7,5,4]。

解决方案：

Solidity 代码如下：

```
pragma solidity ^0.8.0;

contract GrayCode {
    function grayCode(uint n) public pure returns (uint[] memory) {
        if (n == 0) {
            return new uint[](1);
        }
        uint[] memory prev = grayCode(n - 1);
        uint[] memory res = new uint[](2 ** n);
        for (uint i = 0; i < prev.length; i++) {
            res[i] = prev[i];
            res[2 ** n - 1 - i] = prev[i] + 2 ** (n - 1);
        }
        return res;
    }
}
```

算法复杂度：时间复杂度为 O(2^n)，空间复杂度为 O(2^n)。