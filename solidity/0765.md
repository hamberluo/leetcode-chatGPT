题目编号：N/A（LeetCode 765）

题目：情侣牵手

难度：困难

考察范围：贪心算法

题干：

有 n 对情侣，编号从 0 到 n-1。其中第 i 对情侣的两个人恰好有编号为 2*i 和 2*i+1。偶数编号和奇数编号分别表示一对情侣。

他们想要进行一些交换。第 i 对想要和第 j 对交换，这里的对数按照最小编号进行计数。

例如，第 0 对想要和第 1 对交换，第 2 对想要和第 3 对交换，这样做的成本为 1+1=2。

我们定义 couples[i] = [x,y] 表示第 i 对情侣的两个人分别是 x 和 y。我们需要使他们的配对情况达成最佳，并输出所有交换的情况，以便他们交换。

示例 1:

输入: row = [0, 2, 1, 3]
输出: 1
解释: 我们只需要交换情侣 1 和 2 的位置即可。
示例 2:

输入: row = [3, 2, 0, 1]
输出: 0
解释: 无需交换任何情侣，因为他们已经配对完全。

解题思路：

本题是一道贪心算法的题目。我们可以从第一对情侣开始，如果他们不是一对，那么我们就需要交换他们的位置，使得他们成为一对。但是，这样交换之后，他们原本的伴侣就会被分开，所以我们需要找到他们的伴侣，并将他们交换到一起。

我们可以使用一个哈希表来存储每个情侣的伴侣的位置，然后从第二对情侣开始，如果他们不是一对，那么我们就需要交换他们的位置，并将他们的伴侣交换到一起。我们可以使用一个变量来记录交换的次数，最后返回这个变量即可。

解决方案：

Solidity 代码如下：

```solidity
pragma solidity ^0.8.0;

contract Solution {
    function minSwapsCouples(uint[] memory row) public pure returns (uint) {
        uint n = row.length;
        uint[] memory pos = new uint[](n);
        for (uint i = 0; i < n; i++) {
            pos[row[i]] = i;
        }
        uint ans = 0;
        for (uint i = 0; i < n; i += 2) {
            uint x = row[i];
            uint y = x ^ 1;
            if (row[i + 1] != y) {
                uint j = pos[y];
                row[j] = row[i + 1];
                row[i + 1] = y;
                pos[row[j]] = j;
                pos[y] = i + 1;
                ans++;
            }
        }
        return ans;
    }
}
```

算法复杂度：O(n)。