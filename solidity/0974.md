题目编号：974

题目：和可被 K 整除的子数组

难度：中等

考察范围：前缀和、哈希表

题干：

给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

示例 1：

输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]

解题思路：

本题可以使用前缀和和哈希表来解决。

首先，我们可以用前缀和来计算每个子数组的和，然后用哈希表来记录每个前缀和对 K 取模的余数出现的次数。

具体来说，我们可以从左往右遍历数组，计算当前前缀和 sum，然后计算 sum 对 K 取模的余数 mod。如果 mod 为负数，我们需要将其加上 K，因为我们需要在哈希表中统计正数的出现次数。

接下来，我们将当前前缀和对 K 取模的余数的出现次数加入哈希表中。如果在遍历到当前位置时，哈希表中已经存在前缀和对 K 取模的余数为 mod 的记录，那么说明我们已经找到了一个子数组的和可以被 K 整除，那么我们将答案加上该余数在哈希表中出现的次数即可。

最后，我们返回答案即可。

解决方案：

```solidity
pragma solidity ^0.8.0;

contract Solution {
    function subarraysDivByK(int[] memory A, int K) public pure returns (int) {
        mapping<int, int> mp;
        mp[0] = 1;
        int sum = 0, ans = 0;
        for (uint i = 0; i < A.length; i++) {
            sum += A[i];
            int mod = sum % K;
            if (mod < 0) mod += K;
            if (mp.find(mod) != mp.end()) {
                ans += mp[mod];
            }
            mp[mod]++;
        }
        return ans;
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。