题目编号：975

题目：奇偶跳

难度：困难

考察范围：动态规划、有序集合

题干：

给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。

你可以按以下方式从索引 i 向前或向后跳转：

在奇数跳跃中（如，第 1，3，5，... 跳跃），你将跳到索引 j，使得 A[i] <= A[j]，A[j] 是可能的最小值。如果有多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。
在偶数跳跃中（如，第 2，4，6，... 跳跃），你将跳到索引 j，使得 A[i] >= A[j]，A[j] 是可能的最大值。如果有多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。
（对于某些索引 i，可能无法进行合法的跳跃。）

从某一起始索引开始，正好进行奇数次跳跃跳到结束的位置，称为奇数跳跃结束位置。同样，如果正好进行偶数次跳跃跳到结束的位置，称为偶数跳跃结束位置。

例如，从索引 0 开始，你可以按奇数跳跃跳到索引 1，然后按偶数跳跃跳到索引 2，然后你无法进行下一步跳跃。因此，这个起始索引的奇数跳跃结束位置为 1，偶数跳跃结束位置为 2。

以这种方式跳跃，从索引 i 能够到达的所有位置（包括 i）形成了一个上升序列。定义这样的序列的长度为跳跃长度。找到最长的上升序列并返回其长度。

示例 1：

输入：[10,13,12,14,15]
输出：2
解释：
从起始索引 i = 0 出发，有以下跳跃路径：
奇数跳跃：跳到 A[1]（值为 13），跳跃长度 = 1
偶数跳跃：跳到 A[2]（值为 12），跳跃长度 = 2
奇数跳跃：跳到 A[3]（值为 14），跳跃长度 = 3
偶数跳跃：无法跳跃到其他位置。
从起始索引 i = 1 出发，有以下跳跃路径：
奇数跳跃：跳到 A[2]（值为 12），跳跃长度 = 1
偶数跳跃：跳到 A[3]（值为 14），跳跃长度 = 2
奇数跳跃：跳到 A[4]（值为 15），跳跃长度 = 3
偶数跳跃：无法跳跃到其他位置。
从起始索引 i = 2 出发，有以下跳跃路径：
奇数跳跃：跳到 A[3]（值为 14），跳跃长度 = 1
偶数跳跃：无法跳跃到其他位置。
从起始索引 i = 3 出发，有以下跳跃路径：
奇数跳跃：跳到 A[4]（值为 15），跳跃长度 = 1
偶数跳跃：无法跳跃到其他位置。
从起始索引 i = 4 出发，只能进行偶数跳跃，无法跳跃到其他位置。
因此，最长的上升序列是 [10, 13, 12, 14, 15]，跳跃长度为 2。

解题思路：

本题可以使用动态规划来解决，具体思路如下：

1. 定义两个数组 odd 和 even，其中 odd[i] 表示从第 i 个位置开始进行奇数跳跃能够到达的最远位置，even[i] 表示从第 i 个位置开始进行偶数跳跃能够到达的最远位置。

2. 从后往前遍历数组 A，对于每个位置 i，使用有序集合（如红黑树）来查找 odd 数组中比 A[i] 大的最小值和 even 数组中比 A[i] 小的最大值，如果找到了这两个值，则更新 odd[i] 和 even[i]。

3. 最后遍历 odd 数组，统计能够到达数组末尾的位置数量即为最长上升序列的长度。

解决方案：

```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var oddEvenJumps = function(A) {
    const n = A.length;
    const odd = new Array(n).fill(0);
    const even = new Array(n).fill(0);
    odd[n - 1] = even[n - 1] = 1;
    const map = new Map();
    map.set(A[n - 1], n - 1);
    let ans = 1;
    for (let i = n - 2; i >= 0; i--) {
        const val = A[i];
        const ceil = map.ceilingKey(val);
        const floor = map.floorKey(val);
        if (ceil !== null) {
            odd[i] = even[map.get(ceil)];
        }
        if (floor !== null) {
            even[i] = odd[map.get(floor)];
        }
        if (odd[i]) {
            ans++;
        }
        map.set(val, i);
    }
    return ans;
};
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。