题目编号：549

题目：二叉树中最长的连续序列

难度：中等

考察范围：二叉树、递归、深度优先搜索

题干：给定一个二叉树，你需要找出其中最长的连续序列路径的长度。请注意，该路径可以是递增的或递减的。例如，[1,2,3,4] 和 [4,3,2,1] 都被视为合法的序列。

解题思路：本题可以使用深度优先搜索（DFS）来解决。对于每个节点，我们需要知道它的左右子树中最长的连续序列路径长度，然后根据当前节点的值和左右子树的值来更新最长连续序列路径长度。具体来说，我们可以定义一个递归函数 `dfs(node)`，它返回以 `node` 为根节点的子树中最长的连续序列路径长度。在递归函数中，我们首先递归计算出左右子树的最长连续序列路径长度 `left` 和 `right`，然后根据当前节点的值和左右子树的值来更新最长连续序列路径长度 `res`。具体来说，如果当前节点的值等于左子节点的值加 1，那么我们可以将当前节点加入到左子树的最长连续序列路径中，否则左子树的最长连续序列路径长度为 0；同理，如果当前节点的值等于右子节点的值加 1，那么我们可以将当前节点加入到右子树的最长连续序列路径中，否则右子树的最长连续序列路径长度为 0。最后，我们将左右子树的最长连续序列路径长度加上 1（当前节点本身），得到以当前节点为根节点的子树中最长的连续序列路径长度。

解决方案：

```javascript
var longestConsecutive = function(root) {
    let res = 0;
    const dfs = (node) => {
        if (!node) return 0;
        let left = dfs(node.left);
        let right = dfs(node.right);
        if (node.left && node.left.val === node.val + 1) {
            left += 1;
        } else {
            left = 1;
        }
        if (node.right && node.right.val === node.val + 1) {
            right += 1;
        } else {
            right = 1;
        }
        res = Math.max(res, left, right);
        return Math.max(left, right);
    }
    dfs(root);
    return res;
};
```

算法复杂度：时间复杂度为 O(n)，其中 n 是二叉树中的节点数，因为我们需要遍历每个节点一次。空间复杂度为 O(h)，其中 h 是二叉树的高度，因为递归函数需要调用 h 次。