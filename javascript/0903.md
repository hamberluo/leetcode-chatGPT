题目编号：903

题目：DI 序列

难度：困难

考察范围：动态规划

题干：我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）
有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：

如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；
如果 S[i] == 'I'，那么 P[i] < P[i+1]。
如同答案一样，'D' 和 'I' 之间的空白被视为减少和增加的交替使用。

给定一个有效排列 P，如果存在将其变为数组的方法，请返回可行的任何一个 [1, 2, ..., n] 的排列，使其变为 P。否则，返回一个空数组。

解题思路：动态规划

我们可以用动态规划来解决这个问题。我们定义 dp[i][j] 表示前 i 个数中，最后一个数为 j 的方案数。其中 j 的范围是 [0, n]，因为我们需要在最后一个数后面添加一个数。

对于 S[i] == 'D' 的情况，我们需要找到前 i - 1 个数中，最后一个数小于 j 的方案数之和。因为我们需要在最后一个数后面添加一个比它小的数，所以我们需要找到前 i - 1 个数中，最后一个数小于 j 的方案数之和。因此，我们可以得到状态转移方程：

dp[i][j] = sum(dp[i-1][k])，其中 k < j

对于 S[i] == 'I' 的情况，我们需要找到前 i - 1 个数中，最后一个数大于 j 的方案数之和。因为我们需要在最后一个数后面添加一个比它大的数，所以我们需要找到前 i - 1 个数中，最后一个数大于 j 的方案数之和。因此，我们可以得到状态转移方程：

dp[i][j] = sum(dp[i-1][k])，其中 k > j

最终的答案是 dp[n][0] 到 dp[n][n] 的和。

解决方案：

```javascript
var findPermutation = function(s) {
    const n = s.length;
    const dp = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0));
    dp[0][0] = 1;
    for (let i = 1; i <= n; i++) {
        if (s[i-1] === 'D') {
            for (let j = i-1; j >= 0; j--) {
                for (let k = j; k <= i-1; k++) {
                    dp[i][j] += dp[i-1][k];
                }
            }
        } else {
            for (let j = 1; j <= i; j++) {
                for (let k = 0; k < j; k++) {
                    dp[i][j] += dp[i-1][k];
                }
            }
        }
    }
    const ans = new Array(n+1).fill(0);
    let cur = 1;
    for (let i = n; i >= 1; i--) {
        let j = 0;
        while (cur + dp[i][j] <= cur) {
            dp[i][j] = 0;
            j++;
        }
        ans[i] = cur + dp[i][j];
        cur = ans[i];
    }
    return ans.slice(1);
};
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。