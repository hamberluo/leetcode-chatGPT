题目编号：413

题目：等差数列划分

难度：中等

考察范围：动态规划

题干：如果一个数列至少有三个元素，且任意两个相邻元素之差相同，则称该数列为等差数列。例如，以下数列为等差数列:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
以下数列不是等差数列。

1, 1, 2, 5, 7

数组 A 包含 N 个数，且索引从0开始。数组中任意三个下标 (P, Q, R) 满足 0 <= P < Q < R < N。

函数要返回数组 A 中所有为等差数组的子数组个数。

解题思路：动态规划

我们可以用 dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。我们可以从前往后依次计算 dp[i] 的值，假设我们已经计算出了 dp[0] 到 dp[i-1] 的值，考虑如何计算 dp[i]。

我们可以从前往后枚举 j，其中 j<i，此时 A[j] 和 A[i] 可以形成一个等差递增子区间，假设该等差递增子区间的公差为 d，则因为区间长度至少为 3，所以该等差递增子区间的起点的下标为 i-2，终点的下标为 i，因此以 A[i] 为结尾的等差递增子区间的个数就可以加上以 A[j] 为结尾且公差为 d 的等差递增子区间的个数，即 dp[i]+=dp[j]+1。

最终的答案即为所有 dp[i] 的值之和。

解决方案：

```javascript
var numberOfArithmeticSlices = function(A) {
    const n = A.length;
    if (n < 3) {
        return 0;
    }
    const dp = new Array(n).fill(0);
    for (let i = 2; i < n; i++) {
        if (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {
            dp[i] = dp[i - 1] + 1;
        }
    }
    return dp.reduce((a, b) => a + b);
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。