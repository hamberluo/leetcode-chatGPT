题目编号：330

题目：按要求补齐数组

难度：困难

考察范围：贪心算法

题干：给定一个已排序的正整数数组 nums，和一个正整数 n。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

解题思路：贪心算法

首先，我们需要明确一个结论：如果区间 [1, x-1] 内的所有数字都已经被覆盖，且 x 在数组中，则区间 [1, 2x-1] 内的所有数字也都被覆盖。

假设区间 [1, x-1] 内的所有数字都已经被覆盖，且 x 在数组中，对于任意 1 <= y <= x-1，由于 y 已经被覆盖，因此 y+x 也一定被覆盖，即区间 [x, 2x-1] 内的所有数字都被覆盖。假设区间 [1, x-1] 内的所有数字都已经被覆盖，且 x 不在数组中，由于数组中缺少 x，因此我们需要在数组中补充 x，补充后可以覆盖的区间为 [1, 2x-1]，由此可得结论。

基于上述结论，我们可以维护一个变量 miss，表示区间 [1, miss) 内的所有数字都已经被覆盖。初始时，miss=1，表示区间 [1, 0] 内的所有数字都已经被覆盖。对于数组中的每个元素 x，如果 x <= miss，则将区间 [1, x) 内的所有数字都标记为已覆盖，将 miss 更新为 2x。如果 x > miss，则说明区间 [1, miss) 内的所有数字都已经被覆盖，由于 x 比 miss 大，因此我们需要在数组中补充 miss，补充后可以覆盖的区间为 [1, 2miss-1)，将 miss 更新为 2miss。

最终，如果区间 [1, n] 内的所有数字都被覆盖，则不需要补充数字，否则需要补充的数字个数即为区间 [1, n] 内未被覆盖的数字个数。

解决方案：

```javascript
var minPatches = function(nums, n) {
    let patches = 0, miss = 1, i = 0;
    while (miss <= n) {
        if (i < nums.length && nums[i] <= miss) {
            miss += nums[i];
            i++;
        } else {
            miss += miss;
            patches++;
        }
    }
    return patches;
};
```

算法复杂度：时间复杂度为 O(log n)，空间复杂度为 O(1)。