题目编号：894

题目：所有可能的满二叉树

难度：中等

考察范围：二叉树、递归、动态规划

题干：

给定一个正整数 `n`，返回所有可能的满二叉树，其节点数为 `n`。满二叉树的定义如下：

1. 节点数为偶数，左右子树节点数相同
2. 节点数为奇数，左子树节点数比右子树节点数多1

解题思路：

对于满二叉树，我们可以发现，其节点数一定是奇数，因为根节点算一个，每个子树的节点数都是偶数，所以总节点数一定是奇数。

我们可以用递归的思想来解决这个问题。对于一个节点数为 `n` 的满二叉树，我们可以将其分为左右两个子树，左子树节点数为 `i`，右子树节点数为 `n-i-1`，其中 `-1` 是因为根节点也算一个。

我们可以枚举 `i` 的取值，从 `1` 到 `n-2`，因为当 `i=0` 或 `i=n-1` 时，左子树或右子树为空，不符合满二叉树的定义。

对于每个 `i`，我们递归求解左右子树的所有可能性，然后将左右子树的所有可能性进行组合，得到当前节点数为 `n` 的所有可能的满二叉树。

解决方案：

```javascript
var allPossibleFBT = function(n) {
    if (n % 2 === 0) { // 节点数为偶数，不是满二叉树
        return [];
    }
    if (n === 1) { // 只有一个节点，返回只包含根节点的满二叉树
        return [new TreeNode(0)];
    }
    const res = [];
    for (let i = 1; i < n - 1; i += 2) { // 枚举左子树节点数
        const leftTrees = allPossibleFBT(i); // 左子树所有可能的满二叉树
        const rightTrees = allPossibleFBT(n - i - 1); // 右子树所有可能的满二叉树
        for (const left of leftTrees) { // 组合左右子树
            for (const right of rightTrees) {
                const root = new TreeNode(0); // 创建根节点
                root.left = left;
                root.right = right;
                res.push(root);
            }
        }
    }
    return res;
};
```

算法复杂度：时间复杂度为 O(2^n)，空间复杂度为 O(2^n)，其中 n 是节点数。因为每个节点都有可能是根节点，所以总共有 2^n 种可能的满二叉树。递归栈的深度也是 O(n) 级别的。