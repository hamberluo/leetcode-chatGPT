题目编号：78

题目：子集

难度：中等

考察范围：数组、回溯算法

题干：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

解题思路：回溯算法

回溯算法是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，而在前面的一些步骤做出一些修改，并重新尝试找到可行解。

对于这道题，我们可以使用回溯算法来求解所有子集。具体思路如下：

1. 定义一个结果数组 res，用来存储所有子集；
2. 定义一个回溯函数 backtrack，它接收三个参数：当前子集、起始位置、原数组；
3. 在回溯函数中，首先将当前子集加入到结果数组 res 中；
4. 然后从起始位置开始遍历原数组，将当前元素加入到子集中，并递归调用 backtrack 函数；
5. 递归调用结束后，将当前元素从子集中删除，继续遍历原数组；
6. 当遍历结束后，回溯函数结束。

解决方案：

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    const res = [];
    const backtrack = (path, start) => {
        res.push(path.slice()); // 将当前子集加入到结果数组中
        for (let i = start; i < nums.length; i++) {
            path.push(nums[i]); // 将当前元素加入到子集中
            backtrack(path, i + 1); // 递归调用 backtrack 函数
            path.pop(); // 将当前元素从子集中删除
        }
    }
    backtrack([], 0); // 调用回溯函数
    return res;
};
```

算法复杂度：时间复杂度为 O(2^n)，空间复杂度为 O(n)。其中，n 为原数组的长度。