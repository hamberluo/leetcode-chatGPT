题目编号：799

题目：香槟塔

难度：困难

考察范围：动态规划

题干：我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，……，第n层有n个。

每个玻璃杯可以装一定的香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，依此类推（当最底层的玻璃杯满了，香槟会流到地板上）。

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满了的玻璃杯：顶层的一个和第二层的两个，我们让其中的一个杯子溢出，其余均分为半。

给定一个整数 poured 表示你倾倒的总香槟量，返回第 i 行第 j 个玻璃杯所盛放的香槟量（下标从 1 开始）。

解题思路：动态规划

首先，我们可以将题目中的金字塔转化为一个二维数组，数组中的每个元素表示对应位置的杯子中香槟的数量。我们可以使用动态规划的思想来解决这个问题。

我们定义 dp[i][j] 表示第 i 行第 j 个杯子中香槟的数量。对于第一行的杯子，它们的香槟数量就是 poured。对于其他行的杯子，它们的香槟数量可以由上一行的杯子流出的香槟和当前杯子自身的香槟相加得到。

具体来说，对于第 i 行第 j 个杯子，它可以从第 i-1 行的第 j-1 和 j 个杯子中流出香槟，因此它的香槟数量可以由下面的公式得到：

dp[i][j] = max(0, (dp[i-1][j-1] - 1) / 2) + max(0, (dp[i-1][j] - 1) / 2)

其中，max(0, x) 表示将 x 和 0 取较大值，因为香槟的数量不能为负数。

最后，我们只需要返回 dp[row-1][glass-1] 即可，其中 row 表示金字塔的行数，glass 表示要求的杯子所在的行数。

解决方案：

```javascript
var champagneTower = function(poured, query_row, query_glass) {
    const dp = new Array(101).fill(0).map(() => new Array(101).fill(0));
    dp[0][0] = poured;
    for (let i = 1; i <= query_row; i++) {
        for (let j = 0; j <= i; j++) {
            dp[i][j] += Math.max(0, (dp[i-1][j-1] - 1) / 2);
            dp[i][j] += Math.max(0, (dp[i-1][j] - 1) / 2);
        }
    }
    return Math.min(1, dp[query_row][query_glass]);
};
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。其中，n 表示金字塔的行数。