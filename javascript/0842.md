题目编号：842

题目：将数组拆分成斐波那契序列

难度：中等

考察范围：回溯算法、字符串处理

题干：给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。

形式上，斐波那契式序列是一个非负整数列表 F，且满足：

0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；
F.length >= 3；
对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。
另外，注意：可以认为斐波那契式序列中不含有任何前导零，且不能使用 2^31 - 1 作为其中一个元素。

给定一个数字字符串 S，编写一个算法来返回一个可能符合条件的斐波那契式序列的最大长度。

解题思路：回溯算法

这道题目可以使用回溯算法来解决。我们可以从字符串的第一个位置开始，枚举前两个数，然后依次往后枚举下一个数，判断是否符合斐波那契数列的定义。如果符合，就继续往后枚举下一个数，否则就回溯到上一个位置，重新枚举前两个数。

需要注意的是，题目中要求不能使用 2^31 - 1 作为其中一个元素，因此在判断一个数是否符合要求时，需要判断它是否等于 0 或者它的前导数字不为 0。

解决方案：

```javascript
var splitIntoFibonacci = function(S) {
    const res = [];
    const dfs = (start, prev1, prev2) => {
        if (start === S.length) {
            return res.length >= 3;
        }
        let cur = 0;
        for (let i = start; i < S.length; i++) {
            cur = cur * 10 + parseInt(S[i]);
            if (cur > Math.pow(2, 31) - 1) {
                break;
            }
            if (res.length >= 2) {
                if (cur < prev1 + prev2) {
                    continue;
                } else if (cur > prev1 + prev2) {
                    break;
                }
            }
            res.push(cur);
            if (dfs(i + 1, prev2, cur)) {
                return true;
            }
            res.pop();
            if (S[start] === '0') {
                break;
            }
        }
        return false;
    }
    dfs(0, 0, 0);
    return res;
};
```

算法复杂度：时间复杂度为 O(n^2)，其中 n 是字符串 S 的长度。在回溯的过程中，每个位置最多只会被访问一次，因此时间复杂度为 O(n)。在判断一个数是否符合要求时，需要将它转换成整数，因此时间复杂度为 O(n)。总时间复杂度为 O(n^2)。空间复杂度为 O(n)，其中 n 是字符串 S 的长度。回溯算法的空间复杂度取决于递归的深度，最坏情况下递归的深度为 n。