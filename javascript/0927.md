题目编号：927

题目：三等分

难度：困难

考察范围：数组、双指针

题干：给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。

如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：

A[0], A[1], ..., A[i] 组成第一部分；
A[i+1], A[i+2], ..., A[j-1] 作为第二部分；
A[j], A[j+1], ..., A[A.length - 1] 是第三部分。
这三个部分所表示的二进制值相等。如果无法做到，就返回 [-1, -1]。

注意，在考虑每个部分所表示的二进制值时，应将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。

解题思路：首先统计数组中 1 的个数，如果 1 的个数不能被 3 整除，那么无法分成三等分，返回 [-1, -1]。然后从数组两端开始，分别找到第一个和第二个等于 1 的位置，这两个位置分别作为第一部分和第二部分的结束位置，然后再找到第三个等于 1 的位置，这个位置作为第二部分的结束位置，最后判断三个部分所表示的二进制值是否相等即可。

解决方案：

```javascript
var threeEqualParts = function(A) {
    const n = A.length;
    let cnt = 0;
    for (let i = 0; i < n; i++) {
        if (A[i] === 1) cnt++;
    }
    if (cnt % 3 !== 0) return [-1, -1];
    if (cnt === 0) return [0, n - 1];
    const k = cnt / 3;
    let i = 0, j = n - 1;
    let cnt1 = 0, cnt2 = 0, cnt3 = 0;
    while (cnt1 < k) {
        if (A[i] === 1) cnt1++;
        i++;
    }
    while (cnt2 < k) {
        if (A[j] === 1) cnt2++;
        j--;
    }
    while (A[i] === 0) i++;
    while (cnt3 < k) {
        if (A[i] === 1) cnt3++;
        i++;
    }
    i--;
    while (A[j] === 0) j--;
    while (cnt3 < k) {
        if (A[j] === 1) cnt3++;
        j--;
    }
    j++;
    const s1 = A.slice(0, i + 1).join('');
    const s2 = A.slice(i + 1, j).join('');
    const s3 = A.slice(j).join('');
    if (s1 === s2 && s2 === s3) {
        return [i, j];
    } else {
        return [-1, -1];
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。