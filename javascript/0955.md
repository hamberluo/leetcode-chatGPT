题目编号：955

题目：删列造序 II

难度：中等

考察范围：贪心算法、字符串处理

题干：给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。

选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。

比如，有 A = ["abcdef", "uvwxyz"]，删除索引序列 {0, 2, 3}，删除后 A 为["bef", "vyz"]。

假设，我们选择了一组删除索引 D，那么在执行删除操作之后，A 中剩余的每一列都必须是非降序排列的，即 A[0][j] <= A[1][j] <= A[2][j] <= ... <= A[A.length-1][j]，其中 0 <= j < A[0].length。

那么请你返回 D.length 的最小可能值。

解题思路：贪心算法

首先，我们需要明确一点，如果一个字符串在某个位置上的字符被删除了，那么这个字符串在这个位置之后的字符都会向前移动一位，因此，我们可以将删除操作看作是将字符串中某些字符向前移动的操作。

接下来，我们考虑如何判断一个删除索引序列是否符合题目要求。我们可以遍历每个字符串的每个字符，如果发现某个字符在删除索引序列中，那么我们就需要判断这个字符是否可以被删除。如果这个字符可以被删除，那么我们就将它删除，并将删除操作记录下来。如果这个字符不能被删除，那么我们就需要将删除索引序列中的下一个索引作为当前索引，继续判断下一个字符。

在判断一个字符是否可以被删除时，我们需要考虑这个字符在当前字符串中的位置以及它前面的字符是否已经被删除。具体来说，如果一个字符在当前字符串中的位置比前面的字符串中相同位置的字符要靠前，那么它不能被删除。因为如果删除了这个字符，那么它前面的字符就会向后移动一位，这样就会破坏前面字符串的非降序排列。如果一个字符在当前字符串中的位置比前面的字符串中相同位置的字符要靠后，那么它可以被删除。

在判断一个字符是否可以被删除时，我们还需要考虑它前面的字符是否已经被删除。如果一个字符前面的字符已经被删除了，那么它可以被删除。

最后，我们需要注意的是，删除操作的顺序是可以任意的，因此我们可以使用贪心算法，每次选择可以删除的字符中最靠前的一个进行删除。

解决方案：

```javascript
/**
 * @param {string[]} A
 * @return {number}
 */
var minDeletionSize = function(A) {
    const n = A.length;
    const m = A[0].length;
    let ans = 0;
    const deleted = new Array(m).fill(false);
    for (let j = 0; j < m; j++) {
        let i = 0;
        for (; i < n - 1; i++) {
            if (!deleted[i] && A[i][j] > A[i + 1][j]) {
                ans++;
                break;
            }
        }
        if (i < n - 1) {
            continue;
        }
        for (i = 0; i < n - 1; i++) {
            if (A[i][j] < A[i + 1][j]) {
                deleted[i] = true;
            }
        }
    }
    return ans;
};
```

算法复杂度：时间复杂度为 O(nm^2)，空间复杂度为 O(m)。其中，n 是字符串数组 A 的长度，m 是每个字符串的长度。