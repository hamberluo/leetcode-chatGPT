题目编号：948

题目：令牌放置

难度：中等

考察范围：动态规划

题干：你的初始能量为 P，初始分数为 0，只有一包令牌。令牌有三种可能的操作：

增加 1 分数，减少 1 能量。
增加 1 分数，增加 0 能量。
减少 1 分数，增加 1 能量。
你可以按任意顺序进行以下两个步骤：

选取任意个令牌，每个令牌可以使用任意次数，但是其分数和能量消耗必须为正整数。
得到一些分数和/或能量。
答案即为最终分数。

解题思路：动态规划

首先，我们可以将令牌分为两类：增加分数的令牌和增加能量的令牌。对于增加分数的令牌，我们可以将其分为两类：需要消耗能量的令牌和不需要消耗能量的令牌。同样地，对于增加能量的令牌，我们也可以将其分为两类：需要消耗分数的令牌和不需要消耗分数的令牌。

我们可以使用动态规划来解决这个问题。设 dp[i][j] 表示在前 i 个令牌中，能量为 j 时所能获得的最大分数。对于每个令牌，我们可以选择使用它或不使用它。如果选择使用它，那么我们需要根据令牌的类型来更新 dp 数组。具体来说，如果这个令牌是增加分数的令牌，那么我们需要考虑它是否需要消耗能量。如果需要消耗能量，那么我们需要从 dp[i-1][j-1] 转移而来；否则，我们需要从 dp[i-1][j] 转移而来。如果这个令牌是增加能量的令牌，那么我们需要考虑它是否需要消耗分数。如果需要消耗分数，那么我们需要从 dp[i-1][j+1] 转移而来；否则，我们需要从 dp[i-1][j] 转移而来。

最终的答案即为 dp[n][P]，其中 n 表示令牌的数量。

解决方案：

```javascript
var bagOfTokensScore = function(tokens, P) {
    const n = tokens.length;
    tokens.sort((a, b) => a - b);
    let left = 0, right = n - 1;
    let score = 0, maxScore = 0;
    while (left <= right) {
        if (P >= tokens[left]) {
            P -= tokens[left++];
            score++;
            maxScore = Math.max(maxScore, score);
        } else if (score > 0) {
            P += tokens[right--];
            score--;
        } else {
            break;
        }
    }
    return maxScore;
};
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(1)。