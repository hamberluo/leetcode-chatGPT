题目编号：765

题目：情侣牵手

难度：困难

考察范围：贪心算法

题干：

N对情侣坐在2N个座位上，其中一些座位已经有人坐了。情侣们的位置按照编号从0到2N-1，情侣们之间的关系是固定的，即第i对情侣的两个人的编号为2i和2i+1。他们想要坐在一起，但是一些座位已经被其他人占了。他们只能坐在没有人坐的座位上。情侣们之间的距离是他们座位编号的差的绝对值。例如，如果第一对情侣想坐在位置0和位置3上，那么他们之间的距离为3，而不是1。

返回情侣们之间的最小总距离，以便他们可以都坐在一起。

示例1：

输入：row = [0, 2, 1, 3]
输出：1
解释：我们只需要交换位置一次，即可让第一对情侣坐在一起，距离为1。

示例2：

输入：row = [3, 2, 0, 1]
输出：0
解释：没有需要交换的情侣位置，他们已经都坐在一起了。

解题思路：

本题是一道贪心算法的题目，我们可以从第一对情侣开始，找到他们应该坐的位置，然后将他们坐到正确的位置上，再找下一对情侣，直到所有情侣都坐到了正确的位置上。

我们可以用一个哈希表来记录每个人的位置，然后从第一对情侣开始，找到他们应该坐的位置，如果他们没有坐到正确的位置上，就将他们与他们应该坐的位置上的人交换位置，然后更新哈希表。接着找下一对情侣，直到所有情侣都坐到了正确的位置上。

解决方案：

```javascript
var minSwapsCouples = function(row) {
    let n = row.length;
    let pos = new Array(n);
    for (let i = 0; i < n; i++) {
        pos[row[i]] = i;
    }
    let ans = 0;
    for (let i = 0; i < n; i += 2) {
        let x = row[i];
        let y = x ^ 1;
        if (row[i + 1] !== y) {
            let j = pos[y];
            row[i + 1] = y;
            row[j] = x;
            pos[x] = j;
            pos[y] = i + 1;
            ans++;
        }
    }
    return ans;
};
```

算法复杂度：时间复杂度为O(n)，空间复杂度为O(n)。