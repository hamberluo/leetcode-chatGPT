题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许重复歌曲）。请你为她按如下规则创建一个播放列表：

每首歌至少播放一次。
一首歌只有在其他 K 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

解题思路：动态规划

我们可以使用动态规划来解决这个问题。我们定义 dp[i][j] 表示在播放列表中有 i 首歌，其中有 j 首不同的歌的方案数。我们可以考虑最后一首歌是否是新的歌。

如果最后一首歌是新的歌，那么我们可以从 dp[i-1][j-1] 转移而来，表示我们从 i-1 首歌中选择了 j-1 首不同的歌，然后在最后一首歌上选择一个新的歌。

如果最后一首歌不是新的歌，那么我们可以从 dp[i-1][j] 转移而来，表示我们从 i-1 首歌中选择了 j 首不同的歌，然后在最后一首歌上选择了一首已经播放过的歌。

因此，我们可以得到状态转移方程：

dp[i][j] = dp[i-1][j-1] * (N-j+1) + dp[i-1][j] * max(j-K, 0)

其中，第一项表示我们选择了一首新的歌，第二项表示我们选择了一首已经播放过的歌。

最终的答案即为 dp[L][N]。

解决方案：

```javascript
var numMusicPlaylists = function(N, L, K) {
    const MOD = 1e9 + 7;
    const dp = new Array(L+1).fill(0).map(() => new Array(N+1).fill(0));
    dp[0][0] = 1;
    for (let i = 1; i <= L; i++) {
        for (let j = 1; j <= N; j++) {
            dp[i][j] = (dp[i-1][j-1] * (N-j+1) + dp[i-1][j] * Math.max(j-K, 0)) % MOD;
        }
    }
    return dp[L][N];
};
```

算法复杂度：时间复杂度为 O(NL)，空间复杂度为 O(NL)。