题目编号：834

题目：树中距离之和

难度：困难

考察范围：树、动态规划

题干：给定一个无向、连通的树。树中有 N 个标记为 0...N-1 的节点以及 N-1 条边 。

第 i 条边连接节点 edges[i][0] 和 edges[i][1] 。

返回一个表示节点 i 与其他所有节点距离之和的列表 ans。

示例 1:

输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
输出: [8,12,6,10,10,10]
解释:
如下为给定的树的示意图：
  0
 / \
1   2
   /|\
  3 4 5
我们可以计算出以下每个节点与其他所有节点之间的距离:
- 节点 0：距离为 1+1+2+2+2=8。
- 节点 1：距离为 1+2+2+2+2=9。
- 节点 2：距离为 2+1+1+1+1=6。
- 节点 3：距离为 2+1+1+1+2=7。
- 节点 4：距离为 2+1+1+1+2=7。
- 节点 5：距离为 2+1+1+1+2=7。
因此，我们返回 [8,12,6,10,10,10]。

解题思路：本题需要计算每个节点与其他所有节点之间的距离之和，可以考虑使用动态规划的思想，先计算出每个节点到其它节点的距离，再将距离相加得到答案。

具体来说，我们可以先使用 DFS 遍历树，计算出每个节点到其它节点的距离，然后再将距离相加得到答案。具体实现时，我们可以使用两个数组，分别记录每个节点到其它节点的距离和每个节点的子节点个数，然后再遍历一次树，计算出每个节点到其它节点的距离之和。

解决方案：

```javascript
var sumOfDistancesInTree = function(N, edges) {
    // 初始化邻接表和距离数组
    const graph = new Array(N).fill(0).map(() => []);
    const dist = new Array(N).fill(0);
    // 初始化子节点个数数组
    const count = new Array(N).fill(1);
    // 构建邻接表
    for (const [u, v] of edges) {
        graph[u].push(v);
        graph[v].push(u);
    }
    // DFS 计算每个节点到其它节点的距离和子节点个数
    const dfs1 = (u, p) => {
        for (const v of graph[u]) {
            if (v !== p) {
                dfs1(v, u);
                dist[u] += dist[v] + count[v];
                count[u] += count[v];
            }
        }
    };
    dfs1(0, -1);
    // DFS 计算每个节点到其它节点的距离之和
    const dfs2 = (u, p) => {
        for (const v of graph[u]) {
            if (v !== p) {
                dist[v] = dist[u] - count[v] + N - count[v];
                dfs2(v, u);
            }
        }
    };
    dfs2(0, -1);
    return dist;
};
```

算法复杂度：时间复杂度为 O(N)，空间复杂度为 O(N)。