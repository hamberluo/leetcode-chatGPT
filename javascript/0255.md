题目编号：255

题目：验证前序遍历序列二叉搜索树

难度：中等

考察范围：二叉搜索树、栈

题干：给定一个整数数组，你需要验证它是否是一个二叉搜索树正确的前序遍历序列。

你可以假定该序列中的数都是不相同的。

参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3

示例 1：

输入: [5,2,6,1,3]
输出: false

示例 2：

输入: [5,2,1,3,6]
输出: true

解题思路：对于一个二叉搜索树，它的左子树的所有节点都小于根节点，右子树的所有节点都大于根节点。因此，对于一个前序遍历序列，第一个元素一定是根节点，接下来的元素可以分为两部分，一部分是左子树的节点，一部分是右子树的节点。我们可以利用这个特点来验证一个前序遍历序列是否是二叉搜索树的前序遍历序列。

具体做法是，我们用一个栈来存储已经遍历过的节点。对于每一个新的节点，我们先将它与栈顶元素比较，如果比栈顶元素小，说明它是栈顶元素的左子节点，直接入栈；如果比栈顶元素大，说明它是某个节点的右子节点，我们需要找到它的父节点，因此我们不断地弹出栈顶元素，直到栈顶元素比它小为止。此时，栈顶元素就是它的父节点，我们将它的右子节点入栈。如果最后栈为空，说明所有节点都符合要求，是一个二叉搜索树的前序遍历序列。

解决方案：

```javascript
var verifyPreorder = function(preorder) {
    let stack = [];
    let min = -Infinity;
    for (let i = 0; i < preorder.length; i++) {
        if (preorder[i] < min) {
            return false;
        }
        while (stack.length > 0 && preorder[i] > stack[stack.length - 1]) {
            min = stack.pop();
        }
        stack.push(preorder[i]);
    }
    return true;
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。