题目编号：264

题目：丑数 II

难度：中等

考察范围：动态规划、堆

题干：编写一个程序，找出第 n 个丑数。

丑数就是只包含质因数 2、3 和/或 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明:  

1 是丑数。
n 不超过1690。

解题思路：动态规划

我们可以用动态规划的思想来解决这个问题。我们可以定义一个数组 dp，其中 dp[i] 表示第 i 个丑数。显然，dp[1] = 1。

接下来，我们考虑如何求出 dp[i]。我们可以将 dp[i] 分解成三个数的乘积，即 dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)，其中 p2、p3、p5 分别表示当前乘以 2、3、5 的最小丑数的下标。我们可以通过维护这三个下标来求出 dp[i]。

具体来说，我们可以初始化 p2 = p3 = p5 = 1，然后从 dp[2] 开始递推计算 dp[i]。在计算 dp[i] 时，我们首先计算 dp[p2] * 2、dp[p3] * 3 和 dp[p5] * 5 这三个数中的最小值，然后将其赋值给 dp[i]。接着，我们比较 dp[p2] * 2、dp[p3] * 3 和 dp[p5] * 5 是否等于 dp[i]，如果是，则将对应的下标加 1。

最后，dp[n] 就是第 n 个丑数。

解决方案：

```javascript
var nthUglyNumber = function(n) {
    let dp = new Array(n + 1).fill(0);
    dp[1] = 1;
    let p2 = 1, p3 = 1, p5 = 1;
    for (let i = 2; i <= n; i++) {
        let num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;
        dp[i] = Math.min(num2, num3, num5);
        if (dp[i] === num2) {
            p2++;
        }
        if (dp[i] === num3) {
            p3++;
        }
        if (dp[i] === num5) {
            p5++;
        }
    }
    return dp[n];
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。