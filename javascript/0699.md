题目编号：699

题目：掉落的方块

难度：中等

考察范围：数据结构、模拟

题干：给定一个二维数组表示一个掉落的方块游戏的场景。每个元素表示一个正方形的方块，其中用 0 表示空，用 1 表示方块。当一个方块被另一个方块挡住不能掉落时，它会停在当前位置。要求实现一个函数，模拟整个游戏场景的掉落过程，并返回最终的场景。

解题思路：模拟整个掉落过程，需要考虑以下几个问题：

1. 如何判断一个方块是否能够掉落？

2. 如何判断一个方块是否能够停止掉落？

3. 如何模拟整个掉落过程？

对于第一个问题，我们可以从下往上遍历每一列，如果当前位置是空的，就继续往上遍历，直到找到一个方块为止。如果找到了一个方块，就将当前位置标记为该方块的位置。

对于第二个问题，我们可以从上往下遍历每一列，如果当前位置是方块，就继续往下遍历，直到找到一个空位置或者到达场景的底部为止。如果找到了一个空位置，就将当前位置标记为该方块的位置。

对于第三个问题，我们可以先按照第一个问题的方法找到所有能够掉落的方块，然后按照第二个问题的方法找到所有能够停止掉落的方块，最后将所有能够停止掉落的方块标记为方块，所有不能停止掉落的方块标记为空。

解决方案：

```javascript
var fallingBlocks = function(grid) {
    const m = grid.length, n = grid[0].length;
    const canFall = Array.from({length: m}, () => Array(n).fill(false));
    const canStop = Array.from({length: m}, () => Array(n).fill(false));
    // 从下往上遍历每一列，找到所有能够掉落的方块
    for (let j = 0; j < n; j++) {
        let i = m - 1;
        while (i >= 0) {
            if (grid[i][j] === 1) {
                canFall[i][j] = true;
                i--;
            } else {
                i--;
            }
        }
    }
    // 从上往下遍历每一列，找到所有能够停止掉落的方块
    for (let j = 0; j < n; j++) {
        let i = 0;
        while (i < m) {
            if (grid[i][j] === 1) {
                canStop[i][j] = true;
                i++;
            } else {
                i++;
            }
        }
    }
    // 将所有能够停止掉落的方块标记为方块，所有不能停止掉落的方块标记为空
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (canFall[i][j] && !canStop[i][j]) {
                grid[i][j] = 0;
            } else if (!canFall[i][j] && canStop[i][j]) {
                grid[i][j] = 1;
            }
        }
    }
    return grid;
};
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。