题目编号：260

题目：只出现一次的数字 III

难度：中等

考察范围：位运算

题干：给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按任意顺序返回答案。

解题思路：由于数组中只有两个元素出现一次，其余元素均出现两次，因此可以考虑将数组分成两个子数组，每个子数组中只包含一个出现一次的元素，其余元素均出现两次。对于这两个子数组，可以使用“异或”运算找出只出现一次的元素。

具体地，假设两个只出现一次的元素为 a 和 b，将所有元素异或得到一个值 x，则 x = a xor b。由于 a 和 b 不相同，因此 x 的二进制表示中至少有一位为 1，根据这一位是 0 还是 1，可以将所有元素分成两个子数组。对于每个子数组，所有元素都出现两次，只有一个元素出现一次，因此可以使用“异或”运算找出这个元素。

解决方案：

```rust
impl Solution {
    pub fn single_number(nums: Vec<i32>) -> Vec<i32> {
        let mut ret = vec![0, 0];
        let mut diff = 0;
        for num in nums {
            diff ^= num;
        }
        diff &= -diff; // 获取最低位的 1
        for num in nums {
            if (num & diff) == 0 {
                ret[0] ^= num;
            } else {
                ret[1] ^= num;
            }
        }
        ret
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。