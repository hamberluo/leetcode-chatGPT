题目编号：403

题目：青蛙过河

难度：中等

考察范围：动态规划、二进制

题干：

一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙是否能够成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

解题思路：

本题可以使用动态规划来解决。我们可以使用一个二维数组 dp，其中 dp[i][j] 表示青蛙能否跳到第 i 个石子，并且最后一步跳了 j 个单位。

对于每个石子 i，我们可以枚举上一步跳了多少个单位 k，然后判断是否能够从 i-k 跳到 i。如果能够跳到 i，那么我们就可以更新 dp[i][j]，其中 j = k-1, k, k+1。

最终，如果存在 dp[n-1][j] 为 true，其中 j 表示最后一步跳了多少个单位，那么青蛙就可以成功过河。

解决方案：

```rust
impl Solution {
    pub fn can_cross(stones: Vec<i32>) -> bool {
        let n = stones.len();
        let mut dp = vec![vec![false; n]; n];
        dp[0][0] = true;

        for i in 1..n {
            for j in 0..i {
                let k = (stones[i] - stones[j]) as usize;
                if k <= j + 1 {
                    dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1];
                    if i == n-1 && dp[i][k] {
                        return true;
                    }
                }
            }
        }

        false
    }
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。