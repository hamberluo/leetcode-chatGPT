题目编号：357

题目：计算各个位数不同的数字个数

难度：中等

考察范围：数学、动态规划

题干：给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10^n。

解题思路：这是一道数学题，需要找到规律。我们可以先从小的数字开始找规律，比如：

n = 0，只有 1 个数字 0，满足条件。

n = 1，有 10 个数字 0~9，满足条件。

n = 2，有 91 个数字 10~99，满足条件。其中，10、11、22、33、44、55、66、77、88、99 不满足条件，因为它们包含相同的数字。

n = 3，有 739 个数字 100~999，满足条件。其中，100、101、110、121、202、212、221、232、303、313、323、343、404、414、424、434、454、464、474、484、494、505、515、525、535、545、565、575、585、595、606、616、626、636、646、656、676、686、696、707、717、727、737、747、757、767、787、797、808、818、828、838、848、858、868、878、898、909、919、929、939、949、959、969、979、989、999 不满足条件，因为它们包含相同的数字。

我们可以发现，对于 n 位数，如果第一位是 1~9 中的一个数字，那么剩下的数字可以从 0~9 中任意选择，但是不能选择第一位已经选择的数字。因此，第一位有 9 种选择，剩下的数字有 9、8、7、...、(11-n) 种选择，因为不能选择第一位已经选择的数字。所以，n 位数中满足条件的数字个数为：

f(n) = 9 * 9 * 8 * 7 * ... * (11-n)

解决方案：

```rust
impl Solution {
    pub fn count_numbers_with_unique_digits(n: i32) -> i32 {
        if n == 0 {
            return 1;
        }
        let mut res = 10;
        let mut unique_digits = 9;
        let mut available_number = 9;
        let n = n.min(10);
        for i in 2..=n {
            unique_digits *= available_number;
            res += unique_digits;
            available_number -= 1;
        }
        res
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。