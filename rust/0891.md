题目编号：891

题目：子序列宽度之和

难度：困难

考察范围：动态规划、数学

题干：

给定一个整数数组 A ，考虑 A 的所有非空子序列。

对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。

返回 A 的所有子序列的宽度之和。

由于答案可能非常大，请返回答案模 10^9+7。

示例：

输入：[2,1,3]
输出：6
解释：
子序列为 [2]，[1]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。
相应的宽度是 0，0，0，1，1，2，2 。
这些宽度之和是 6 。

提示：

1 <= A.length <= 20000
1 <= A[i] <= 20000

解题思路：

首先，我们可以将 A 数组排序，这样最大值和最小值就可以直接取到了。

然后，我们考虑对于每个数 A[i]，它在多少个子序列中是最大值或最小值。

对于最大值，它在所有以 A[i] 结尾的子序列中都是最大值，而在所有以 A[i] 开头的子序列中都不是最大值。

对于最小值，同理。

因此，我们可以先对 A 数组排序，然后对于每个数 A[i]，计算它在多少个子序列中是最大值或最小值。

具体来说，我们可以用 dp1[i] 表示以 A[i] 结尾的子序列中，A[i] 是最大值的子序列个数，dp2[i] 表示以 A[i] 结尾的子序列中，A[i] 是最小值的子序列个数。

对于 dp1[i]，我们可以枚举 A[j]（j < i），如果 A[j] < A[i]，那么以 A[j] 结尾的子序列中，A[i] 可以作为最大值，因此 dp1[i] += dp1[j]。

对于 dp2[i]，同理。

最后，我们可以计算出所有子序列的宽度之和。对于一个子序列，它的宽度就是它的最大值和最小值的差。因此，我们可以枚举最大值和最小值，计算它们的差，然后将所有差值相加即可。

解决方案：

```rust
const MOD: i64 = 1_000_000_007;

pub fn sum_subseq_widths(a: Vec<i32>) -> i32 {
    let n = a.len();
    let mut a = a;
    a.sort_unstable();

    let mut dp1 = vec![1; n];
    let mut dp2 = vec![1; n];

    for i in 1..n {
        for j in 0..i {
            if a[j] < a[i] {
                dp1[i] = (dp1[i] + dp1[j]) % MOD;
            }
            if a[j] > a[i] {
                dp2[i] = (dp2[i] + dp2[j]) % MOD;
            }
        }
    }

    let mut ans = 0;
    for i in 0..n {
        ans = (ans + dp1[i] * (a[i] as i64) % MOD - dp2[i] * (a[i] as i64) % MOD + MOD) % MOD;
    }

    ans as i32
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。