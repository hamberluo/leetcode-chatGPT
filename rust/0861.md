题目编号：861

题目：翻转矩阵后的得分

难度：中等

考察范围：贪心算法、位运算

题干：有一个二维矩阵 A 其中每个元素的值为 0 或 1。移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。在做出任意数量的移动后，每行都必须以 0 开头。返回最大的行总和。

解题思路：贪心算法

首先，我们需要明确一个事实：对于每一行，如果它的第一个元素为 0，那么这一行的值一定不会比它的第一个元素为 1 的情况更小。因此，我们可以先通过行翻转操作，使得每一行的第一个元素都为 1。

接下来，我们需要考虑如何进行列翻转操作。对于每一列，我们可以计算出如果这一列进行翻转操作，会对总和产生多少的贡献。具体来说，如果这一列中 0 的个数少于 1 的个数，那么翻转这一列会对总和产生贡献，否则不会产生贡献。

最后，我们将所有行的值相加即可得到最大的行总和。

解决方案：

```rust
impl Solution {
    pub fn matrix_score(a: Vec<Vec<i32>>) -> i32 {
        let m = a.len();
        let n = a[0].len();
        let mut res = m * (1 << (n - 1)); // 初始化为所有行的第一个元素都为 1 的情况
        for j in 1..n {
            let mut cnt = 0;
            for i in 0..m {
                cnt += a[i][j] ^ a[i][0]; // 统计这一列中 0 的个数
            }
            res += cnt.max(m - cnt) * (1 << (n - j - 1)); // 计算贡献
        }
        res as i32
    }
}
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(1)。