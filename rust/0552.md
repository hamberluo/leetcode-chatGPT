题目编号：552

题目：学生出勤记录 II

难度：困难

考察范围：动态规划

题干：

给定一个正整数 n，表示学生的出勤记录表的长度。出勤记录表是一个字符串，其中第 i 个字符表示第 i 天的出勤记录（'A'、'L' 和 'P'）。

只要学生满足下列两个条件，则可以获得出勤奖励：

按总出勤计，学生缺席（'A'）严格少于两天。
学生连续出勤（连续出现字符 'L'）严格少于三天。
如果学生可以获得出勤奖励，返回 true；否则，返回 false。

解题思路：

本题可以使用动态规划来解决。我们可以定义一个三维数组 dp，其中 dp[i][j][k] 表示前 i 天有 j 个 'A'，结尾有连续 k 个 'L' 的出勤记录的方案数。

对于第 i 天，我们可以进行以下三种操作：

添加 'P'，即 dp[i][j][0] += dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]；
添加 'A'，即 dp[i][j+1][0] += dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]；
添加 'L'，即 dp[i][j][k+1] += dp[i-1][j][k]。

最终的答案即为 dp[n][0][0] + dp[n][1][0] + dp[n][2][0]。

解决方案：

```rust
impl Solution {
    pub fn check_record(n: i32) -> i32 {
        let n = n as usize;
        let mut dp = vec![vec![vec![0; 3]; 2]; n+1];
        dp[0][0][0] = 1;
        for i in 1..=n {
            // 添加 'P'
            for j in 0..2 {
                for k in 0..3 {
                    dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % 1000000007;
                }
            }
            // 添加 'A'
            for k in 0..3 {
                dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][k]) % 1000000007;
            }
            // 添加 'L'
            for j in 0..2 {
                for k in 0..2 {
                    dp[i][j][k+1] = (dp[i][j][k+1] + dp[i-1][j][k]) % 1000000007;
                }
            }
        }
        let mut res = 0;
        for j in 0..2 {
            for k in 0..3 {
                res = (res + dp[n][j][k]) % 1000000007;
            }
        }
        res
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。