题目编号：465

题目：最优账单平衡

难度：困难

考察范围：贪心算法、动态规划

题干：有 n 个人，他们之间互相借款。给定一个数组 debts 表示每个人的借款金额，其中 debts[i][0] 表示第 i 个人欠款给第 debts[i][1] 个人的金额。所有借款信息都以 (x,y,z) 的形式表示，表示借款人编号为 x，收款人编号为 y，借款金额为 z。假设一个人既可以借款也可以放款，并且借款金额可以为负数。如果某个人的借款金额为正数，则表示他需要向其他人还款；如果某个人的借款金额为负数，则表示其他人需要向他还款。请你找到一种最优的还款方案，使得所有人的借款金额都恰好为 0，并输出其还款路径。

解题思路：本题可以使用贪心算法或动态规划来解决。这里介绍一种贪心算法的思路。

首先，我们可以将所有的借款信息转化为一个借款矩阵，其中 matrix[i][j] 表示第 i 个人欠款给第 j 个人的金额。如果 matrix[i][j] > 0，则表示第 i 个人需要向第 j 个人还款；如果 matrix[i][j] < 0，则表示第 j 个人需要向第 i 个人还款；如果 matrix[i][j] = 0，则表示第 i 个人和第 j 个人之间没有借款关系。

接下来，我们可以使用贪心算法来求解最优还款方案。具体来说，我们可以按照以下步骤进行：

1. 对于每个人 i，计算他的净借款金额 net[i]，即他需要向其他人还款的金额减去其他人需要向他还款的金额。如果 net[i] > 0，则表示第 i 个人需要向其他人还款；如果 net[i] < 0，则表示其他人需要向第 i 个人还款；如果 net[i] = 0，则表示第 i 个人的借款已经完全平衡。

2. 对于每个需要还款的人 i，找到一个需要收款的人 j，使得 net[j] < 0 且 matrix[i][j] > 0。这样，第 i 个人就可以向第 j 个人还款，同时减少了第 j 个人需要向其他人还款的金额。如果找不到这样的人 j，则说明第 i 个人的借款已经完全平衡，不需要再进行还款。

3. 重复步骤 2，直到所有的借款都已经完全平衡。

解决方案：

```rust
fn optimal_account_balancing(debts: Vec<Vec<i32>>) -> i32 {
    let n = debts.len();
    let mut net = vec![0; n];
    for i in 0..n {
        for j in 0..n {
            net[i] += debts[i][j] - debts[j][i];
        }
    }
    let mut ans = 0;
    let mut i = 0;
    while i < n {
        if net[i] == 0 {
            i += 1;
            continue;
        }
        let mut j = i + 1;
        while j < n && net[i] * net[j] > 0 {
            j += 1;
        }
        if j == n {
            break;
        }
        let mut k = j + 1;
        while k < n && net[i] * net[k] > 0 {
            if debts[i][k] > 0 {
                let x = debts[i][k].min(-debts[j][k]);
                debts[i][k] -= x;
                debts[k][i] += x;
                debts[j][k] += x;
                debts[k][j] -= x;
                net[i] -= x;
                net[j] += x;
                ans += x.abs();
                if net[i] == 0 {
                    break;
                }
            }
            k += 1;
        }
        i = j;
    }
    ans
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。