题目编号：995

题目：K 连续位的最小翻转次数

难度：困难

考察范围：贪心算法、滑动窗口

题干：

在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，并将子数组中的每个 0 更改为 1，而每个 1 更改为 0。

返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。

解题思路：

我们可以使用贪心算法来解决这个问题。我们从左到右扫描数组 A，如果当前位置 i 的值为 0，那么我们需要将 i 到 i + K - 1 这个区间内的数全部翻转。如果当前位置 i 的值为 1，那么我们不需要翻转这个区间。如果我们无法翻转 i 到 i + K - 1 这个区间，那么就返回 -1。

我们可以使用一个变量 flip 记录当前已经翻转了多少次，以及一个变量 ans 记录最小的翻转次数。我们还需要使用一个队列来记录当前需要翻转的位置。我们从左到右扫描数组 A，如果当前位置 i 需要翻转，那么我们将 i 加入队列中。如果队列中的第一个位置 j 已经超出了 i - K 的范围，那么我们需要将 j 从队列中弹出，并将 flip 减去 1。如果此时 A[i] 仍然为 0，那么我们需要将 i 加入队列中，并将 flip 加上 1。如果 flip 的值大于 ans，那么我们可以直接返回 -1。

解决方案：

```rust
impl Solution {
    pub fn min_k_bit_flips(a: Vec<i32>, k: i32) -> i32 {
        let k = k as usize;
        let n = a.len();
        let mut flip = 0;
        let mut ans = 0;
        let mut q = VecDeque::new();
        for i in 0..n {
            if !q.is_empty() && q[0] + k <= i {
                flip -= 1;
                q.pop_front();
            }
            if a[i] == flip % 2 {
                if i + k > n {
                    return -1;
                }
                flip += 1;
                ans += 1;
                q.push_back(i);
            }
        }
        ans
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(k)。