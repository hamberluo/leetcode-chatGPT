题目编号：761

题目：特殊的二进制序列

难度：困难

考察范围：字符串、递归

题干：

特殊的二进制序列是具有以下两个性质的二进制序列：

0 的数量与 1 的数量相等。
二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。
给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)

在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？

解题思路：

题目要求我们将特殊的二进制序列进行交换，使得交换后的字符串按照字典序排列的最大的结果是什么。因此，我们需要先将特殊的二进制序列进行拆分，然后对拆分后的子串进行递归处理，最后再将子串进行拼接。

具体来说，我们可以将特殊的二进制序列进行拆分，拆分成若干个特殊的二进制序列，然后对每个特殊的二进制序列进行递归处理，最后将处理后的子串按照字典序进行排序，然后拼接起来即可。

在递归处理子串时，我们需要先将子串进行拆分，然后对拆分后的子串进行递归处理，最后将处理后的子串按照题目要求进行拼接。

解决方案：

```rust
impl Solution {
    pub fn make_largest_special(s: String) -> String {
        let mut res = String::new();
        let mut i = 0;
        let mut cnt = 0;
        for (j, c) in s.chars().enumerate() {
            if c == '1' {
                cnt += 1;
            } else {
                cnt -= 1;
            }
            if cnt == 0 {
                let mut sub = s[i+1..j].to_string();
                sub = "1".to_string() + &Self::make_largest_special(sub) + "0";
                res.push_str(&sub);
                i = j + 1;
            }
        }
        res.chars().sorted().rev().collect()
    }
}
```

算法复杂度：O(nlogn)

其中，n 表示字符串的长度。在递归处理子串时，每次都需要将子串进行拆分，因此时间复杂度为 O(n)。在拼接子串时，需要对子串进行排序，因此时间复杂度为 O(nlogn)。因此，总的时间复杂度为 O(nlogn)。