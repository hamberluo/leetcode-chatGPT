题目编号：855

题目：考场就座

难度：中等

考察范围：数据结构、算法

题干：在考场上，一排有 N 个座位，分别编号为 0, 1, 2, ..., N-1 。当学生进入考场时，他必须坐在编号为 0 <= i < N 的座位上，而且不能坐在已经有人坐过的座位上。

当第一个学生到达考场时，他坐在自己的位置上，此后的学生将会：

如果他的座位还空着，就坐在自己的座位上。
当他的座位被占用时，随机选择一个未被占用的座位，坐到那里。
当最后一个学生进入考场后，还有座位空着，那么剩下的学生就会选择坐在空座位上。

给定一个整数 N，表示考场座位数目，同时给定一个整数 K，表示第 K 个学生的编号（编号从 0 开始），请返回他最后坐的位置编号。

解题思路：这道题目可以使用数学归纳法来证明，最后一个学生坐在自己的位置上的概率为 1/N，坐在其他位置上的概率为 (1/N) * (N-2)/(N-1)。因此，最后一个学生坐在自己的位置上的概率为：

1/N + (1/N) * (N-2)/(N-1) + (1/N) * (N-2)/(N-1) * (N-4)/(N-3) + ... + (1/N) * (N-2)/(N-1) * (N-4)/(N-3) * ... * 2/3

可以发现，这个式子可以化简为 1/N，因此最后一个学生坐在自己的位置上的概率为 1/N，也就是说，最后一个学生最后坐在的位置编号就是 K。

解决方案：

```rust
fn last_remaining_seat(n: i32, k: i32) -> i32 {
    k
}
```

算法复杂度：时间复杂度为 O(1)，空间复杂度为 O(1)。