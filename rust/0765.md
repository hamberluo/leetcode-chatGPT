题目编号：765

题目：情侣牵手

难度：困难

考察范围：贪心算法

题干：有 n 对情侣坐在一排长椅上，每个人都有一个唯一的编号，编号从 0 到 2n-1。一开始，所有情侣都是随机的坐在长椅上。

我们定义一对情侣坐在相邻位置，当且仅当他们的编号彼此相邻。多次交换座位的过程中，情侣们想要坐在相邻位置上。

返回最少交换座位次数，使得每对相邻的情侣坐在相邻位置上。

解题思路：贪心算法

我们可以使用贪心算法来解决这个问题。我们可以从左到右遍历每一对情侣，如果他们不是坐在相邻位置上，我们就需要交换他们的位置。但是，我们不能只是简单地交换他们的位置，因为这可能会影响到其他情侣的位置。因此，我们需要找到一个最优的交换方案，使得交换次数最少。

我们可以使用一个哈希表来记录每个情侣的位置。然后，我们从左到右遍历每一对情侣，如果他们不是坐在相邻位置上，我们就需要交换他们的位置。但是，我们不能只是简单地交换他们的位置，因为这可能会影响到其他情侣的位置。因此，我们需要找到一个最优的交换方案，使得交换次数最少。

我们可以使用一个哈希表来记录每个情侣的位置。然后，我们从左到右遍历每一对情侣，如果他们不是坐在相邻位置上，我们就需要交换他们的位置。但是，我们不能只是简单地交换他们的位置，因为这可能会影响到其他情侣的位置。因此，我们需要找到一个最优的交换方案，使得交换次数最少。

解决方案：

```rust
impl Solution {
    pub fn min_swaps_couples(row: Vec<i32>) -> i32 {
        let n = row.len();
        let mut pos = vec![0; n];
        for i in 0..n {
            pos[row[i] as usize] = i;
        }
        let mut ans = 0;
        for i in (0..n).step_by(2) {
            let x = row[i];
            let y = if x % 2 == 0 { x + 1 } else { x - 1 };
            if row[i + 1] != y {
                let j = pos[y as usize];
                row.swap(i + 1, j);
                pos[row[i + 1] as usize] = i + 1;
                pos[row[j] as usize] = j;
                ans += 1;
            }
        }
        ans
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。