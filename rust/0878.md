题目编号：878

题目：第 N 个神奇数字

难度：困难

考察范围：数学、二分查找

题干：

如果正整数可以被 A 或 B 整除，那么它是神奇的。

返回第 N 个神奇数字。由于答案可能非常大，返回它模 10^9 + 7 的结果。

示例 1：

输入：N = 1, A = 2, B = 3
输出：2

示例 2：

输入：N = 4, A = 2, B = 3
输出：6

示例 3：

输入：N = 5, A = 2, B = 4
输出：10

示例 4：

输入：N = 3, A = 6, B = 4
输出：8

提示：

1 <= N <= 10^9
2 <= A <= 40000
2 <= B <= 40000

解题思路：

本题可以使用二分查找来解决。首先，我们可以发现，第 N 个神奇数字一定是在 [1, A * B] 的范围内的。因此，我们可以对这个范围进行二分查找，找到第一个大于等于 N 的神奇数字。

对于一个给定的数字 x，我们可以计算出在 [1, x] 范围内有多少个神奇数字。具体来说，我们可以计算出在 [1, x] 范围内有多少个能被 A 整除的数字，多少个能被 B 整除的数字，以及多少个能同时被 A 和 B 整除的数字。根据容斥原理，我们可以得到在 [1, x] 范围内有多少个神奇数字。

具体来说，我们可以计算出在 [1, x] 范围内有多少个能被 A 整除的数字，即 x / A 个。同理，我们可以计算出在 [1, x] 范围内有多少个能被 B 整除的数字，即 x / B 个。但是，这样我们会重复计算那些同时能被 A 和 B 整除的数字。因此，我们需要计算出在 [1, x] 范围内有多少个能同时被 A 和 B 整除的数字，即 x / lcm(A, B) 个，其中 lcm(A, B) 表示 A 和 B 的最小公倍数。

最后，我们可以使用容斥原理，计算出在 [1, x] 范围内有多少个神奇数字，即：

x / A + x / B - x / lcm(A, B)

解决方案：

```rust
fn nth_magical_number(n: i32, a: i32, b: i32) -> i32 {
    let mod_num = 1_000_000_007;
    let lcm = a * b / gcd(a, b);
    let (mut left, mut right) = (1, i64::from(n) * i64::from(a).min(i64::from(b)));
    while left < right {
        let mid = (left + right) / 2;
        let count = mid / a + mid / b - mid / lcm;
        if count < n.into() {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    (left % mod_num) as i32
}

fn gcd(mut a: i32, mut b: i32) -> i32 {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}
```

算法复杂度：O(log(N) * log(M))，其中 M 表示 A 和 B 的最小公倍数。