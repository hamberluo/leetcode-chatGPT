题目编号：822

题目：翻转卡片游戏

难度：中等

考察范围：数组、模拟

题干：在桌子上有一堆牌，每张牌上都写着一个整数。此外，还有两个分别名为 row 和 column 的正整数，它们表示牌桌上有 row 行和 column 列的表格。最开始，每张牌的正面朝下。

现在，你需要根据以下规则翻转牌的状态，任意次数：

选中任意一个以 (i, j) 为左上角的矩形区域，将那里所有的牌翻转。（请参见示例以获得更为详细的解释）

当存在一张牌的正面朝上时，我们称这个牌的状态是“已翻转的”。

返回能使所有牌的状态均为 “已翻转的” 的翻转次数的最小值。如果无法使所有牌的状态均为 “已翻转的”，返回 -1。

解题思路：模拟

首先，我们可以发现，对于每个位置，翻转两次相当于没有翻转。因此，我们可以只考虑每个位置是否翻转一次。

接下来，我们考虑如何确定每个位置是否翻转。我们可以枚举每个位置，然后判断这个位置是否需要翻转。如果需要翻转，我们就将这个位置的状态翻转，并将翻转次数加一。

如何判断一个位置是否需要翻转呢？我们可以考虑这个位置在多少个矩形区域中出现。如果出现的次数是奇数，那么这个位置需要翻转。否则，这个位置不需要翻转。

如何计算一个位置在多少个矩形区域中出现呢？我们可以枚举每个矩形区域，然后判断这个位置是否在这个矩形区域中。如果在，我们就将计数器加一。

解决方案：

```rust
impl Solution {
    pub fn flip_lights(n: i32, m: i32) -> i32 {
        let n = n as usize;
        let m = m as usize;
        let mut state = vec![vec![true; n]; 4];
        for i in 0..n {
            state[0][i] = false;
            state[1][i] = i % 2 == 0;
            state[2][i] = i % 2 == 1;
            state[3][i] = i % 3 == 0;
        }
        let mut cnt = 0;
        for i in 0..4 {
            for j in 0..n {
                if state[i][j] {
                    cnt += 1;
                }
            }
        }
        let mut ans = 0;
        match m {
            0 => ans = 1,
            1 => ans = match n {
                1 => 2,
                2 => 3,
                _ => 4,
            },
            2 => ans = match n {
                1 => 2,
                2 => 4,
                _ => 7,
            },
            _ => ans = match n {
                1 => 2,
                2 => 4,
                _ => 8,
            },
        }
        ans.min(cnt) as i32
    }
}
```

算法复杂度：时间复杂度为 O(1)，空间复杂度为 O(1)。