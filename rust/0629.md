题目编号：629

题目：K个逆序对数组

难度：困难

考察范围：动态规划、数学

题干：

给定两个整数 n 和 k，找到所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的数量。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是逆序对。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

解题思路：

这是一道动态规划的题目，我们可以用 dp[i][j] 表示由 1~i 组成，恰好有 j 个逆序对的不同的数组的数量。

对于 dp[i][j]，我们可以考虑将 i 插入到 1~i-1 的某个位置，这样就会产生 i-1 个逆序对，然后我们就可以将问题转化为求由 1~i-1 组成，恰好有 j-(i-1) 个逆序对的不同的数组的数量。

因此，我们可以得到状态转移方程：

dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i+1]

其中，dp[i-1][j] 表示 i 不插入时，由 1~i-1 组成，恰好有 j 个逆序对的不同的数组的数量；dp[i-1][j-1] 表示 i 插入到最前面时，由 2~i-1 和 i 组成，恰好有 j-1 个逆序对的不同的数组的数量；dp[i-1][j-2] 表示 i 插入到第二个位置时，由 1 和 3~i-1 和 i 组成，恰好有 j-2 个逆序对的不同的数组的数量，以此类推。

解决方案：

```rust
fn k_inverse_pairs(n: i32, k: i32) -> i32 {
    let MOD = 1_000_000_007;
    let mut dp = vec![vec![0; k as usize + 1]; n as usize + 1];
    dp[0][0] = 1;
    for i in 1..=n as usize {
        dp[i][0] = 1;
        for j in 1..=k as usize {
            dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD;
            if j >= i {
                dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD;
            }
        }
    }
    dp[n as usize][k as usize]
}
```

算法复杂度：时间复杂度 O(nk)，空间复杂度 O(nk)。