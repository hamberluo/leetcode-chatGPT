题目编号：991

题目：坏了的计算器

难度：中等

考察范围：数学、贪心算法

题干：

在显示着数字的坏计算器上，我们可以执行以下两种操作：

双倍（Double）：将显示屏上的数字乘 2；
递减（Decrement）：将显示屏上的数字减 1 。
最初，计算器显示数字 X。

返回显示数字 Y 所需的最小操作数。

解题思路：

首先，我们可以发现，如果 Y>X，那么我们只能通过不断执行减一操作来使得 X=Y，因为乘二操作只会让 X 变得更大。

其次，如果 Y<X，那么我们可以通过一系列的乘二和减一操作来使得 X=Y。具体来说，我们可以不断地执行以下两种操作中的一种：

如果 Y 是偶数，将 Y 除以 2；
如果 Y 是奇数，将 Y 加 1 或减 1。
直观地理解一下，如果 Y 是偶数，那么将 Y 除以 2 的操作显然更优；而如果 Y 是奇数，那么我们应当尽可能地将 Y 减少，以使得后续的除以 2 操作更优。

解决方案：

我们可以从 Y 开始，不断地对 Y 进行除以 2 或加减 1 的操作，直到 Y=X 为止。在这个过程中，我们需要记录执行的操作次数。

代码如下：

```rust
impl Solution {
    pub fn broken_calc(x: i32, y: i32) -> i32 {
        let mut res = 0;
        let mut y = y;
        while y > x {
            res += 1;
            if y % 2 == 0 {
                y /= 2;
            } else {
                y += 1;
            }
        }
        res + x - y
    }
}
```

算法复杂度：时间复杂度为 O(log(Y-X))，空间复杂度为 O(1)。