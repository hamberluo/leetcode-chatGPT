题目编号：32

题目：最长有效括号

难度：困难

考察范围：字符串、栈、动态规划

题干：给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"

示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

解题思路：使用栈或动态规划

解决方案：使用栈

使用栈来解决这个问题，我们遍历字符串，如果遇到左括号，我们就将其下标压入栈中；如果遇到右括号，我们就将栈顶元素对应的左括号下标弹出。这样，我们就可以利用栈来判断每个括号是否合法，以及找到每个合法子串的长度。具体地，我们从左到右遍历字符串，遇到左括号时将其下标压入栈中，遇到右括号时，如果当前栈顶元素对应的左括号可以和当前的右括号匹配上，那么我们就弹出栈顶元素，同时更新最长有效括号子串的长度。如果当前栈顶元素对应的左括号不能和当前的右括号匹配上，那么我们就将当前右括号的下标压入栈中，作为新的起始位置。

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。

rust 代码如下：

```rust
impl Solution {
    pub fn longest_valid_parentheses(s: String) -> i32 {
        let mut stack = vec![-1];
        let mut max_len = 0;
        for (i, c) in s.chars().enumerate() {
            if c == '(' {
                stack.push(i as i32);
            } else {
                stack.pop();
                if stack.is_empty() {
                    stack.push(i as i32);
                } else {
                    max_len = max_len.max(i as i32 - stack.last().unwrap());
                }
            }
        }
        max_len
    }
}
```