题目编号：31

题目：下一个排列

难度：中等

考察范围：数组、双指针

题干：

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

解题思路：

题目要求我们找到下一个排列，那么我们可以先从后往前找到第一个不满足逆序的位置，记为 i，然后再从后往前找到第一个比 nums[i] 大的数，记为 j，交换 nums[i] 和 nums[j]，最后将 i 后面的数按照升序排列即可。

解决方案：

```rust
impl Solution {
    pub fn next_permutation(nums: &mut Vec<i32>) {
        let n = nums.len();
        let mut i = n - 2;
        while i >= 0 && nums[i] >= nums[i + 1] {
            i -= 1;
        }
        if i >= 0 {
            let mut j = n - 1;
            while j >= 0 && nums[j] <= nums[i] {
                j -= 1;
            }
            nums.swap(i, j);
        }
        nums[i + 1..].reverse();
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。