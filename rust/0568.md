题目编号：568

题目：最大休假天数

难度：困难

考察范围：动态规划

题干：给定一个城市的旅游计划，城市中有许多景点，你需要选择一些景点进行游览。你需要遵守以下规则：

1.你可以进行任意次数的游览，但每次游览必须至少包含一个景点。

2.在开始游览时，你需要在景点之间移动。这些移动需要耗费你的旅游时间。你可以通过购买车票或者步行来完成这些移动。你的旅游时间是有限的，因此你不能在旅游时间用尽之前游览完所有的景点。

3.你的旅游时间是连续的，也就是说，你不能在旅游过程中中断旅游，然后再次开始旅游。

4.每个景点都有一个游览时间，你需要在游览时间用尽之前离开该景点。

5.你可以在任意一个景点结束旅游，然后开始移动到下一个景点。

6.你的旅游时间是从第一天开始计算的，因此你不能在第一天之前到达城市。

给定一个城市的旅游计划，你需要计算出你最多可以休假多少天。

解题思路：这是一道动态规划问题。我们可以定义一个二维数组 dp[i][j]，表示在第 i 天，游览了前 j 个景点所能获得的最大休假天数。对于每个景点，我们可以选择游览或者不游览。如果选择游览，那么我们需要在游览时间内完成游览，并且需要考虑前面游览的景点所剩余的时间。如果选择不游览，那么我们可以直接跳过该景点，继续游览下一个景点。

解决方案：

```rust
impl Solution {
    pub fn max_vacation_days(flights: Vec<Vec<i32>>, days: Vec<Vec<i32>>) -> i32 {
        let n = flights.len();
        let k = days[0].len();
        let mut dp = vec![vec![0; n]; k];
        for j in (0..n).rev() {
            for i in 0..k {
                dp[i][j] = days[j][i] + if j == n - 1 { 0 } else { dp[i][j + 1] };
                for p in 0..n {
                    if flights[j][p] == 1 {
                        dp[i][j] = dp[i][j].max(days[p][i] + if j == n - 1 { 0 } else { dp[i][j + 1] });
                    }
                }
            }
        }
        dp[0][0]
    }
}
```

算法复杂度：时间复杂度为 O(n^2k)，空间复杂度为 O(nk)。