题目编号：835

题目：图像重叠

难度：中等

考察范围：数组、模拟

题干：给出两个图像 A 和 B ，A 和 B 以二维数组形式给出，其中每个元素的值为 0 或 1 。只有当 A 和 B 在对应的位置都为 1 时，才能在新图像中的对应位置也为 1。给出 A 和 B ，请你返回一个新的二维数组表示叠加后的结果。

解题思路：对于每个 1，我们需要将其移动到 B 的位置，然后计算它们的重叠部分。我们可以将 A 中的每个 1 移动到 B 的位置，然后计算它们的重叠部分。对于每个 1，我们需要计算它们的偏移量，然后将它们移动到 B 的位置。我们可以枚举 A 和 B 中的每个 1，然后计算它们的偏移量，然后将它们移动到 B 的位置。对于每个偏移量，我们可以使用一个二维数组来记录它们的出现次数。最后，我们可以枚举所有的偏移量，找到出现次数最多的偏移量，然后将其对应的重叠部分填充为 1。

解决方案：

```rust
impl Solution {
    pub fn largest_overlap(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) -> i32 {
        let n = a.len();
        let mut count = vec![vec![0; n * 2]; n * 2];
        for i in 0..n {
            for j in 0..n {
                if a[i][j] == 1 {
                    for k in 0..n {
                        for l in 0..n {
                            if b[k][l] == 1 {
                                count[i - k + n][j - l + n] += 1;
                            }
                        }
                    }
                }
            }
        }
        count.into_iter().flatten().max().unwrap_or(0)
    }
}
```

算法复杂度：时间复杂度为 O(n^4)，空间复杂度为 O(n^2)。