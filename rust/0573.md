题目编号：573

题目：松鼠模拟

难度：简单

考察范围：模拟

题干：有一个松鼠，它住在一个树上。你可以通过以下三个操作来模拟松鼠的行为：

1. 每一步选择向上爬或者向下爬，然后移动一个单位的距离。如果松鼠爬到了树的顶部，那么它不能再向上爬了。同样地，如果松鼠爬到了树的底部，那么它不能再向下爬了。

2. 每一步选择向左或者向右移动一个单位的距离。

3. 通过摘取一个水果（值为正整数）来获得能量。

你可以通过让松鼠“跳跃”来模拟松鼠的行为。每一次跳跃，你可以选择向上爬、向下爬、向左移动或者向右移动。你的目标是让松鼠获得最大的能量值。

给定一个描述树中每个节点的整数数组表示，你需要重新排列树中的节点，使得每个没有子节点的节点都向下移动。每个节点的值是唯一的。

注意：叶子节点是没有子节点的节点，下面的例子中的第三个节点就是叶子节点。

解题思路：首先需要找到松鼠到每个水果的距离，然后根据距离排序，依次选择距离最短的水果，计算松鼠到该水果的距离和松鼠到树根的距离，然后更新松鼠到树根的距离和能量值。

解决方案：

```rust
impl Solution {
    pub fn min_distance(height: i32, width: i32, tree: Vec<i32>, squirrel: Vec<i32>, nuts: Vec<Vec<i32>>) -> i32 {
        let mut sum = 0;
        let mut max = std::i32::MIN;
        for nut in &nuts {
            let dis = (nut[0] - tree[0]).abs() + (nut[1] - tree[1]).abs();
            sum += dis * 2;
            max = max.max(dis - (nut[0] - squirrel[0]).abs() - (nut[1] - squirrel[1]).abs());
        }
        sum - max
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。