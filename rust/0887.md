题目编号：887

题目：鸡蛋掉落

难度：困难

考察范围：动态规划、二分查找

题干：

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋），并将其从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

解题思路：

这是一道经典的动态规划问题，但是直接使用动态规划会超时，因此需要使用二分查找进行优化。

我们可以定义状态 dp_{k,n} 表示有 k 个鸡蛋，最多可以尝试 n 层楼时，最坏情况下最少需要扔几次鸡蛋才能确定楼层 F 的位置。

对于每一次扔鸡蛋，有两种情况：鸡蛋碎了或者没碎。

如果鸡蛋碎了，那么我们需要在下面的 n-1 层楼中继续寻找 F 的位置，此时我们剩下 k-1 个鸡蛋和 n-1 层楼，因此需要进行 dp_{k-1,n-1} 次操作。

如果鸡蛋没碎，那么我们需要在上面的 N-n 层楼中继续寻找 F 的位置，此时我们剩下 k 个鸡蛋和 N-n 层楼，因此需要进行 dp_{k,n-1} 次操作。

因此，我们可以得到状态转移方程：

dp_{k,n} = dp_{k-1,n-1} + dp_{k,n-1} + 1

其中 +1 表示当前这一次扔鸡蛋的操作。

但是这个状态转移方程的时间复杂度是 O(KN^2)，会超时。因此我们需要使用二分查找进行优化。

我们可以将状态转移方程改写为：

dp_{k,n} = dp_{k-1,n-1} + dp_{k,n-1} + 1

= dp_{k-1,n} + dp_{k,n-1} + 1 - dp_{k-1,n-1}

因此，我们可以将 dp_{k,n} 看作是 dp_{k-1,n} 和 dp_{k,n-1} 的函数，即：

dp_{k,n} = 1 + dp_{k-1,n} + dp_{k,n-1} - dp_{k-1,n-1}

这个式子的含义是，我们在 [1,n] 中选择一个位置 i 进行扔鸡蛋，如果鸡蛋碎了，那么我们需要在 [1,i-1] 中继续寻找 F 的位置，此时我们剩下 k-1 个鸡蛋和 i-1 层楼，因此需要进行 dp_{k-1,i-1} 次操作；如果鸡蛋没碎，那么我们需要在 [i+1,n] 中继续寻找 F 的位置，此时我们剩下 k 个鸡蛋和 n-i 层楼，因此需要进行 dp_{k,n-i} 次操作。因此，我们需要在 [1,n] 中选择一个位置 i，使得 dp_{k-1,i-1} 和 dp_{k,n-i} 的最大值最小。

这个问题可以使用二分查找进行优化。具体来说，我们可以在 [1,n] 中选择一个位置 i，计算 dp_{k-1,i-1} 和 dp_{k,n-i} 的最大值，如果这个最大值小于 dp_{k,n}，那么说明我们可以在 [1,i-1] 或 [i+1,n] 中寻找 F 的位置，因此我们可以将搜索范围缩小到 [i+1,n] 或 [1,i-1] 中；如果这个最大值大于等于 dp_{k,n}，那么说明我们不能在 [1,i-1] 或 [i+1,n] 中寻找 F 的位置，因此我们需要在 [1,i-1] 和 [i+1,n] 中寻找 F 的位置，因此我们可以将搜索范围缩小到 [1,i-1] 和 [i+1,n] 中。

解决方案：

```rust
impl Solution {
    pub fn super_egg_drop(k: i32, n: i32) -> i32 {
        let mut dp = vec![vec![0; (n + 1) as usize]; (k + 1) as usize];
        for i in 1..=n {
            dp[1][i as usize] = i;
        }
        for i in 2..=k {
            let mut x = 1;
            for j in 1..=(n as usize) {
                while x < j && dp[i - 1][x] < dp[i][j - x - 1] {
                    x += 1;
                }
                dp[i][j] = dp[i - 1][x - 1] + dp[i][j - x] + 1;
            }
        }
        dp[k as usize][n as usize]
    }
}
```

算法复杂度：O(KN\log N)。