题目编号：799

题目：香槟塔

难度：中等

考察范围：动态规划

题干：

我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，……，第n层有n个。

每个玻璃杯可以装一定的香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，依此类推（超过了杯子的容量，香槟会立刻溢出）。

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满了的玻璃杯。在倒第四杯时，第三层中间的玻璃杯盛放了一半的香槟，他两侧的玻璃杯各自盛放了四分之一的香槟，如下图所示。

现在当倾倒了非负整数杯香槟后，返回第i行第j个玻璃杯内香槟的数量（i和j都从0开始）。

示例：

输入: poured(倾倒香槟总杯数) = 4, query_glass(查询的杯子位置) = 2, 1
输出: 0.5
解释: 
第一次倾倒四杯香槟后，第二层的香槟满了。但第三层的中间玻璃杯盛放了一半的香槟，所以返回0.5。

解题思路：

本题可以使用动态规划来解决。

我们可以用dp[i][j]表示第i行第j个杯子中的香槟数量，那么dp[i][j]的值可以由上一层的左右两个杯子溢出的香槟量来决定。

具体来说，如果上一层的左右两个杯子中的香槟量大于1，那么这些香槟会等分到当前杯子的左右两个杯子中，否则，这些香槟会全部流到当前杯子中。

最后，我们只需要返回dp[i][j]的值即可。

解决方案：

```rust
impl Solution {
    pub fn champagne_tower(poured: i32, query_row: i32, query_glass: i32) -> f64 {
        let mut dp = vec![vec![0.0; 101]; 101];
        dp[0][0] = poured as f64;
        for i in 0..query_row as usize {
            for j in 0..=i {
                let overflow = (dp[i][j] - 1.0) / 2.0;
                if overflow > 0.0 {
                    dp[i + 1][j] += overflow;
                    dp[i + 1][j + 1] += overflow;
                }
            }
        }
        dp[query_row as usize][query_glass as usize].min(1.0)
    }
}
```

算法复杂度：时间复杂度为O(n^2)，空间复杂度为O(n^2)。