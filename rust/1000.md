题目编号：1000

题目：合并石头的最低成本

难度：困难

考察范围：动态规划、贪心算法

题干：

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

示例 1：

输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [5, 4]，成本为 9，剩下 [9, 1]。
合并 [9, 1]，成本为 10，结束。
总成本 20，这是可能的最小值。

示例 2：

输入：stones = [3,2,4,1], K = 3
输出：-1
解释：任何合并操作后，都会剩下 2 堆，无法继续合并。因此，输入数组无法完成该操作。

示例 3：

输入：stones = [3,5,1,2,6], K = 3
输出：25
解释：
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，结束。
总成本 25，这是可能的最小值。

提示：

1 <= stones.length <= 30
2 <= K <= 30
1 <= stones[i] <= 100

解题思路：

这是一道动态规划的题目，我们可以用 dp[i][j] 表示将第 i 到 j 堆石头合并成一堆的最小成本。那么，我们可以枚举最后一次合并的位置 k，将 dp[i][j] 分成两部分，即 dp[i][k] 和 dp[k+1][j]，然后加上将这两部分合并的成本 stones[i]+stones[i+1]+...+stones[j]，即 dp[i][j] = dp[i][k] + dp[k+1][j] + sum(stones[i..=j])。

但是，这样的时间复杂度是 O(n^3)，无法通过本题。因此，我们需要优化。

我们可以发现，将 stones[i..=j] 合并成一堆的成本是固定的，因此，我们可以用前缀和 sum[i][j] 表示 stones[i..=j] 的和，这样，我们就可以在 O(1) 的时间内计算出 stones[i]+stones[i+1]+...+stones[j]。

接下来，我们考虑如何优化 dp。我们可以发现，对于 dp[i][j]，它的状态转移只与 dp[i][k] 和 dp[k+1][j] 有关，因此，我们可以使用区间 dp 的思想，从小区间向大区间转移，这样，我们就可以将时间复杂度优化到 O(n^3)。

解决方案：

```rust
fn merge_stones(stones: Vec<i32>, k: i32) -> i32 {
    let n = stones.len();
    let k = k as usize;
    if (n - 1) % (k - 1) != 0 {
        return -1;
    }
    let mut sum = vec![vec![0; n]; n];
    for i in 0..n {
        sum[i][i] = stones[i];
        for j in i + 1..n {
            sum[i][j] = sum[i][j - 1] + stones[j];
        }
    }
    let mut dp = vec![vec![0; n]; n];
    for len in k..=n {
        for i in 0..=n - len {
            let j = i + len - 1;
            dp[i][j] = std::i32::MAX;
            for t in i..j {
                if (t - i + 1) % (k - 1) == 0 && (j - t) % (k - 1) == 0 {
                    let cost = dp[i][t] + dp[t + 1][j] + sum[i][j];
                    dp[i][j] = dp[i][j].min(cost);
                }
            }
        }
    }
    dp[0][n - 1]
}
```

算法复杂度：O(n^3)。