题目编号：903

题目：DI 序列的有效排列

难度：困难

考察范围：动态规划

题干：

给定只含 "I"（增大）或 "D"（减小）的字符串 S ，令 N = S.length。

任何有效排列 P[0], P[1], ..., P[N] 都需要满足：

如果 S[i] == "I"，那么 P[i] < P[i+1]
如果 S[i] == "D"，那么 P[i] > P[i+1]
给定一个有效排列，考虑该排列中的最大值和最小值，以及该排列是否合法。我们将 P 信息嵌入序列中，请返回嵌入序列的最小可能熵解。形式化地，如果一个序列 B 是序列 A 的子序列，且 B[0] = A[0]，B[B.length - 1] = A[A.length - 1]，那么称序列 B 是序列 A 的一个嵌入序列。

例如，[0,1,2,3] 的一个嵌入序列是 [0,2,1,3]，而 [0,1,2,3,4] 不是 [0,3,1,4] 的嵌入序列。

示例 1：

输入："IDID"
输出：[0,4,1,3,2]
解释： 
给定的序列是 "IDID"，原始序列是 [0,1,2,3,4]。
可以将其重新排列为 [0,4,1,3,2]，这是一个有效排列，且最大值和最小值分别为 4 和 0。
因此，它是一个嵌入序列，该序列的熵为 3.3219280948873623。

示例 2：

输入："III"
输出：[0,1,2,3]
解释： 
输出返回了所有可能的排列方案中，最熵的排列。

解题思路：

本题可以使用动态规划来解决。我们可以定义状态 dp[i][j] 表示前 i 个数中，最后一个数为 j 的方案数。其中，j 的取值范围为 [0, N]，其中 N 为 S 的长度。

对于 S 中的第 i 个字符，如果是 "I"，那么我们需要找到前 i 个数中最后一个比 j 小的数 k，然后 dp[i][j] 就可以由 dp[i-1][k] 转移而来。如果是 "D"，那么我们需要找到前 i 个数中最后一个比 j 大的数 k，然后 dp[i][j] 就可以由 dp[i-1][k] 转移而来。

最终的答案就是 dp[N][0]，因为最后一个数必须是 0。

解决方案：

```rust
impl Solution {
    pub fn di_string_match(s: String) -> Vec<i32> {
        let n = s.len();
        let mut dp = vec![vec![0; n+1]; n+1];
        dp[0][0] = 1;
        for i in 1..=n {
            if s.chars().nth(i-1).unwrap() == 'I' {
                for j in 1..=i {
                    for k in 0..j {
                        dp[i][j] += dp[i-1][k];
                    }
                }
            } else {
                for j in (0..i).rev() {
                    for k in j..=i-1 {
                        dp[i][j] += dp[i-1][k+1];
                    }
                }
            }
        }
        let mut ans = vec![0; n+1];
        let mut used = vec![false; n+1];
        let mut cur = 0;
        for i in 0..=n {
            for j in 0..=n {
                if !used[j] {
                    if dp[n][j] >= cur+1 {
                        ans[i] = j as i32;
                        used[j] = true;
                        cur += 1;
                        break;
                    } else {
                        cur -= dp[n][j];
                    }
                }
            }
        }
        ans
    }
}
```

算法复杂度：时间复杂度为 O(N^3)，空间复杂度为 O(N^2)。