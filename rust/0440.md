题目编号：440

题目：字典序的第K小数字

难度：困难

考察范围：数学、字符串

题干：

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

示例：

输入:
n: 13   k: 2

输出:
10

解释:
字典序排序如下：
1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9
第二个数字是 10。

解题思路：

首先，我们需要了解字典序的定义。字典序是指在字典中排列的顺序，例如在英文字母表中，a 在 b 的前面，b 在 c 的前面，以此类推。

对于本题，我们需要找到 1 到 n 中字典序第 k 小的数字。我们可以从 1 开始，依次遍历每个数字，计算以该数字为前缀的数字个数，如果该数字的前缀数字个数小于 k，则说明答案在该数字的子树中，我们需要进一步遍历该数字的子树；否则，答案在该数字的同级右侧，我们需要遍历下一个数字。

具体来说，我们可以先计算以 1 为前缀的数字个数 count，如果 count 小于 k，则说明答案在以 1 为前缀的数字的子树中，我们需要进一步遍历以 1 为前缀的数字；否则，答案在以 1 为前缀的数字的同级右侧，我们需要遍历下一个数字。我们可以将这个过程抽象成一个树形结构，其中每个节点表示一个以某个数字为前缀的数字，节点的子节点表示在该数字的基础上添加一位数字所得到的数字。例如，以 1 为前缀的数字有 10、11、12、...、19，它们是 1 的子节点。

我们可以通过深度优先搜索遍历这个树形结构，计算每个节点的前缀数字个数。具体来说，我们可以先计算以 1 为前缀的数字个数 count，如果 count 小于 k，则说明答案在以 1 为前缀的数字的子树中，我们需要进一步遍历以 1 为前缀的数字；否则，答案在以 1 为前缀的数字的同级右侧，我们需要遍历下一个数字。如果 count 大于等于 k，则说明答案为以 1 为前缀的数字中的第 k 个数字，我们可以将答案设为 1，并退出搜索。

如果 count 小于 k，则说明答案在以 1 为前缀的数字的子树中。我们可以将答案设为 10，表示以 1 为前缀的数字中的第一个数字，然后进一步遍历以 1 为前缀的数字的子树。我们需要计算以 10 为前缀的数字个数 count，如果 count 小于 k，则说明答案在以 10 为前缀的数字的子树中，我们需要进一步遍历以 10 为前缀的数字；否则，答案在以 10 为前缀的数字的同级右侧，我们需要遍历下一个数字。如果 count 大于等于 k，则说明答案为以 10 为前缀的数字中的第 k 个数字，我们可以将答案设为 10，并退出搜索。

以此类推，直到找到第 k 个数字为止。

解决方案：

```rust
impl Solution {
    pub fn find_kth_number(n: i32, k: i32) -> i32 {
        let mut cur = 1;
        let mut k = k - 1;
        while k > 0 {
            let steps = Self::get_steps(n, cur, cur + 1);
            if steps <= k {
                cur += 1;
                k -= steps;
            } else {
                cur *= 10;
                k -= 1;
            }
        }
        cur
    }

    fn get_steps(n: i32, n1: i32, n2: i32) -> i32 {
        let mut steps = 0;
        let mut n1 = n1 as i64;
        let mut n2 = n2 as i64;
        while n1 <= n {
            steps += (n2.min(n as i64 + 1) - n1) as i32;
            n1 *= 10;
            n2 *= 10;
        }
        steps
    }
}
```

算法复杂度：时间复杂度为 O(\log n)，空间复杂度为 O(1)。