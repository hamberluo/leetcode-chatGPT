题目编号：375

题目：猜数字大小 II

难度：中等

考察范围：动态规划

题干：我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，才算游戏结束。

例如，n = 10，我选择了8。

你猜测 5，我告诉你，我选的数字比你的大了，你需要支付现金 5 元。

你猜测 7，我告诉你，我选的数字比你的小了，你需要支付现金 7 元。

你猜测 9，我告诉你，我选的数字比你的小了，你需要支付现金 9 元。

你猜测 8，我告诉你，恭喜你，你猜对了！

总共花费了 5 + 7 + 9 = 21 元。

给定 n，你需要返回最小花费费用，以便在游戏中获胜。

解题思路：动态规划

首先，我们可以确定一个事实，就是我们需要猜的数字一定在 1 到 n 之间，所以我们需要从 1 到 n 枚举每一个可能的答案，然后计算出每一个答案所需要的最小花费。

对于每一个答案 x，我们可以将其分为两个部分，一部分是猜测 x 的花费，另一部分是在猜测 x 的基础上，需要猜测剩余数字的最小花费。

我们可以使用一个二维数组 dp 来记录每一个答案所需要的最小花费，其中 dp[i][j] 表示在猜测 i 到 j 之间的数字时，所需要的最小花费。

对于每一个 dp[i][j]，我们可以枚举 k，其中 i <= k <= j，然后计算出在猜测 k 的基础上，需要猜测剩余数字的最小花费，即 dp[i][k-1] 和 dp[k+1][j] 中的最大值，然后加上猜测 k 的花费，即 k，就可以得到 dp[i][j] 的值。

最终，dp[1][n] 就是我们需要的答案。

解决方案：

```rust
impl Solution {
    pub fn get_money_amount(n: i32) -> i32 {
        let n = n as usize;
        let mut dp = vec![vec![0; n+1]; n+1];
        for len in 2..=n {
            for i in 1..=n-len+1 {
                let j = i + len - 1;
                dp[i][j] = std::i32::MAX;
                for k in i..=j {
                    let cost = k as i32 + std::cmp::max(dp[i][k-1], dp[k+1][j]);
                    dp[i][j] = std::cmp::min(dp[i][j], cost);
                }
            }
        }
        dp[1][n]
    }
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。