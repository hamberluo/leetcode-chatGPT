题目编号：667

题目：优美的排列 II

难度：中等

考察范围：数组、贪心算法

题干：给定两个整数 n 和 k，你需要实现一个数组，这个数组需要满足如下条件：

1. 数组的长度为 n，且只包含 1 到 n 这 n 个数字。
2. 序列中不重复的元素数量恰好为 k。
3. 对于序列中的每个 i（1 ≤ i < n），满足 |seq[i] - seq[i-1]| == d，其中 d 为序列中两个连续元素之间的差的绝对值之一。

返回任意一个满足上述条件的数组即可。

解题思路：贪心算法

首先，我们可以构造一个长度为 n 的数组，其中前 k 个元素为 1 到 k 的正整数，后面的元素为 k+1 到 n 的正整数。这样，我们就满足了第一个条件。

接下来，我们考虑如何满足第二个条件。我们可以从第 k+1 个元素开始，每次交替插入一个新的元素和一个已有的元素，直到插入了 n 个元素为止。这样，我们就满足了第二个条件。

最后，我们考虑如何满足第三个条件。我们可以从第 k+1 个元素开始，每次插入一个新的元素和一个已有的元素，使得它们的差的绝对值为 d。如果当前的差的绝对值为 d，我们就插入一个新的元素；否则，我们就插入一个已有的元素。这样，我们就满足了第三个条件。

解决方案：

```rust
impl Solution {
    pub fn construct_array(n: i32, k: i32) -> Vec<i32> {
        let mut res = vec![0; n as usize];
        let mut l = 1;
        let mut r = k + 1;
        for i in 0..k+1 {
            if i % 2 == 0 {
                res[i as usize] = l;
                l += 1;
            } else {
                res[i as usize] = r;
                r -= 1;
            }
        }
        let mut d = 1;
        for i in (k+1) as usize..n as usize {
            res[i] = res[i-1] + d;
            if d > 0 {
                d = -d - 1;
            } else {
                d = -d + 1;
            }
        }
        res
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。