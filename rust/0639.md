题目编号：639

题目：解码方法 II

难度：困难

考察范围：动态规划

题干：

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'，可以表示从 1 到 9 的任意数字（不包括 0）。例如，字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18"、"19"。

给定一串数字，你可以解码它吗？

编写一个函数，以字符串作为输入，返回解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

解题思路：

本题是一道动态规划的题目，我们可以定义一个 dp 数组，其中 dp[i] 表示前 i 个字符的解码方法总数。

对于第 i 个字符，我们需要考虑以下两种情况：

1. 如果第 i 个字符是数字，那么它可以单独解码成一个字母，也可以和前一个数字组成一个字母。如果第 i 个字符是 0，那么它只能和前一个数字组成一个字母。因此，我们可以得到以下状态转移方程：

   if s[i] == '0':
       if s[i-1] == '1' or s[i-1] == '2':
           dp[i] = dp[i-2]
       else:
           return 0
   elif s[i] >= '1' and s[i] <= '9':
       dp[i] = dp[i-1]
       if s[i-1] == '1' or (s[i-1] == '2' and s[i] <= '6'):
           dp[i] += dp[i-2]

2. 如果第 i 个字符是 *，那么它可以单独解码成一个字母，也可以和前一个数字组成一个字母。如果第 i 个字符是 *，那么它可以代表 1 到 9 中的任意一个数字。因此，我们可以得到以下状态转移方程：

   dp[i] = 9 * dp[i-1]
   if s[i-1] == '1':
       dp[i] += 9 * dp[i-2]
   elif s[i-1] == '2':
       dp[i] += 6 * dp[i-2]
   elif s[i-1] == '*':
       dp[i] += 15 * dp[i-2]

最终的答案就是 dp[n]，其中 n 是字符串的长度。

解决方案：

```rust
impl Solution {
    pub fn num_decodings(s: String) -> i32 {
        let n = s.len();
        let s = s.chars().collect::<Vec<_>>();
        let mut dp = vec![0; n+1];
        dp[0] = 1;
        if s[0] == '0' {
            return 0;
        }
        dp[1] = if s[0] == '*' { 9 } else { 1 };
        for i in 2..=n {
            if s[i-1] == '0' {
                if s[i-2] == '1' || s[i-2] == '2' {
                    dp[i] = dp[i-2];
                } else {
                    return 0;
                }
            } else if s[i-1] >= '1' && s[i-1] <= '9' {
                dp[i] = dp[i-1];
                if s[i-2] == '1' || (s[i-2] == '2' && s[i-1] <= '6') {
                    dp[i] += dp[i-2];
                }
            } else if s[i-1] == '*' {
                dp[i] = 9 * dp[i-1];
                if s[i-2] == '1' {
                    dp[i] += 9 * dp[i-2];
                } else if s[i-2] == '2' {
                    dp[i] += 6 * dp[i-2];
                } else if s[i-2] == '*' {
                    dp[i] += 15 * dp[i-2];
                }
            }
            dp[i] %= 1000000007;
        }
        dp[n] as i32
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。