题目编号：960

题目：删列造序 III

难度：中等

考察范围：动态规划

题干：

给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。

选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。

比如，有 A = ["abcdef", "uvwxyz"]，删除索引序列 {0, 2, 3}，删除后 A[0] = "bef", A[1] = "wxyz"。

假设，我们选择了一组删除索引 D，在执行删除操作之后，A 中剩余的每一列都是非降序排列的，那么称 D 是关键删列集合。

请你返回 A 的关键删列集合中最小可能的元素数量。

解题思路：

这道题目可以转化为一个最长上升子序列的问题。

我们可以先将每个字符串按照删除索引删除后，得到一个新的字符串数组 B。

然后我们可以枚举删除索引的组合，对于每个组合，判断是否满足删除后的 B 数组每一列都是非降序排列的。

如果满足条件，我们可以将这个组合中未被删除的列组成一个新的字符串数组 C，然后求 C 的最长上升子序列的长度。

最后，我们可以将所有满足条件的组合中最长上升子序列的长度取最小值，即为答案。

解决方案：

```rust
impl Solution {
    pub fn min_deletion_size(a: Vec<String>) -> i32 {
        let n = a[0].len();
        let mut dp = vec![1; n];
        let mut ans = n as i32;
        for i in 0..n {
            for j in 0..i {
                let mut flag = true;
                for k in 0..a.len() {
                    if a[k].as_bytes()[j] > a[k].as_bytes()[i] {
                        flag = false;
                        break;
                    }
                }
                if flag {
                    dp[i] = dp[i].max(dp[j] + 1);
                }
            }
            ans = ans.min(n as i32 - dp[i]);
        }
        ans
    }
}
```

算法复杂度：O(n^3)，其中 n 是字符串的长度。