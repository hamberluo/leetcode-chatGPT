题目编号：503

题目：下一个更大元素 II

难度：中等

考察范围：栈、数组

题干：给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是指 x 在数组中对应位置的右边的第一个比 x 大的元素，如果不存在，输出 -1。

解题思路：可以使用单调栈来解决这个问题。由于是循环数组，我们可以将原数组复制一份接在原数组的末尾，这样就可以处理循环的情况了。我们可以遍历这个新数组，对于每个元素，如果栈为空，就将当前元素入栈；如果栈不为空，就比较当前元素和栈顶元素的大小，如果当前元素比栈顶元素大，就将栈顶元素出栈，并将栈顶元素的下一个更大元素设为当前元素，重复这个过程直到当前元素小于等于栈顶元素，然后将当前元素入栈。最后，我们只需要遍历原数组，将每个元素的下一个更大元素输出即可。

解决方案：

```rust
impl Solution {
    pub fn next_greater_elements(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut stack = Vec::new();
        let mut res = vec![-1; n];
        for i in 0..2 * n {
            let j = i % n;
            while !stack.is_empty() && nums[*stack.last().unwrap()] < nums[j] {
                let idx = stack.pop().unwrap();
                res[idx] = nums[j];
            }
            stack.push(j);
        }
        res
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。