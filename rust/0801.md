题目编号：801

题目：使序列递增的最小交换次数

难度：中等

考察范围：贪心算法、动态规划

题干：给定一个长度为 n 的整数序列，你需要找到一个最小的交换次数，使得交换任意两个元素后，序列变得递增。换句话说，找到最小的 k，使得交换任意两个下标 i 和 j，满足 i < j 且 a[i] > a[j]，交换 k 次后，序列变得递增。

解题思路：贪心算法

对于一个序列，我们可以通过交换相邻的两个元素来使得序列递增。因此，我们可以考虑对于每个位置 i，找到它后面第一个比它大的数 j，然后将 i 和 j 交换。这样，我们就可以将 i 后面的所有数都变得比 i 大，从而使得序列递增。

但是，这种贪心策略并不一定能够得到最优解。例如，对于序列 [3, 1, 2, 4, 5]，我们可以先将 1 和 2 交换，然后再将 1 和 3 交换，最终得到序列 [1, 2, 3, 4, 5]，需要交换 2 次。但是，如果我们先将 1 和 3 交换，然后再将 1 和 2 交换，最终得到的序列也是 [1, 2, 3, 4, 5]，但是只需要交换 1 次。

因此，我们需要考虑一种更加优秀的贪心策略。我们可以从左到右遍历整个序列，对于每个位置 i，找到它后面第一个比它大的数 j，然后计算将 i 和 j 交换所需要的最小交换次数。具体来说，我们可以将 i 和 j 之间的所有数都看作是 i 的候选交换位置，然后选择其中最优的位置进行交换。这样，我们就可以保证每次交换都是最优的，从而得到最小的交换次数。

解决方案：

```rust
impl Solution {
    pub fn min_swap(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let n = nums1.len();
        let mut dp = vec![vec![n; 2]; n];
        dp[0][0] = 0;
        dp[0][1] = 1;
        for i in 1..n {
            if nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1] {
                dp[i][0] = dp[i - 1][0];
                dp[i][1] = dp[i - 1][1] + 1;
            }
            if nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1] {
                dp[i][0] = dp[i][0].min(dp[i - 1][1]);
                dp[i][1] = dp[i][1].min(dp[i - 1][0] + 1);
            }
        }
        dp[n - 1][0].min(dp[n - 1][1]) as i32
    }
}
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(n)。