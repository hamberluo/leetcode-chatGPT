题目编号：600

题目：不含连续1的非负整数

难度：简单

考察范围：位运算、动态规划

题干：

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含连续的 1 的个数。

例如，1、3、5 都是小于或等于 5 的非负整数，且它们的二进制表示分别为 1、11、101，其中只有 1 个数（5）的二进制表示不包含连续的 1，因此输出 1。

解题思路：

对于一个二进制数，如果它的最后一位是 0，那么它的 1 的个数就是它右移一位的数的 1 的个数；如果它的最后两位是 01，那么它的 1 的个数就是它右移两位的数的 1 的个数加 1；如果它的最后两位是 11，那么它的 1 的个数就是它右移两位的数的 1 的个数。

因此，我们可以用动态规划的思想，从低位到高位依次计算每个数的 1 的个数。

解决方案：

```rust
impl Solution {
    pub fn find_integers(n: i32) -> i32 {
        let mut dp = vec![0; 32];
        dp[0] = 1;
        dp[1] = 2;
        for i in 2..32 {
            dp[i] = dp[i-1] + dp[i-2];
        }
        let mut n = n;
        let mut pre_bit = 0;
        let mut res = 0;
        for i in (0..31).rev() {
            let bit = (n >> i) & 1;
            if bit == 1 {
                res += dp[i];
                if pre_bit == 1 {
                    return res;
                }
                pre_bit = 1;
            } else {
                pre_bit = 0;
            }
        }
        res + 1
    }
}
```

算法复杂度：时间复杂度为 O(log n)，空间复杂度为 O(1)。