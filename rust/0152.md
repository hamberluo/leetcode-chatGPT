题目编号：152

题目：乘积最大子数组

难度：中等

考察范围：动态规划

题干：

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

解题思路：

本题可以使用动态规划来解决，我们可以定义两个数组，一个存储当前位置的最大值，一个存储当前位置的最小值，因为负数乘以负数会变成正数，所以我们需要同时记录最小值和最大值。

对于当前位置，如果当前位置的值为正数，则最大值为前一个位置的最大值乘以当前位置的值和当前位置的值中的较大值，最小值为前一个位置的最小值乘以当前位置的值和当前位置的值中的较小值。

如果当前位置的值为负数，则最大值为前一个位置的最小值乘以当前位置的值和当前位置的值中的较大值，最小值为前一个位置的最大值乘以当前位置的值和当前位置的值中的较小值。

最后，我们只需要遍历一遍数组，找到最大值即可。

解决方案：

```rust
impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut max_dp = vec![0; n];
        let mut min_dp = vec![0; n];
        max_dp[0] = nums[0];
        min_dp[0] = nums[0];
        let mut res = nums[0];
        for i in 1..n {
            if nums[i] > 0 {
                max_dp[i] = max_dp[i - 1].max(1) * nums[i];
                min_dp[i] = min_dp[i - 1].min(1) * nums[i];
            } else {
                max_dp[i] = min_dp[i - 1].min(1) * nums[i];
                min_dp[i] = max_dp[i - 1].max(1) * nums[i];
            }
            res = res.max(max_dp[i]);
        }
        res
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。