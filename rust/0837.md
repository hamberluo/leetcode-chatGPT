题目编号：837

题目：新21点

难度：中等

考察范围：动态规划

题干：爱丽丝参与一个大致基于纸牌游戏 “21 点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从牌顶抽一张牌，将其点数添加到自己的得分中。 每张牌都有其对应的点数，J、Q、K 的点数为 10，A 的点数为 1 或 11（选择使得爱丽丝的点数不超过 21 的那个值），牌面数字的点数为其本身。 本题中，card(x) 表示 x 这张牌的点数。

游戏结束后，如果爱丽丝的得分小于等于 21 分，则她的得分与游戏开始时相同。否则，她的得分为 -1。

当爱丽丝得分小于 K 分时，她会继续抽取牌，直到得分大于等于 K 分。

给你数据 K，deck 和 W，返回达到得分 K 所需的最小牌数，如果不可能达到该分数，返回 0。

解题思路：动态规划

我们可以用 dp[x] 表示当前得分为 x 时，最终能够到达得分 K 的概率。最终的答案即为 dp[0]。

对于每一张牌，我们可以转移当前的 dp 值。如果当前得分为 x，下一步会得到一张牌，它有 card(x) 种可能的取值。这些取值均等可能，因此我们可以列出如下的转移方程：

dp[x] = (dp[x+1] + dp[x+2] + ... + dp[x+card(x)]) / card(x)

这里的除法是整数除法，也就是说，当 x+card(x) > K 时，我们将分母减小一些。

我们可以从得分为 K 的位置开始倒推。当 K ≤ x ≤ min(N-1, K+W-1) 时，dp[x] 的值已经确定为 1。这是因为无论我们抽到什么牌，得分都会超过 K，因此游戏立即结束。

最后，我们可以根据上述转移方程，从 dp[x+1] 计算出 dp[x]，直到计算出 dp[0]。

解决方案：

```rust
impl Solution {
    pub fn new21_game(n: i32, k: i32, max_pts: i32) -> f64 {
        let k = k as usize;
        let max_pts = max_pts as usize;
        let mut dp = vec![0.0; k + max_pts];
        let mut s = 0.0;
        for i in k..k + max_pts {
            dp[i] = if i <= n { 1.0 } else { 0.0 };
            s += dp[i];
        }
        for i in (0..k).rev() {
            dp[i] = s / max_pts as f64;
            s += dp[i] - dp[i + max_pts];
        }
        dp[0]
    }
}
```

算法复杂度：时间复杂度为 O(K + W)，空间复杂度为 O(K + W)。