题目编号：277

题目：搜索名人

难度：中等

考察范围：图论、搜索算法

题干：假设你是一个专业的狗仔队记者，参加了一个 n 人派对，其中每个人被从 0 到 n - 1 标号。在这个派对人群中可能存在一位 “名人”。所谓 “名人” 的定义是：其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人。

现在你想要确认这个 “名人” 是否存在，或者确定不存在。你唯一能做的就是问诸如 “A 你好呀，请问你认不认识 B？” 的问题，以此来确定 A 是否认识 B。你需要在渐近意义下尽可能减少问题的数量。

给你一个辅助函数 bool knows(a, b)，返回值为 true 表示 a 认识 b，false 表示不认识。

解题思路：这道题可以用图论中的拓扑排序来解决。我们可以将每个人看作一个节点，如果一个人认识另一个人，那么就从前者向后者连一条有向边。那么如果存在一个 “名人”，那么他一定是这个有向图中的一个入度为 n - 1，出度为 0 的节点。因为他不认识其他人，所以他不会向其他人连边，而其他人都会向他连边。

我们可以用拓扑排序来找到这个入度为 n - 1，出度为 0 的节点。具体来说，我们可以先遍历一遍图，找到所有入度为 0 的节点，将它们加入队列中。然后每次从队列中取出一个节点，将它的所有出边删除，如果此时有某个节点的入度变为 0，那么就将它加入队列中。最后如果队列为空，说明没有符合条件的节点，返回 -1，否则返回队列中最后一个节点，因为如果存在 “名人”，那么他一定是最后一个入队的节点。

解决方案：

```rust
impl Solution {
    pub fn find_celebrity(&self, n: i32) -> i32 {
        let mut indegrees = vec![0; n as usize];
        let mut outdegrees = vec![0; n as usize];
        for i in 0..n {
            for j in 0..n {
                if i == j {
                    continue;
                }
                if self.knows(i as i32, j as i32) {
                    outdegrees[i as usize] += 1;
                    indegrees[j as usize] += 1;
                }
            }
        }
        for i in 0..n {
            if indegrees[i as usize] == n - 1 && outdegrees[i as usize] == 0 {
                return i;
            }
        }
        -1
    }
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。