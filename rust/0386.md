题目编号：386

题目：字典序排数

难度：中等

考察范围：递归、字典序

题干：

给定一个整数 n, 返回从 1 到 n 的字典顺序。

例如，

给定 n = 13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9]。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 同样会确保合法，即 n 在 [1, 10^5]范围内。

解题思路：

题目要求按照字典序排列从1到n的所有数字，可以先将数字转化为字符串，然后按照字符串的字典序进行排序。

但是这种方法的时间复杂度为O(nlogn)，不符合题目要求。因此需要寻找更优的解法。

我们可以将数字看成一棵树，每个节点表示一个数字，每个节点的子节点表示在该节点后面添加一个数字所得到的数字。

例如，数字1的子节点为10、11、12、13、14、15、16、17、18、19，数字10的子节点为100、101、102、103、104、105、106、107、108、109。

我们可以先将数字1的所有子节点加入结果数组中，然后递归地遍历每个子节点，将每个子节点的所有子节点加入结果数组中，直到遍历完所有的子节点。

需要注意的是，当数字大于n时，需要停止遍历。

解决方案：

```rust
impl Solution {
    pub fn lexical_order(n: i32) -> Vec<i32> {
        let mut res = Vec::new();
        for i in 1..10 {
            Self::dfs(i, n, &mut res);
        }
        res
    }

    fn dfs(cur: i32, n: i32, res: &mut Vec<i32>) {
        if cur > n {
            return;
        }
        res.push(cur);
        for i in 0..10 {
            let next = cur * 10 + i;
            if next > n {
                return;
            }
            Self::dfs(next, n, res);
        }
    }
}
```

算法复杂度：时间复杂度为O(n)，空间复杂度为O(n)。