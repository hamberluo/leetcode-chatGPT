题目编号：256

题目：粉刷房子

难度：中等

考察范围：动态规划

题干：你有一个房子，需要粉刷墙壁。这个房子有 n 个不同的位置，每个位置可以被涂上红色、蓝色或绿色。你必须将所有相邻的位置都涂上不同的颜色。你可以用不同的颜色粉刷相邻的位置，但相邻的位置不能同时涂上相同的颜色。

给定一个整数 n，你需要计算出有多少种不同的涂色方案。

注意：n 的范围为 [1, 50]。

解题思路：动态规划

我们可以用 dp[i][j] 表示前 i 个房子，第 i 个房子涂上颜色 j 的方案数。其中，j 可以取 0、1、2，分别表示红色、蓝色、绿色。

对于第 i 个房子，它可以涂上三种颜色中的任意一种，但是要求与前一个房子的颜色不同。因此，我们需要枚举第 i-1 个房子的颜色 k，然后计算 dp[i][j] 的值。

具体来说，我们可以列出如下的状态转移方程：

dp[i][0] = dp[i-1][1] + dp[i-1][2]
dp[i][1] = dp[i-1][0] + dp[i-1][2]
dp[i][2] = dp[i-1][0] + dp[i-1][1]

最终的答案即为 dp[n][0] + dp[n][1] + dp[n][2]。

解决方案：

```kotlin
class Solution {
    fun numWays(n: Int): Int {
        val dp = Array(n + 1) { IntArray(3) }
        dp[0][0] = 1
        dp[0][1] = 1
        dp[0][2] = 1
        for (i in 1..n) {
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % 1000000007
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 1000000007
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % 1000000007
        }
        return (dp[n][0] + dp[n][1] + dp[n][2]) % 1000000007
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。