题目编号：600

题目：不含连续1的非负整数

难度：简单

考察范围：位运算、动态规划

题干：给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含连续的 1 的个数。

例如，输入 5，返回 5，因为 5 的二进制表示为 101，其不包含连续的 1；输入 8，返回 6，因为小于等于 8 的非负整数中，其二进制表示不包含连续的 1 的个数分别为：0、1、10、100、101、110 和 1000。

解题思路：动态规划

对于一个二进制数，如果它的最高位是 0，那么它的二进制表示中不包含连续的 1 的个数就等于它去掉最高位后的二进制表示中不包含连续的 1 的个数。

如果它的最高位是 1，那么它的二进制表示中不包含连续的 1 的个数就等于它去掉最高位后的二进制表示中不包含连续的 1 的个数加上一个特殊的数，这个特殊的数是最高位为 1，次高位为 0，其余位为 1 的数。

因此，我们可以使用动态规划来解决这个问题。设 dp[i] 表示小于等于 i 的非负整数中，其二进制表示不包含连续的 1 的个数。对于 i 的二进制表示中的每一位，如果这一位是 0，那么它对应的 dp 值就等于 i 去掉这一位后的数的 dp 值；如果这一位是 1，那么它对应的 dp 值就等于 i 去掉这一位后的数的 dp 值加上一个特殊的数。

解决方案：

```kotlin
class Solution {
    fun findIntegers(n: Int): Int {
        val dp = IntArray(32)
        dp[0] = 1
        dp[1] = 2
        for (i in 2 until dp.size) {
            dp[i] = dp[i - 1] + dp[i - 2]
        }
        var ans = 0
        var pre = 0
        for (i in 30 downTo 0) {
            val cur = 1 shl i
            if (n and cur != 0) {
                ans += dp[i]
                if (pre == 1) {
                    break
                }
                pre = 1
            } else {
                pre = 0
            }
            if (i == 0) {
                ans++
            }
        }
        return ans
    }
}
```

算法复杂度：时间复杂度为 O(\log n)，空间复杂度为 O(\log n)。