题目编号：979

题目：在二叉树中分配硬币

难度：中等

考察范围：二叉树、递归、贪心算法

题干：

给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。

在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。 

(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。

返回使每个结点上只有一枚硬币所需的移动次数。

解题思路：

对于每个节点，我们需要计算它的过载量，即它的硬币数减去它应该有的硬币数（即1个硬币）。然后，我们可以在递归中将这些过载量向它的父节点传递，从而计算整个树的答案。

对于一个节点来说，它的过载量等于它的左子节点的过载量加上它的右子节点的过载量，再加上它自己的硬币数减1。这个过载量可能是负数，表示这个节点需要硬币，或者是正数，表示这个节点有多余的硬币。

对于每个节点，我们计算它需要移动的次数，即它的过载量的绝对值除以2。然后，我们将这个过载量的相反数（正数或负数）返回给它的父节点，表示它从父节点那里获得或者需要移动的硬币数。

解决方案：

```kotlin
class Solution {
    var ans = 0

    fun distributeCoins(root: TreeNode?): Int {
        dfs(root)
        return ans
    }

    private fun dfs(node: TreeNode?): Int {
        if (node == null) {
            return 0
        }
        val left = dfs(node.left)
        val right = dfs(node.right)
        ans += Math.abs(left) + Math.abs(right)
        return left + right + node.`val` - 1
    }
}
```

算法复杂度：时间复杂度为 O(n)，其中 n 是二叉树中的节点数。对于每个节点，我们最多只需要访问它的左右子节点各一次，因此时间复杂度为 O(n)。空间复杂度为 O(h)，其中 h 是二叉树的高度。空间复杂度主要取决于递归调用的栈空间，而根据题目的约束，树的高度不会超过树中节点数的范围，因此空间复杂度为 O(n)。