题目编号：60

题目：第k个排列

难度：中等

考察范围：数学、回溯算法

题干：给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。

解题思路：回溯算法

我们可以使用回溯算法来解决这个问题。我们可以先生成所有的排列，然后按照字典序排序，最后返回第 k 个排列。

但是这种方法的时间复杂度为 O(n!)，当 n 很大时，会超时。因此我们需要优化这个算法。

我们可以根据 k 的值来确定每一位上的数字。假设 n = 4，k = 9，我们可以先确定第一位上的数字。由于每个数字开头的排列数都是一样的，即 (n-1)!，因此第一位上的数字为 (k-1) / 6 + 1 = 2。然后我们可以将 2 从集合中删除，得到集合 [1, 3, 4]。接下来我们需要确定第二位上的数字。由于已经确定了第一位上的数字为 2，因此第二位上的数字只能是 1、3、4 中的一个。我们可以计算出以 1、3、4 开头的排列数分别为 (n-2)!，因此可以得到第二位上的数字为 3。然后我们可以将 3 从集合中删除，得到集合 [1, 4]。接下来我们需要确定第三位上的数字。由于已经确定了前两位上的数字为 2、3，因此第三位上的数字只能是 1 或 4。我们可以计算出以 1、4 开头的排列数分别为 (n-3)!，因此可以得到第三位上的数字为 1。最后一位上的数字只能是 4，因此得到的排列为 2314。

解决方案：

```kotlin
class Solution {
    fun getPermutation(n: Int, k: Int): String {
        val nums = mutableListOf<Int>()
        for (i in 1..n) {
            nums.add(i)
        }
        val factorials = IntArray(n)
        factorials[0] = 1
        for (i in 1 until n) {
            factorials[i] = factorials[i - 1] * i
        }
        var k = k - 1
        val sb = StringBuilder()
        for (i in n - 1 downTo 0) {
            val index = k / factorials[i]
            sb.append(nums[index])
            nums.removeAt(index)
            k -= index * factorials[i]
        }
        return sb.toString()
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。