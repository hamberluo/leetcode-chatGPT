题目编号：768

题目：最多能完成排序的块 II

难度：困难

考察范围：数组、双指针

题干：

给定一个数组arr，其中有不同的数字，但可能存在相等的整数。我们将这个数组分成几个“块”，并将这些块分别进行排序。

排序后，再把这些块连接起来，使得连接后的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例 1:

输入: arr = [5,4,3,2,1]
输出: 1
解释:
将整个数组分成一个块，排序后为 [1, 2, 3, 4, 5]。

示例 2:

输入: arr = [2,1,3,4,4]
输出: 4
解释:
我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。
然后这些块分别进行排序后得到 [1, 2], [3, 4, 4]。
连接这些块后得到 [1, 2, 3, 4, 4]，这也是升序排序后的数组。

解题思路：

题目要求我们将数组分成多个块，使得每个块内的元素排序后，整个数组就是有序的。我们可以使用双指针的方法来解决这个问题。

我们从左到右遍历数组，同时维护一个变量 max，表示当前块内的最大值。当我们遍历到位置 i 时，我们将 max 更新为 max 和 arr[i] 中的较大值。

同时，我们需要维护一个变量 right，表示当前块的右边界。当我们遍历到位置 i 时，我们将 right 更新为 right 和 i 中的较小值。

如果当前位置 i 等于 right，那么说明当前块内的所有元素都小于等于 max，因此我们可以将当前块分割出来，并开始处理下一个块。

解决方案：

```kotlin
class Solution {
    fun maxChunksToSorted(arr: IntArray): Int {
        var max = 0
        var right = 0
        var count = 0
        for (i in arr.indices) {
            max = maxOf(max, arr[i])
            right = minOf(right, i)
            if (max == i) {
                count++
            }
        }
        return count
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。