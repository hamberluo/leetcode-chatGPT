题目编号：264

题目：丑数 II

难度：中等

考察范围：动态规划、堆

题干：

编写一个程序，找出第 n 个丑数。

丑数就是只包含质因数 2、3 和/或 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明:  

1 是丑数。
n 不超过1690。

解题思路：

丑数是只包含质因数 2、3 和/或 5 的正整数，因此第 n 个丑数一定可以表示为 2^i * 3^j * 5^k 的形式，其中 i,j,k 都是非负整数。

我们可以从小到大枚举 i,j,k，每次计算出当前的丑数，直到找到第 n 个丑数为止。但是这种方法的时间复杂度为 O(n^3)，无法通过本题。

我们可以使用动态规划的思想，从已知的丑数中推导出新的丑数。具体来说，我们设已知的第 i 个丑数为 nums[i]，则第 i+1 个丑数一定是在 nums[0:i] 中的某个数乘以 2、3 或 5 的结果中的最小值。我们可以使用三个指针 p2,p3,p5 分别表示下一个丑数是当前指针指向的丑数乘以 2、3 或 5 得到的，每次选择其中的最小值作为新的丑数，并将对应的指针向前移动一步。

解决方案：

```kotlin
class Solution {
    fun nthUglyNumber(n: Int): Int {
        val nums = IntArray(n)
        nums[0] = 1
        var p2 = 0
        var p3 = 0
        var p5 = 0
        for (i in 1 until n) {
            val num2 = nums[p2] * 2
            val num3 = nums[p3] * 3
            val num5 = nums[p5] * 5
            val num = minOf(num2, num3, num5)
            nums[i] = num
            if (num == num2) {
                p2++
            }
            if (num == num3) {
                p3++
            }
            if (num == num5) {
                p5++
            }
        }
        return nums[n - 1]
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。