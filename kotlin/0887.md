题目编号：887

题目：鸡蛋掉落

难度：困难

考察范围：动态规划、二分查找

题干：

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋），并将其从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

解题思路：

这是一道经典的动态规划问题，但是直接使用动态规划会超时，因此需要使用二分查找进行优化。

我们可以定义状态 dp(k, n) 表示有 k 个鸡蛋，可以尝试扔 n 次鸡蛋，最坏情况下能够确定的楼层数。

对于每次扔鸡蛋，有两种情况：鸡蛋碎了或者没碎。

如果鸡蛋碎了，那么我们需要在下面的楼层继续尝试，此时剩余的鸡蛋数为 k-1，可以尝试的次数为 n-1，因此能够确定的楼层数为 dp(k-1, n-1)。

如果鸡蛋没碎，那么我们需要在上面的楼层继续尝试，此时剩余的鸡蛋数为 k，可以尝试的次数为 n-1，因此能够确定的楼层数为 dp(k, n-1)。

因此，我们可以得到状态转移方程：

dp(k, n) = dp(k-1, n-1) + dp(k, n-1) + 1

其中，1 表示当前尝试的楼层数。

我们需要找到最小的 n，使得 dp(K, n) >= N，即能够确定的楼层数大于等于 N。

由于 dp(k, n) 随着 n 的增加而单调递增，因此可以使用二分查找来优化。

解决方案：

```kotlin
class Solution {
    fun superEggDrop(K: Int, N: Int): Int {
        val dp = Array(K + 1) { IntArray(N + 1) }
        var n = 0
        while (dp[K][n] < N) {
            n++
            for (k in 1..K) {
                dp[k][n] = dp[k][n - 1] + dp[k - 1][n - 1] + 1
            }
        }
        return n
    }
}
```

算法复杂度：时间复杂度为 O(KNlogN)，空间复杂度为 O(KN)。