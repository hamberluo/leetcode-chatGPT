题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：

你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许重复）。请你为她按如下规则创建一个播放列表：

每首歌至少播放一次。
一首歌只有在其他 K 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

解题思路：

动态规划

设 dp[i][j] 表示播放列表长度为 i，其中有 j 首不同的歌的方案数。

考虑 dp[i][j] 如何转移：

最后一首歌是新歌，即之前播放了 j - 1 首不同的歌，那么有 dp[i-1][j-1] * (N - j + 1) 种方案。

最后一首歌是旧歌，即之前播放了 j 首不同的歌，那么有 dp[i-1][j] * (j - K) 种方案。

综上，dp[i][j] = dp[i-1][j-1] * (N - j + 1) + dp[i-1][j] * (j - K)。

解决方案：

```kotlin
class Solution {
    fun numMusicPlaylists(N: Int, L: Int, K: Int): Int {
        val mod = 1000000007
        val dp = Array(L + 1) { IntArray(N + 1) }
        dp[0][0] = 1
        for (i in 1..L) {
            for (j in 1..N) {
                dp[i][j] = (dp[i - 1][j - 1] * (N - j + 1) % mod + dp[i - 1][j] * (j - K) % mod) % mod
            }
        }
        return dp[L][N]
    }
}
```

算法复杂度：时间复杂度 O(LN)，空间复杂度 O(LN)。