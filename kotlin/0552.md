题目编号：552

题目：学生出勤记录 II

难度：困难

考察范围：动态规划

题干：

给定一个正整数 n，表示该学生的出勤记录的长度。正整数 m 表示该学生缺席的最大次数。

学生的出勤记录是一个字符串，仅包含以下三个字符：

'A' : Absent，缺勤
'L' : Late，迟到
'P' : Present，到场

如果学生能够同时满足下面两个条件，则可以获得出勤奖励：

按总出勤计，学生缺席（'A'）严格少于 m 次。
学生不会存在连续 3 次或 3 次以上的迟到（'L'）记录。

给定 n 和 m，返回可以获得出勤奖励的记录情况数量。答案可能非常大，所以返回对 10^9 + 7 取余的结果。

解题思路：

本题可以使用动态规划来解决。

定义 dp[i][j][k] 表示前 i 天，缺席了 j 天，结尾连续迟到了 k 天的方案数。

对于第 i 天，有以下三种情况：

第 i 天缺席，即 s[i-1] == 'A'，则 dp[i][j+1][0] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]。

第 i 天到场，即 s[i-1] == 'P'，则 dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]。

第 i 天迟到，即 s[i-1] == 'L'，则 dp[i][j][k+1] = dp[i-1][j][k]。

最终的答案为所有 dp[n][j][k] 的和，其中 0 <= j <= m，0 <= k <= 2。

解决方案：

```kotlin
class Solution {
    fun checkRecord(n: Int): Int {
        val mod = 1000000007
        val dp = Array(n+1) { Array(2) { IntArray(3) } }
        dp[0][0][0] = 1
        for (i in 1..n) {
            // 第 i 天缺席
            dp[i][1][0] = (dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % mod
            dp[i][1][1] = dp[i-1][1][0]
            dp[i][1][2] = dp[i-1][1][1]
            // 第 i 天到场
            dp[i][0][0] = (dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % mod
            dp[i][0][1] = dp[i-1][0][0]
            dp[i][0][2] = dp[i-1][0][1]
        }
        var ans = 0
        for (j in 0..1) {
            for (k in 0..2) {
                ans = (ans + dp[n][j][k]) % mod
            }
        }
        return ans
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。