题目编号：361

题目：轰炸敌人

难度：中等

考察范围：动态规划

题干：给定一个二维的网格图，每个格子可能是墙壁 'W'，敌人 'E' 或者空 '0'（数字 '0'），请你计算一个最大的敌人数量，这些敌人都可以在同一行或者同一列被炸到。

你只能在一个空的格子里放置一个炸弹，用来炸掉同一行和同一列的敌人。由于这个炸弹会同时炸掉同一行和同一列的敌人，所以被炸到的敌人数量是被算作一次有效的击杀。

解题思路：动态规划

我们可以用一个二维数组 dp[i][j] 来表示在 (i,j) 这个位置可以炸掉的敌人数量。那么 dp[i][j] 的值就是在 (i,j) 这个位置可以炸掉的敌人数量，也就是在该位置向上、向下、向左、向右四个方向分别能够炸掉的敌人数量之和。

具体来说，我们可以从左到右、从上到下遍历整个网格图，对于每个位置 (i,j)，我们分别计算出从该位置向上、向下、向左、向右四个方向分别能够炸掉的敌人数量，然后将这四个方向的敌人数量相加，就得到了 dp[i][j] 的值。

具体的计算方法如下：

- 从 (i,j) 向上遍历，直到遇到墙壁 'W'，或者到达网格图的边界。在遍历的过程中，如果遇到敌人 'E'，则将计数器 count 加 1。
- 从 (i,j) 向下遍历，直到遇到墙壁 'W'，或者到达网格图的边界。在遍历的过程中，如果遇到敌人 'E'，则将计数器 count 加 1。
- 从 (i,j) 向左遍历，直到遇到墙壁 'W'，或者到达网格图的边界。在遍历的过程中，如果遇到敌人 'E'，则将计数器 count 加 1。
- 从 (i,j) 向右遍历，直到遇到墙壁 'W'，或者到达网格图的边界。在遍历的过程中，如果遇到敌人 'E'，则将计数器 count 加 1。

最终，dp[i][j] 的值就是四个方向的敌人数量之和。

解决方案：

```kotlin
class Solution {
    fun maxKilledEnemies(grid: Array<CharArray>): Int {
        val m = grid.size
        val n = grid[0].size
        val dp = Array(m) { IntArray(n) }

        // 从左到右、从上到下遍历整个网格图
        for (i in 0 until m) {
            for (j in 0 until n) {
                // 如果当前位置是墙壁，则不能放置炸弹，直接跳过
                if (grid[i][j] == 'W') {
                    continue
                }

                // 从 (i,j) 向上遍历，计算能够炸掉的敌人数量
                var count = 0
                var k = i
                while (k >= 0 && grid[k][j] != 'W') {
                    if (grid[k][j] == 'E') {
                        count++
                    }
                    k--
                }

                // 从 (i,j) 向下遍历，计算能够炸掉的敌人数量
                k = i
                while (k < m && grid[k][j] != 'W') {
                    if (grid[k][j] == 'E') {
                        count++
                    }
                    k++
                }

                // 从 (i,j) 向左遍历，计算能够炸掉的敌人数量
                k = j
                while (k >= 0 && grid[i][k] != 'W') {
                    if (grid[i][k] == 'E') {
                        count++
                    }
                    k--
                }

                // 从 (i,j) 向右遍历，计算能够炸掉的敌人数量
                k = j
                while (k < n && grid[i][k] != 'W') {
                    if (grid[i][k] == 'E') {
                        count++
                    }
                    k++
                }

                // 更新 dp[i][j] 的值
                dp[i][j] = count
            }
        }

        // 找到 dp 数组中的最大值
        var maxCount = 0
        for (i in 0 until m) {
            for (j in 0 until n) {
                if (grid[i][j] == '0' && dp[i][j] > maxCount) {
                    maxCount = dp[i][j]
                }
            }
        }

        return maxCount
    }
}
```

算法复杂度：时间复杂度为 O(mn(m+n))，空间复杂度为 O(mn)。其中，m 和 n 分别为网格图的行数和列数。