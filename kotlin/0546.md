题目编号：546

题目：移除盒子

难度：困难

考察范围：动态规划

题干：

给出一些不同颜色的盒子，每个盒子都有一个分数。你希望移除掉这些盒子，使得剩下的盒子分数之和最大。

每次你可以选择一个连续的区间，然后将区间内的所有盒子都移除掉。注意，你需要按照盒子的顺序进行移除。即如果选择了区间 [l, r]，那么在移除了该区间中的盒子之后，位置 l 和位置 r+1 处的盒子之间仍然会存在一个连接。

解题思路：

本题可以使用动态规划来解决。定义 dp[i][j][k] 表示从 i 到 j 这段区间中，连续的 k 个数字加上其平方的最大得分。

对于 dp[i][j][k]，我们可以考虑将其分为两部分：

- 移除区间 [i, j-1]，再加上 k+1 的得分，即 dp[i][j-1][0] + (k+1)^2
- 不移除区间 [i, m]，再加上移除区间 [m+1, j-1] 的得分，即 dp[i][m][k+1] + dp[m+1][j-1][0]

其中 m 表示区间 [i, j-1] 中最后一个与 j 相同的数字的位置。

因此，我们可以得到状态转移方程：

dp[i][j][k] = \max\{dp[i][j-1][0] + (k+1)^2, dp[i][m][k+1] + dp[m+1][j-1][0]\}

最终的答案即为 dp[0][n-1][0]，其中 n 表示盒子的数量。

解决方案：

```kotlin
class Solution {
    fun removeBoxes(boxes: IntArray): Int {
        val n = boxes.size
        val dp = Array(n) { Array(n) { IntArray(n) } }

        // 初始化长度为 1 的区间
        for (i in 0 until n) {
            for (k in 0 until n) {
                dp[i][i][k] = (k + 1) * (k + 1)
            }
        }

        // 枚举区间长度
        for (len in 2..n) {
            // 枚举区间起点
            for (i in 0..n-len) {
                val j = i + len - 1
                // 枚举最后一个与 j 相同的数字的位置
                for (k in 0 until n) {
                    // 移除区间 [i, j-1]
                    dp[i][j][k] = dp[i][j-1][0] + (k+1) * (k+1)
                    // 不移除区间 [i, m]，再加上移除区间 [m+1, j-1] 的得分
                    for (m in i until j) {
                        if (boxes[m] == boxes[j]) {
                            dp[i][j][k] = maxOf(dp[i][j][k], dp[i][m][k+1] + dp[m+1][j-1][0])
                        }
                    }
                }
            }
        }

        return dp[0][n-1][0]
    }
}
```

算法复杂度：O(n^4)