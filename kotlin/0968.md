题目编号：968

题目：监控二叉树

难度：困难

考察范围：二叉树、贪心算法、递归

题干：

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

解题思路：

对于每个节点，有三种状态：

0：该节点未被监控，且没有摄像头覆盖到该节点；
1：该节点已被监控，且没有摄像头覆盖到该节点；
2：该节点未被监控，但有摄像头覆盖到该节点。

对于每个节点，我们需要考虑以下几种情况：

1.该节点的左右子节点都被监控到了，那么该节点就可以被标记为状态0，因为其父节点可以通过子节点的监控来监控到该节点。

2.该节点的左右子节点中有一个节点被监控到了，那么该节点就可以被标记为状态1，因为其父节点可以通过子节点的监控来监控到该节点。

3.该节点的左右子节点都未被监控到，那么该节点就需要安装一个摄像头，来监控该节点及其子节点。因为该节点需要被监控到，所以该节点的状态应该为2。

对于根节点，我们需要特殊处理，因为其没有父节点。我们可以在根节点上安装一个摄像头，来监控整棵树。

解决方案：

```kotlin
class Solution {
    var res = 0
    fun minCameraCover(root: TreeNode?): Int {
        if (dfs(root) == 0) res++
        return res
    }

    // 返回节点的状态
    // 0：该节点未被监控，且没有摄像头覆盖到该节点；
    // 1：该节点已被监控，且没有摄像头覆盖到该节点；
    // 2：该节点未被监控，但有摄像头覆盖到该节点。
    fun dfs(node: TreeNode?): Int {
        if (node == null) return 1
        val left = dfs(node.left)
        val right = dfs(node.right)
        if (left == 0 || right == 0) {
            res++
            return 2
        }
        return if (left == 2 || right == 2) 1 else 0
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(h)，其中 n 为节点数，h 为树的高度。