题目编号：1000

题目：合并石头的最低成本

难度：困难

考察范围：动态规划、贪心算法

题干：

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

解题思路：

这是一道经典的动态规划问题，但是状态转移方程比较难想。

首先，我们可以先考虑只有两堆石头的情况，假设这两堆石头的数量分别为 a 和 b，那么它们合并的成本为 a+b。但是，如果我们再加入一堆石头 c，那么它们的合并成本就不一定是 a+b+c 了，因为我们可以先将 a 和 b 合并成一个堆，再将这个堆和 c 合并成一个堆，这样的成本为 (a+b)+c。同理，如果我们再加入一堆石头 d，那么它们的合并成本就不一定是 (a+b)+c+d 了，因为我们可以先将 a、b 和 c 合并成一个堆，再将这个堆和 d 合并成一个堆，这样的成本为 ((a+b)+c)+d。

由此可见，对于任意一堆石头，它的合并成本都可能依赖于之前合并的结果。因此，我们可以定义状态 dp[i][j] 表示将第 i 到第 j 堆石头合并成一堆的最低成本。那么，我们需要求的就是 dp[1][N]。

接下来，我们考虑如何转移状态。假设我们要将第 i 到第 j 堆石头合并成一堆，那么我们可以枚举最后一次合并的位置 k，其中 i ≤ k < j。这样，我们就可以将第 i 到第 k 堆石头合并成一堆，将第 k+1 到第 j 堆石头合并成一堆，然后将这两堆石头合并成一堆。这样的成本为 dp[i][k]+dp[k+1][j]+sum[i][j]，其中 sum[i][j] 表示第 i 到第 j 堆石头的总数。我们需要枚举所有可能的 k，然后取最小值作为 dp[i][j] 的值。

最后，我们需要注意一下边界条件。当 i=j 时，dp[i][j]=0，因为只有一堆石头不需要合并。当 j=i+1 时，dp[i][j]=sum[i][j]，因为只有两堆石头需要合并，而它们的合并成本就是它们的总数。

解决方案：

```kotlin
fun mergeStones(stones: IntArray, K: Int): Int {
    val n = stones.size
    if ((n - 1) % (K - 1) != 0) {
        return -1
    }
    val sum = IntArray(n + 1)
    for (i in 1..n) {
        sum[i] = sum[i - 1] + stones[i - 1]
    }
    val dp = Array(n + 1) { IntArray(n + 1) { Int.MAX_VALUE } }
    for (i in 1..n) {
        dp[i][i] = 0
    }
    for (len in 2..n) {
        for (i in 1..n - len + 1) {
            val j = i + len - 1
            for (k in i until j step K - 1) {
                dp[i][j] = minOf(dp[i][j], dp[i][k] + dp[k + 1][j])
            }
            if ((len - 1) % (K - 1) == 0) {
                dp[i][j] += sum[j] - sum[i - 1]
            }
        }
    }
    return dp[1][n]
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。