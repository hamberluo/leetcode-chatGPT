题目编号：437

题目：路径总和 III

难度：中等

考察范围：二叉树、递归

题干：给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 

解题思路：对于每个节点，都可以以它为起点，向下遍历整个树，找到所有路径和等于给定数值的路径。因此，可以使用递归的方式，对于每个节点，都进行一次递归，分别计算以该节点为起点的路径数目。具体实现时，可以使用一个辅助函数，该函数的作用是计算以当前节点为起点的路径数目。在该函数中，首先判断当前节点是否为空，如果为空，则返回 0；否则，计算以当前节点为起点的路径数目，具体实现如下：

1. 首先，计算以当前节点为起点的路径数目，该路径必须包含当前节点，因此，可以将当前节点的值从目标值中减去，然后递归计算以当前节点的左右子节点为起点的路径数目，将两个结果相加即可。

2. 其次，计算不包含当前节点的路径数目，该路径可以从当前节点的左右子节点开始，因此，可以递归计算以当前节点的左右子节点为起点的路径数目，将两个结果相加即可。

3. 最后，将以上两个结果相加，即为以当前节点为起点的路径数目。

解决方案：

```kotlin
class Solution {
    fun pathSum(root: TreeNode?, sum: Int): Int {
        if (root == null) {
            return 0
        }
        return pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum)
    }

    private fun pathSumFrom(node: TreeNode?, sum: Int): Int {
        if (node == null) {
            return 0
        }
        var count = 0
        if (node.`val` == sum) {
            count++
        }
        count += pathSumFrom(node.left, sum - node.`val`) + pathSumFrom(node.right, sum - node.`val`)
        return count
    }
}
```

算法复杂度：时间复杂度为 O(n^2)，其中 n 为二叉树中节点的个数，因为对于每个节点，都需要递归计算以该节点为起点的路径数目，因此总的时间复杂度为 O(n^2)；空间复杂度为 O(n)，其中 n 为二叉树中节点的个数，因为递归的深度最多为 n，因此总的空间复杂度为 O(n)。