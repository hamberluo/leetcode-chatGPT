题目编号：386

题目：字典序排数

难度：中等

考察范围：递归、深度优先搜索

题干：给定一个整数 n, 返回从 1 到 n 的字典顺序。

例如，给定 n = 13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9]。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。

解题思路：本题可以使用递归或深度优先搜索来解决。我们可以将数字看做一棵树，每个节点表示一个数字，每个节点的子节点表示在该节点后面加上一个数字所得到的数字。例如，节点 1 的子节点为 10、11、12、...、19。我们可以先将 1 到 9 加入结果列表中，然后递归遍历每个节点的子节点，将子节点加入结果列表中，直到遍历完所有节点。

解决方案：

```kotlin
class Solution {
    fun lexicalOrder(n: Int): List<Int> {
        val res = mutableListOf<Int>()
        // 递归遍历每个节点
        fun dfs(cur: Int) {
            if (cur > n) return
            res.add(cur)
            dfs(cur * 10) // 遍历当前节点的子节点
            if (cur % 10 < 9) dfs(cur + 1) // 遍历当前节点的兄弟节点
        }
        // 遍历 1 到 9 的节点
        for (i in 1..9) {
            dfs(i)
        }
        return res
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(log n)。