题目编号：799

题目：香槟塔

难度：中等

考察范围：动态规划

题干：我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，依此类推。（如果最底层的玻璃杯满了，就会将多余的香槟流出去）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放了一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯：顶层的一个和第二层的两个，但第二层的两个玻璃杯平分了一杯香槟。在倒第四杯香槟后，第二层的左右两边的玻璃杯均满了，总共有四个满的玻璃杯，第三层的中间玻璃杯盛放了一半的香槟。

给定一个非负整数 poured 表示你最开始拥有的香槟总量，返回一个数组表示香槟塔最底层所有玻璃杯盛放的香槟量，精确到小数点后2位。

解题思路：动态规划

首先，我们可以将香槟塔看成一个二维数组，第 i 行第 j 列表示第 i 层第 j 个杯子中的香槟量。由于每个杯子最多只能盛放 250ml 的香槟，因此我们可以将数组大小设置为 101 * 101，其中第 i 行有 i 个元素。

接下来，我们考虑如何模拟倾倒香槟的过程。我们可以从第 1 行第 1 列开始，依次向下遍历每个杯子。对于第 i 行第 j 列的杯子，如果它的香槟量超过了 250ml，那么它会向左右两个杯子均匀地流出一半的香槟，即第 i+1 行第 j 列和第 i+1 行第 j+1 列的杯子中各增加原来香槟量的一半。注意，如果第 i+1 行第 j 列或第 i+1 行第 j+1 列的杯子已经满了，那么它们不会再接收到更多的香槟。

最后，我们只需要返回最后一行所有杯子中的香槟量即可。

解决方案：

```kotlin
class Solution {
    fun champagneTower(poured: Int, query_row: Int, query_glass: Int): Double {
        val dp = Array(101) { DoubleArray(101) }
        dp[0][0] = poured.toDouble()
        for (i in 0 until 100) {
            for (j in 0..i) {
                if (dp[i][j] > 1) {
                    val flow = (dp[i][j] - 1) / 2
                    dp[i + 1][j] += flow
                    dp[i + 1][j + 1] += flow
                    dp[i][j] = 1.0
                }
            }
        }
        return dp[query_row][query_glass]
    }
}
```

算法复杂度：时间复杂度为 O(100^2)，空间复杂度为 O(100^2)。