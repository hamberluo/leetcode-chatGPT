题目编号：233

题目：数字 1 的个数

难度：困难

考察范围：数学、位运算

题干：给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

示例 1：

输入：n = 13
输出：6

示例 2：

输入：n = 0
输出：0

提示：

0 <= n <= 2 * 10^9

解题思路：本题可以使用数学方法或者位运算方法来解决。

数学方法：

我们可以将数字 1 出现的个数拆分成每个数位上 1 的个数之和，例如对于数字 12345，它的个位上数字 1 出现的次数为 1234 次，十位上数字 1 出现的次数为 1240 次，百位上数字 1 出现的次数为 1300 次，千位上数字 1 出现的次数为 2000 次，万位上数字 1 出现的次数为 10000 次，因此总共出现的次数为 1+4+3+2+1=11 次。

对于一个数位上的数字，我们可以将其分为三类：

1. 当前数位上的数字为 0，例如对于数字 12345，百位上的数字为 0。

此时当前数位上数字 1 的个数为 0。

2. 当前数位上的数字为 1，例如对于数字 12345，千位上的数字为 1。

此时当前数位上数字 1 的个数为当前数位之前的数字（高位数字）乘以当前数位的权重（例如千位的权重为 1000），再加上当前数位之后的数字（低位数字）加 1。

3. 当前数位上的数字大于 1，例如对于数字 12345，万位上的数字为 5。

此时当前数位上数字 1 的个数为（当前数位之前的数字加 1）乘以当前数位的权重。

位运算方法：

我们可以将数字 n 拆分成每个数位上的数字，例如对于数字 12345，我们可以拆分成 1、2、3、4、5 这 5 个数字。

对于每个数位上的数字，我们可以计算出它对最终结果的贡献，例如对于数字 12345，个位上的数字为 5，它对最终结果的贡献为 1，因为它可以和 1、11、21、31、41 这 5 个数字组成以 1 结尾的数字，十位上的数字为 4，它对最终结果的贡献为 10，因为它可以和 10~19、110~119、210~219、310~319、410~419 这 50 个数字组成以 1 结尾的数字，百位上的数字为 3，它对最终结果的贡献为 100，因为它可以和 100~199、1100~1199、2100~2199、3100~3199、4100~4199 这 500 个数字组成以 1 结尾的数字，以此类推。

我们可以使用位运算来计算每个数位上的数字对最终结果的贡献，具体来说，对于第 i 个数位上的数字，我们可以计算出它对最终结果的贡献为：

1. 如果当前数位上的数字为 0，则贡献为 0。

2. 如果当前数位上的数字为 1，则贡献为 i 之前的数字（高位数字）加上 1，再加上 i 之后的数字（低位数字）加 1。

3. 如果当前数位上的数字大于 1，则贡献为（i 之前的数字加 1）乘以 10^(i-1)。

最终将每个数位上的数字对最终结果的贡献相加即可得到最终结果。

解决方案：

数学方法：

```kotlin
class Solution {
    fun countDigitOne(n: Int): Int {
        var count = 0
        var i = 1
        while (i <= n) {
            val high = n / (i * 10)
            val cur = n / i % 10
            val low = n % i
            if (cur == 0) {
                count += high * i
            } else if (cur == 1) {
                count += high * i + low + 1
            } else {
                count += (high + 1) * i
            }
            i *= 10
        }
        return count
    }
}
```

位运算方法：

```kotlin
class Solution {
    fun countDigitOne(n: Int): Int {
        var count = 0
        var i = 1
        var high = n / 10
        var cur = n % 10
        var low = 0
        while (high != 0 || cur != 0) {
            if (cur == 0) {
                count += high * i
            } else if (cur == 1) {
                count += high * i + low + 1
            } else {
                count += (high + 1) * i
            }
            low += cur * i
            cur = high % 10
            high /= 10
            i *= 10
        }
        return count
    }
}
```

算法复杂度：时间复杂度为 O(log n)，空间复杂度为 O(1)。