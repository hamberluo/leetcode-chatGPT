题目编号：837

题目：新21点

难度：中等

考察范围：动态规划

题干：爱丽丝参与一个大致基于纸牌游戏 “21 点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

解题思路：动态规划

我们可以用 dp[x] 表示从得分为 x 的情况开始游戏并且获胜的概率，目标是求 dp[0] 的值。

根据规则，当分数达到或超过 K 时游戏结束，如果分数不超过 N，我们就获胜了，否则就输了。因此，我们可以得到如下的转移方程：

dp[x] = (dp[x+1] + dp[x+2] + ... + dp[x+W]) / W

这是一个非常标准的动态规划转移方程，含义是当前状态下，我们可以选择抽取 1 到 W 中的任意一个数字，下一步到达 x+1, x+2, ..., x+W 中的一个，而到达这些状态的概率相等，都是 1/W。

然而直接计算这个转移方程的时间复杂度是 O(NW)，无法通过本题。注意到转移方程中的 dp[x+1], dp[x+2], ..., dp[x+W] 实际上是 dp[x] 的“后继”（即可以由 dp[x] 转移而来的状态），因此我们可以使用一个变量 s 表示后继状态的概率之和，即

s = dp[x+1] + dp[x+2] + ... + dp[x+W]

这样转移方程就可以写成

dp[x] = s / W

同时我们可以得到

dp[x-1] = (s - dp[x+W]) / W

这样，我们就可以使用滑动窗口来优化时间复杂度了。具体来说，我们维护一个长度为 W 的滑动窗口，其中的元素为 dp[x], dp[x+1], ..., dp[x+W-1]。每次我们需要计算 dp[x] 时，只需要把窗口中的元素相加，然后除以 W 即可；然后我们把 dp[x] 加入窗口，把 dp[x+W] 从窗口中移除即可。

解决方案：动态规划

```kotlin
class Solution {
    fun new21Game(N: Int, K: Int, W: Int): Double {
        val dp = DoubleArray(N + W + 1)
        var s = 0.0
        for (i in K..N) {
            dp[i] = 1.0
            s += dp[i]
        }
        for (i in K - 1 downTo 0) {
            dp[i] = s / W
            s += dp[i] - dp[i + W]
        }
        return dp[0]
    }
}
```

算法复杂度：时间复杂度 O(N+W)，空间复杂度 O(N+W)。