题目编号：740

题目：删除与获得点数

难度：中等

考察范围：动态规划

题干：

给定一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1:

输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。

示例 2:

输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 获得 3 个点数，接着要删除两个 2 和一个 4。
之后，删除 3 获得 3 个点数，接着要删除两个 3。
总共获得 9 个点数。

注意:

nums的长度最大为20000。
每个整数nums[i]的大小都在[1, 10000]范围内。

解题思路：

本题可以使用动态规划来解决。

首先，我们需要统计每个数字出现的次数，然后对于每个数字，我们可以选择删除它或者不删除它。

如果我们选择删除它，那么我们就需要删除所有等于 nums[i] - 1 和 nums[i] + 1 的元素，这样可以保证不会出现连续的数字。

如果我们选择不删除它，那么我们就需要跳过这个数字，继续考虑下一个数字。

我们可以使用两个数组 dp1 和 dp2 来分别表示选择删除和不删除当前数字时的最大点数。

对于 dp1[i]，我们可以选择删除 nums[i]，此时我们可以获得 nums[i] 的点数，然后需要删除所有等于 nums[i] - 1 和 nums[i] + 1 的元素，这样可以保证不会出现连续的数字。因此，dp1[i] = dp2[i-1] + nums[i] * count[i]。

对于 dp2[i]，我们可以选择不删除 nums[i]，此时我们需要跳过 nums[i]，继续考虑下一个数字。因此，dp2[i] = max(dp1[i-1], dp2[i-1])。

最终的答案就是 max(dp1[n-1], dp2[n-1])，其中 n 是数组的长度。

解决方案：

```kotlin
class Solution {
    fun deleteAndEarn(nums: IntArray): Int {
        val count = IntArray(10001)
        for (num in nums) {
            count[num]++
        }
        var dp1 = 0
        var dp2 = 0
        for (i in 1..10000) {
            val tmp = dp1
            dp1 = dp2 + i * count[i]
            dp2 = maxOf(dp2, tmp)
        }
        return maxOf(dp1, dp2)
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。