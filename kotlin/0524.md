题目编号：524

题目：通过删除字母匹配到字典里最长单词

难度：中等

考察范围：字符串、排序、双指针

题干：

给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果没有，则返回空字符串。

示例 1:

输入:
s = "abpclefg"
d = ["ale","apple","monkey","plea"]

输出: 
"apple"

示例 2:

输入:
s = "abpclefg"
d = ["a","b","c"]

输出: 
"a"

解题思路：

首先，我们需要对字典中的字符串按照长度和字典序进行排序，这样可以方便后面的匹配。

然后，我们遍历字典中的每个字符串，判断该字符串是否可以通过删除给定字符串的某些字符来得到。具体来说，我们可以使用双指针的方法，分别从给定字符串和字典中的字符串的开头开始遍历，如果两个字符相等，则两个指针都向后移动一位，否则只移动给定字符串的指针。如果字典中的字符串的指针移动到了末尾，则说明该字符串可以通过删除给定字符串的某些字符来得到。

最后，我们找到最长的可以通过删除给定字符串的某些字符来得到的字符串，并返回该字符串。

解决方案：

```kotlin
class Solution {
    fun findLongestWord(s: String, d: List<String>): String {
        // 对字典中的字符串按照长度和字典序进行排序
        val sortedDict = d.sortedWith(compareBy({ -it.length }, { it }))

        // 遍历字典中的每个字符串，判断该字符串是否可以通过删除给定字符串的某些字符来得到
        for (word in sortedDict) {
            var i = 0
            var j = 0
            while (i < s.length && j < word.length) {
                if (s[i] == word[j]) {
                    j++
                }
                i++
            }
            if (j == word.length) {
                return word
            }
        }

        return ""
    }
}
```

算法复杂度：时间复杂度为 O(n * m)，其中 n 是给定字符串的长度，m 是字典中字符串的总长度。空间复杂度为 O(1)。