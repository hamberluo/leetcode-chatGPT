题目编号：955

题目：删列造序 II

难度：中等

考察范围：贪心算法、字符串处理

题干：

给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。

选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。

比如，有 A = ["abcdef", "uvwxyz"]，删除索引序列 {0, 2, 3}，删除后 A 为["bef", "vyz"]。

假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组需要满足以下条件：

1. A 的每个元素都是按字典序排列的非降序排列的，即对于任意的 i 和 j（0 <= i < j < A.length），A[i] <= A[j]。

2. 如果有多个元素下标有所不同，那么在最终的数组中，这些元素的顺序应该与在 A 中出现的顺序相同。

给定一个初始数组 A，求出满足条件的删除索引 D 的最小可能长度。

解题思路：

对于每个字符串，我们需要判断其是否需要删除。如果需要删除，那么我们就需要考虑删除后的字符串是否满足条件。

对于两个字符串 s_1 和 s_2，如果 s_1[i] > s_2[i]，那么在删除索引 i 后，s_1 会排在 s_2 的后面。因此，如果存在两个字符串 s_1 和 s_2，使得 s_1[i] > s_2[i]，那么我们就不能删除索引 i。

如果不存在这样的两个字符串，那么我们就可以删除索引 i。删除后，我们需要继续判断下一个索引是否需要删除。

解决方案：

```cpp
class Solution {
public:
    int minDeletionSize(vector<string>& A) {
        int n = A.size();
        int m = A[0].size();
        int ans = 0;
        vector<bool> sorted(n, false);
        for (int j = 0; j < m; j++) {
            bool flag = true;
            for (int i = 1; i < n; i++) {
                if (!sorted[i] && A[i][j] < A[i - 1][j]) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                for (int i = 1; i < n; i++) {
                    if (A[i][j] > A[i - 1][j]) {
                        sorted[i] = true;
                    }
                }
            } else {
                ans++;
            }
        }
        return ans;
    }
};
```

算法复杂度：O(nm)，其中 n 是字符串的数量，m 是字符串的长度。