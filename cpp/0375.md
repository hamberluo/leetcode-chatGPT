题目编号：375

题目：猜数字大小 II

难度：中等

考察范围：动态规划

题干：

我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，才算游戏结束。

例如，n = 10，我选择了8。

你猜 5，我告诉你，我选的数字比你的小了，你支付现金5元。

你猜 7，我告诉你，我选的数字比你的小了，你支付现金7元。

你猜 9，我告诉你，我选的数字比你的大了，你支付现金9元。

你猜 8，我告诉你，恭喜你，你猜对了！

总共你需要支付 5 + 7 + 9 = 21 元现金。

给定 n，你需要返回你最少需要支付多少现金才能保证猜到我选的数字。

解题思路：

这是一道典型的动态规划问题。

我们可以定义 dp[i][j] 表示在区间 [i,j] 中猜出任意一个数的最小花费。

对于 dp[i][j]，我们可以枚举区间内的每一个数 k，然后计算在 k 的左边和右边分别猜的最小花费，最后取两者的最大值加上 k 的花费，即为 dp[i][j] 的值。

具体而言，我们可以写出如下的状态转移方程：

dp[i][j] = min(dp[i][j], k + max(dp[i][k-1], dp[k+1][j]))

其中，k 的范围是 [i,j]。

最终的答案即为 dp[1][n]。

解决方案：

```cpp
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+1, vector<int>(n+1, INT_MAX));
        for (int i = 1; i <= n; i++) {
            dp[i][i] = 0;
        }
        for (int len = 2; len <= n; len++) {
            for (int i = 1; i <= n-len+1; i++) {
                int j = i + len - 1;
                for (int k = i; k <= j; k++) {
                    dp[i][j] = min(dp[i][j], k + max((k > i ? dp[i][k-1] : 0), (k < j ? dp[k+1][j] : 0)));
                }
            }
        }
        return dp[1][n];
    }
};
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。