题目编号：289

题目：生命游戏

难度：中等

考察范围：数组、模拟

题干：

根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个由 0 和 1 组成的二维网格，其中 0 表示死亡，1 表示生存。每个单元格都与其八个相邻位置（水平，垂直，对角线）中的单元格形成关系。按照以下规则更新网格：

- 任何活着的单元格，如果周围八个位置中有两个或三个单元格为活着的，则继续活着。
- 任何活着的单元格，如果周围八个位置中有超过三个单元格为活着的，则死亡。
- 任何死亡的单元格，如果周围八个位置中恰好有三个单元格为活着的，则变成活着的状态。

下图展示了生命游戏的一种可能情况。

![image.png](https://pic.leetcode-cn.com/1629974216-WhzJZJ-image.png)

解题思路：

本题是一道模拟题，需要按照题目中的规则模拟每个细胞的状态变化。由于题目要求原地修改，因此需要使用额外的状态来记录细胞的下一个状态。

具体思路如下：

- 遍历整个二维网格，对于每个细胞，统计其周围八个位置中活着的细胞数量。
- 根据规则更新每个细胞的状态，将其存储到额外的状态数组中。
- 将额外的状态数组复制回原数组中。

解决方案：

```cpp
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        vector<vector<int>> next(m, vector<int>(n, 0)); // 存储下一个状态
        int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
        int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int cnt = 0; // 统计周围活细胞数量
                for (int k = 0; k < 8; k++) {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 1) {
                        cnt++;
                    }
                }
                if (board[i][j] == 1) { // 当前细胞为活细胞
                    if (cnt == 2 || cnt == 3) {
                        next[i][j] = 1; // 继续活着
                    }
                } else { // 当前细胞为死细胞
                    if (cnt == 3) {
                        next[i][j] = 1; // 变成活细胞
                    }
                }
            }
        }
        board = next; // 复制回原数组
    }
};
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。