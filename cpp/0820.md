题目编号：820

题目：单词的压缩编码

难度：中等

考察范围：字符串、哈希表

题干：

给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。

例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。

对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？

解题思路：

题目要求我们将单词列表编码成一个索引字符串 S 和一个索引列表 A，使得通过索引列表 A 可以恢复出原来的单词列表，并且 S 的长度最小。

我们可以将单词列表中的每个单词反转，然后按照字典序排序。这样，如果一个单词是另一个单词的后缀，那么它一定会排在前面。例如，"me" 和 "time" 反转后变成 "em" 和 "emit"，它们按照字典序排序后是 "em" 和 "emit"，"em" 排在前面，说明 "me" 是 "time" 的后缀。

接下来，我们遍历排序后的单词列表，对于每个单词，我们判断它是否是前一个单词的后缀。如果是，我们就不需要将它加入到索引字符串 S 中，因为它已经被前一个单词包含了。如果不是，我们就需要将它加入到索引字符串 S 中，并更新索引列表 A。

最后，我们将索引字符串 S 的长度加上索引列表 A 的长度，就是最终的结果。

解决方案：

```cpp
class Solution {
public:
    int minimumLengthEncoding(vector<string>& words) {
        int n = words.size();
        for (int i = 0; i < n; i++) {
            reverse(words[i].begin(), words[i].end()); // 反转单词
        }
        sort(words.begin(), words.end()); // 按照字典序排序
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (i + 1 < n && words[i + 1].find(words[i]) == 0) { // 判断是否是前一个单词的后缀
                continue;
            }
            res += words[i].size() + 1; // 将单词加入索引字符串 S 中
        }
        return res;
    }
};
```

算法复杂度：排序的时间复杂度为 O(nlogn)，遍历单词列表的时间复杂度为 O(n)，因此总时间复杂度为 O(nlogn)。空间复杂度为 O(n)，用于存储反转后的单词。