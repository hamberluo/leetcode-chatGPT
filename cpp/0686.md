题目编号：686

题目：重复叠加字符串匹配

难度：简单

考察范围：字符串、双指针

题干：给定两个字符串 A 和 B，寻找重复叠加字符串 A 的最小次数，使得 B 成为叠加后的字符串的子串，如果不存在则返回 -1。

解题思路：双指针

首先，我们可以将 A 不断叠加，直到长度大于等于 B 的长度，然后再判断 B 是否是 A 的子串。如果是，直接返回叠加次数；否则，再将 A 叠加一次，再判断 B 是否是 A 的子串，以此类推，直到 A 的长度大于等于 2B 或者 B 不是 A 的子串为止。

在判断子串时，可以使用双指针的方法，即用两个指针 i 和 j 分别指向 A 和 B 的开头，然后比较 A[i] 和 B[j] 是否相等，如果相等，则 i 和 j 同时向后移动一位，否则 i 回到上一次匹配的位置的下一位，j 回到 B 的开头。

解决方案：

```cpp
class Solution {
public:
    int repeatedStringMatch(string A, string B) {
        int n1 = A.size(), n2 = B.size();
        int cnt = n2 / n1 + 2; // 最多需要叠加的次数
        string s = A;
        for (int i = 1; i < cnt; i++) {
            s += A;
            if (s.find(B) != string::npos) { // 判断 B 是否是 s 的子串
                return i + 1;
            }
        }
        return -1;
    }
};
```

算法复杂度：时间复杂度为 O(n1 * (n2 + n1))，空间复杂度为 O(n1 + n2)。其中，n1 和 n2 分别为字符串 A 和 B 的长度。