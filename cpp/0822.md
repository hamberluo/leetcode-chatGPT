题目编号：822

题目：翻转卡片游戏

难度：中等

考察范围：数组、模拟

题干：在桌子上有一堆牌，每张牌上都写着一个整数。此外，还有两个可以交替执行的操作：

1.取出桌子上任意一张牌，将牌翻过来，如果牌的正面朝上，就将牌上的数字加倍，如果牌的反面朝上，就将牌上的数字变为负数。

2.如果桌子上任意两张牌的数字之和能够被 K 整除，就可以将它们一起收起来。

你能否找到收起所有牌的最小点数和？

解题思路：模拟

首先，我们可以发现，如果两张牌的数字之和能够被 K 整除，那么它们的余数之和也能够被 K 整除。因此，我们可以先计算出所有牌的余数，并统计每个余数的数量。

接下来，我们可以模拟翻牌的过程。对于每张牌，我们可以分别计算它正面朝上和反面朝上时的点数，并取其中较小的一个。如果这张牌正面朝上，我们就将它的余数数量减一，并将它的点数加入答案中；如果这张牌反面朝上，我们就将它的余数数量减一，并将它的点数取相反数后加入答案中。

最后，我们可以检查是否还有余数数量不为零的牌。如果有，说明无法收起所有牌，返回 -1；否则，返回答案。

解决方案：

```cpp
class Solution {
public:
    int flipgame(vector<int>& fronts, vector<int>& backs) {
        int n = fronts.size();
        vector<int> cnt(2001);
        for (int i = 0; i < n; i++) {
            if (fronts[i] == backs[i]) {
                cnt[fronts[i]]++;
            } else {
                cnt[fronts[i]]++;
                cnt[backs[i]]++;
            }
        }
        int ans = INT_MAX;
        for (int i = 0; i < n; i++) {
            if (cnt[fronts[i]] == 1) {
                ans = min(ans, fronts[i]);
            }
            if (cnt[backs[i]] == 1) {
                ans = min(ans, backs[i]);
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。