题目编号：85

题目：最大矩形

难度：困难

考察范围：栈、动态规划

题干：给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

解题思路：本题可以使用栈或者动态规划来解决。

栈的解法：对于每一行，我们可以将其看作是一个直方图，每个位置的高度为从该位置向上连续的 1 的个数。然后对于每一行，我们都可以求出其对应的直方图，然后利用单调栈来求解最大矩形面积。具体来说，我们维护一个单调递增的栈，栈中存储的是直方图中每个位置的下标。对于每个位置，我们将其与栈顶元素比较，如果当前位置的高度小于等于栈顶元素的高度，则将栈顶元素弹出，并计算以该位置为右边界，栈顶元素为左边界的最大矩形面积。如果当前位置的高度大于栈顶元素的高度，则将其入栈。最后，我们需要在栈中加入一个高度为 0 的哨兵，以便于计算最后一个位置的最大矩形面积。

动态规划的解法：我们可以将每一行看作是一个直方图，然后利用动态规划来求解最大矩形面积。具体来说，我们定义一个二维数组 dp，其中 dp[i][j] 表示以第 i 行第 j 列为底部的最大矩形面积。对于每个位置，我们可以将其看作是一个直方图中的一个柱子，其高度为从该位置向上连续的 1 的个数。然后我们可以利用动态规划的思想，从上往下依次计算每个位置的最大矩形面积。具体来说，对于每个位置，我们可以将其看作是一个矩形的右下角，然后我们需要向上扩展该矩形，直到其不能再向上扩展为止。具体来说，我们可以定义一个变量 height，表示当前位置向上连续的 1 的个数，然后我们从当前位置向上遍历，每遍历到一个位置，就将 height 加 1，然后计算以该位置为底部，高度为 height 的最大矩形面积。最后，我们需要在第一行加入一个高度为 0 的哨兵，以便于计算第一行的最大矩形面积。

解决方案：栈的解法

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size();
        vector<int> heights(n + 1, 0);
        int ans = 0;
        for (int i = 0; i < m; i++) {
            stack<int> stk;
            for (int j = 0; j <= n; j++) {
                if (j < n) {
                    if (matrix[i][j] == '1') {
                        heights[j]++;
                    } else {
                        heights[j] = 0;
                    }
                }
                while (!stk.empty() && heights[j] < heights[stk.top()]) {
                    int h = heights[stk.top()];
                    stk.pop();
                    int w = stk.empty() ? j : j - stk.top() - 1;
                    ans = max(ans, h * w);
                }
                stk.push(j);
            }
        }
        return ans;
    }
};
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(n)。