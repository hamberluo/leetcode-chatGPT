题目编号：552

题目：学生出勤记录 II

难度：困难

考察范围：动态规划

题干：

给定一个正整数 n，表示学生的出勤记录表的长度。出勤记录表是一个字符串，记录了学生的出勤情况，其中第 i 个字符表示第 i 天的出勤情况（缺席记为 'A'，迟到记为 'L'，到场记为 'P'）。

同时给定整数 k，表示学生最多缺席 k 天，且最多连续迟到不超过 2 天。

你需要根据这个学生的出勤记录表判断他是否能够获得出勤奖励。

示例 1:

输入: n = 2, k = 1
输出: 3
解释: 以下是学生的出勤记录:
1. 出勤
2. 缺席
如果学生缺席第二天，就会不达标，所以返回 3。

示例 2:

输入: n = 2, k = 0
输出: 4
解释: 以下是学生的出勤记录:
1. 出勤
2. 出勤
因为不会受到缺席的惩罚，所以可以获得出勤奖励。

解题思路：

本题可以使用动态规划来解决。

定义 dp[i][j][k] 表示前 i 天，缺席了 j 天，结尾连续迟到了 k 天的方案数。

对于第 i 天，有三种情况：

1. 出勤：dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]
2. 缺席：dp[i][j+1][0] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]
3. 迟到：dp[i][j][k+1] = dp[i-1][j][k] (k < 2)

最终的答案为所有 dp[n][j][k] 的和，其中 0 <= j <= k <= 2。

解决方案：

```cpp
class Solution {
public:
    int checkRecord(int n) {
        int mod = 1e9 + 7;
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(3, vector<int>(3)));
        dp[0][0][0] = 1;
        for (int i = 1; i <= n; i++) {
            // 出勤
            for (int j = 0; j <= 2; j++) {
                for (int k = 0; k <= 2; k++) {
                    dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % mod;
                }
            }
            // 缺席
            for (int j = 0; j <= 1; j++) {
                for (int k = 0; k <= 2; k++) {
                    dp[i][j+1][0] = (dp[i][j+1][0] + dp[i-1][j][k]) % mod;
                }
            }
            // 迟到
            for (int j = 0; j <= 2; j++) {
                for (int k = 0; k <= 1; k++) {
                    dp[i][j][k+1] = (dp[i][j][k+1] + dp[i-1][j][k]) % mod;
                }
            }
        }
        int ans = 0;
        for (int j = 0; j <= 2; j++) {
            for (int k = 0; k <= 2; k++) {
                ans = (ans + dp[n][j][k]) % mod;
            }
        }
        return ans;
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。