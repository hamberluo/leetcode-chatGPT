题目编号：403

题目：青蛙过河

难度：中等

考察范围：动态规划、二进制

题干：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。给定石子的位置列表（用单元格序号升序表示），请判定青蛙是否能够成功过河（即能否在最后一步跳至最后一个石子上）。开始时，青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2）。

解题思路：动态规划

我们可以用一个二维数组 dp[i][j] 表示青蛙能否跳到第 i 个石子，并且最后一步跳了 j 个单位。其中，j 的取值范围为 [0, i-1]，因为最后一步跳的距离不可能超过当前所在的石子编号。

对于 dp[i][j]，我们需要考虑两种情况：

1. 青蛙能否从前面的某个石子跳到当前石子 i，跳跃距离为 j。即 dp[i-j][j] 是否为 true。

2. 青蛙能否从前面的某个石子跳到当前石子 i，跳跃距离为 j-1 或 j+1。即 dp[i-j-1][j-1] 或 dp[i-j+1][j+1] 是否为 true。

如果上述两种情况中有一种为 true，则 dp[i][j] 也为 true。

最终，我们只需要判断 dp[n-1][j] 是否为 true，其中 n 为石子的数量，j 的取值范围为 [0, n-2]，因为最后一步跳的距离不可能超过当前所在的石子编号。

解决方案：

```cpp
class Solution {
public:
    bool canCross(vector<int>& stones) {
        int n = stones.size();
        vector<vector<bool>> dp(n, vector<bool>(n));
        dp[0][0] = true;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int k = stones[i] - stones[j];
                if (k <= j + 1) {
                    dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1];
                    if (i == n-1 && dp[i][k]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。