题目编号：330

题目：按要求补齐数组

难度：困难

考察范围：贪心算法

题干：

给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

解题思路：

首先，我们需要明确一个结论：如果区间 [1, x-1] 内的所有数字都已经被覆盖，且 x 在数组中，则区间 [1, 2x-1] 内的所有数字也都被覆盖。

假设区间 [1, x-1] 内的所有数字都已经被覆盖，且 x 在数组中，对于任意 1 <= y < x，y 已经被覆盖，x 可以加上 y 得到 x+y，因此区间 [x, 2x-1] 内的所有数字都被覆盖，证毕。

基于上述结论，我们可以在给定数组的情况下，贪心地向其中添加数字，每次添加的数字为当前无法表示的最小正整数，直到区间 [1, n] 内的所有数字都被覆盖。

具体实现时，用 miss 表示当前缺失的最小正整数，即区间 [1, miss) 内的所有数字都已经被覆盖。初始时，miss = 1，即缺失的是 1。对于数组中的每个数字 x，有三种情况：

1. x <= miss，此时将 miss 增加 x，表示区间 [1, miss) 内的所有数字都被覆盖了。

2. x > miss，此时需要向数组中添加一个数，为了能够覆盖 miss，添加的数为 miss 本身，此时 miss 增加到 2*miss，表示区间 [1, 2*miss) 内的所有数字都被覆盖了。

3. miss > n，此时区间 [1, n] 内的所有数字都被覆盖了，可以直接返回添加的数字个数。

解决方案：

```cpp
class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        long long miss = 1; // 当前缺失的最小正整数
        int i = 0, patches = 0;
        while (miss <= n) {
            if (i < nums.size() && nums[i] <= miss) {
                miss += nums[i++]; // 能够覆盖的区间扩大到 [1, miss+nums[i]-1]
            } else {
                miss += miss; // 添加 miss，能够覆盖的区间扩大到 [1, 2*miss-1]
                patches++;
            }
        }
        return patches;
    }
};
```

算法复杂度：时间复杂度为 O(logn)，空间复杂度为 O(1)。