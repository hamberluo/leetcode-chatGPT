题目编号：276

题目：栅栏涂色

难度：中等

考察范围：动态规划

题干：有一个栅栏，它有 n 个柱子，每个柱子可以被涂成 k 种颜色中的一种。你需要给所有柱子涂上颜色，且相邻的柱子不能涂成相同的颜色。你需要计算出涂色方案总数。

解题思路：动态规划

对于第 i 个柱子，它可以涂成 k 种颜色中的一种，那么它的涂色方案数为 k。对于第 i+1 个柱子，它可以涂成 k 种颜色中的一种，但是它的涂色方案数与第 i 个柱子的颜色有关。如果第 i+1 个柱子的颜色与第 i 个柱子的颜色相同，那么第 i+2 个柱子就不能涂成第 i+1 个柱子的颜色，此时第 i+1 个柱子的涂色方案数为 k-1；如果第 i+1 个柱子的颜色与第 i 个柱子的颜色不同，那么第 i+1 个柱子的涂色方案数为 k-1。因此，我们可以得到状态转移方程：

dp[i][0] = k
dp[i][1] = (k-1) * (dp[i-1][0] + dp[i-1][1])
dp[i][2] = dp[i-1][1] * (k-1)

其中，dp[i][0] 表示第 i 个柱子涂成任意一种颜色的方案数，dp[i][1] 表示第 i 个柱子涂成与第 i-1 个柱子颜色不同的方案数，dp[i][2] 表示第 i 个柱子涂成与第 i-1 个柱子颜色相同但与第 i-2 个柱子颜色不同的方案数。

最终的答案为 dp[n-1][0] + dp[n-1][1]。

解决方案：

```cpp
class Solution {
public:
    int numWays(int n, int k) {
        if (n == 0) return 0;
        if (n == 1) return k;
        int dp[n][3];
        dp[0][0] = k;
        dp[0][1] = k * (k-1);
        dp[0][2] = 0;
        for (int i = 1; i < n; i++) {
            dp[i][0] = dp[i-1][1] + dp[i-1][2];
            dp[i][1] = (k-1) * (dp[i-1][0] + dp[i-1][2]);
            dp[i][2] = dp[i-1][1];
        }
        return dp[n-1][0] + dp[n-1][1] + dp[n-1][2];
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。