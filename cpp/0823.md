题目编号：823

题目：带因子的二叉树

难度：中等

考察范围：动态规划、树

题干：

给出一个含有不重复整数元素的数组，每个整数均大于 1。

我们用这些整数来构建二叉树，每个整数可以使用任意次数。

其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？返回的结果应对 10^9 + 7 取余。

示例 1:

输入: A = [2, 4]
输出: 3
解释: 我们可以得到这些二叉树: [2], [4], [4, 2, 2]

示例 2:

输入: A = [2, 4, 5, 10]
输出: 7
解释: 我们可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].

提示:

1 <= A.length <= 1000.
2 <= A[i] <= 10 ^ 9.

解题思路：

本题可以使用动态规划来解决。

首先，我们需要对数组进行排序，这样可以保证后面的数一定是前面数的因子。

然后，我们定义一个 dp 数组，dp[i] 表示以 A[i] 为根节点的二叉树的数量。

对于每个 A[i]，我们需要找到它的因子 A[j]，并且 A[j] 必须在 A[i] 的左子树中，A[i]/A[j] 必须在 A[i] 的右子树中。

因此，我们可以枚举 A[i] 的因子 A[j]，然后计算左子树和右子树的数量，最后将它们相乘即可。

需要注意的是，由于 A[i] 可以使用任意次数，因此我们需要将 dp[i] 累加上所有可能的左子树和右子树的数量。

最后，我们将所有 dp[i] 相加即可得到答案。

解决方案：

```cpp
class Solution {
public:
    int numFactoredBinaryTrees(vector<int>& A) {
        int n = A.size();
        sort(A.begin(), A.end());
        unordered_map<int, long long> dp;
        for (int i = 0; i < n; i++) {
            dp[A[i]] = 1;
            for (int j = 0; j < i; j++) {
                if (A[i] % A[j] == 0) {
                    int k = A[i] / A[j];
                    if (dp.count(k)) {
                        dp[A[i]] += dp[A[j]] * dp[k];
                    }
                }
            }
        }
        long long ans = 0;
        for (auto& p : dp) {
            ans += p.second;
        }
        return ans % 1000000007;
    }
};
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。