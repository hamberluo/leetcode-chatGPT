题目编号：810

题目：黑板异或游戏

难度：中等

考察范围：位运算、博弈论

题干：

有一个长度为 n 的非空整数数组，初始时每个数都是正整数。

你的任务是对其中的每个数执行一下操作，使得最终数组中的每个数都是 奇数。

每次操作如下：

选择数组中的一个数 x，将 x 减去 2 的某个幂次方，即 x - 2^k，其中 k 是某个非负整数。
注意，每个数可以被操作任意次，但是每个数只能被操作一次。

如果数组中的每个数都是奇数，那么返回 true，否则返回 false。

解题思路：

这是一道博弈论的题目，我们需要找到规律。

首先，如果数组中所有数的异或和为 0，那么先手必败，因为无论先手怎么操作，后手都可以模仿先手的操作，使得最终数组中的每个数都是偶数，从而先手失败。

其次，如果数组中所有数的异或和不为 0，那么先手必胜，因为先手可以通过操作某个数，使得数组中所有数的异或和变为 0，从而后手陷入先前的情况，最终先手获胜。

证明如下：

假设数组中所有数的异或和为 S，那么先手可以选择一个数 x，使得 x 的二进制表示中，S 的最高位为 1 的那一位为 1，然后将 x 减去 2^k，其中 k 是 S 的最高位为 1 的那一位的位数。

这样，x 的二进制表示中，S 的最高位为 1 的那一位变为 0，其他位不变，从而 x 的二进制表示中，S 的每一位都变为了 0 或 1。

然后，先手将 x 的新值与原来的值异或，得到一个新的数 y，将 y 加入数组中，此时数组中所有数的异或和变为了 S xor x xor y。

由于 x 的二进制表示中，S 的最高位为 1 的那一位变为了 0，所以 y 的二进制表示中，S 的最高位为 1 的那一位为 1，从而 y 的二进制表示中，S 的最高位为 1 的那一位变为了 1，其他位不变。

因此，S xor x xor y 的二进制表示中，S 的最高位为 1 的那一位变为了 0，其他位不变，从而 S xor x xor y 的值小于 S。

重复上述操作，直到数组中所有数都是奇数，此时先手获胜。

解决方案：

```cpp
class Solution {
public:
    bool xorGame(vector<int>& nums) {
        int n = nums.size();
        int x = 0;
        for (int num : nums) {
            x ^= num;
        }
        return x == 0 || n % 2 == 0;
    }
};
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(1)。