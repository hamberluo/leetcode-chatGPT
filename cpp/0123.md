题目编号：123

题目：买卖股票的最佳时机 III

难度：困难

考察范围：动态规划

题干：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

解题思路：本题是买卖股票系列中最难的一道题目，需要用到动态规划的思想。我们可以将整个过程分为五个阶段：

1. 未进行任何操作
2. 第一次买入股票
3. 第一次卖出股票
4. 第二次买入股票
5. 第二次卖出股票

对于每个阶段，我们需要记录当前的最大收益。具体来说，我们可以定义四个变量：

1. buy1：在该阶段第一次买入股票后剩余的最大收益
2. sell1：在该阶段第一次卖出股票后剩余的最大收益
3. buy2：在该阶段第二次买入股票后剩余的最大收益
4. sell2：在该阶段第二次卖出股票后剩余的最大收益

对于第一个阶段，由于我们未进行任何操作，因此四个变量的值均为 0。对于第二个阶段，我们需要买入股票，因此 buy1 的值应为 -prices[i]，表示当前的最大收益为买入股票的负收益。对于第三个阶段，我们需要卖出股票，因此 sell1 的值应为 buy1 + prices[i]，表示当前的最大收益为第一次买入股票后的收益加上卖出股票的收益。对于第四个阶段，我们需要再次买入股票，因此 buy2 的值应为 sell1 - prices[i]，表示当前的最大收益为第一次买入股票后的收益减去再次买入股票的负收益。对于第五个阶段，我们需要再次卖出股票，因此 sell2 的值应为 buy2 + prices[i]，表示当前的最大收益为第二次买入股票后的收益加上卖出股票的收益。

最终的答案即为 sell2，因为在最后一个阶段，我们已经完成了两次交易，且卖出了股票。

解决方案：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy1 = INT_MIN, sell1 = 0, buy2 = INT_MIN, sell2 = 0;
        for (int i = 0; i < prices.size(); i++) {
            buy1 = max(buy1, -prices[i]);
            sell1 = max(sell1, buy1 + prices[i]);
            buy2 = max(buy2, sell1 - prices[i]);
            sell2 = max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。