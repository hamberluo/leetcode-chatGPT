题目编号：900

题目：RLE 迭代器

难度：中等

考察范围：数组、模拟

题干：

编写一个遍历游程编码序列的迭代器。

迭代器由 RLEIterator(int[] A) 初始化，其中 A 是某个序列的游程编码。更具体地，对于所有偶数 i，A[i] 告诉我们在序列中重复非负整数值 A[i + 1] 的次数。

迭代器支持一个函数：next(int n)，它耗尽接下来的 n 个元素（n >= 1），并返回最后一个元素的值。如果没有剩余的元素可供耗尽，则返回 -1 。

解题思路：

由于题目中给出的是游程编码，因此我们需要将其转换为原始序列。具体来说，我们可以将游程编码中的每一对相邻的数 (count, value) 展开成 count 个 value。

在实现迭代器时，我们可以使用两个指针 i 和 j，分别表示当前遍历到的游程编码的下标和当前游程编码中剩余的元素个数。每次调用 next 函数时，我们将 n 与 j 中的较小值相比较，取其为本次需要耗尽的元素个数。然后我们从当前游程编码中依次取出这些元素，直到 j 变为 0 或者游程编码被遍历完。如果游程编码被遍历完了，我们需要将 i 后移两个位置，指向下一个游程编码的起始位置。

解决方案：

```cpp
class RLEIterator {
public:
    RLEIterator(vector<int>& A) {
        this->A = A;
        i = 0;
        j = 0;
    }
    
    int next(int n) {
        while (i < A.size() && n > 0) {
            if (j == 0) {
                j = A[i];
                i += 2;
            } else {
                int k = min(n, j);
                n -= k;
                j -= k;
                return A[i + 1];
            }
        }
        return -1;
    }

private:
    vector<int> A;
    int i, j;
};
```

算法复杂度：每次调用 next 函数的时间复杂度为 O(n)，其中 n 表示需要耗尽的元素个数。空间复杂度为 O(1)。