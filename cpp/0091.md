题目编号：91

题目：解码方法

难度：中等

考察范围：动态规划

题干：一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

解题思路：动态规划

对于字符串 s，我们可以定义一个数组 dp，其中 dp[i] 表示字符串 s 的前 i 个字符 s[0..i-1] 的解码方法总数。

考虑对 dp 数组进行推导。我们可以考虑最后一步解码操作对字符串 s 的影响：

如果最后一步是单独解码 s 中的最后一个字符，那么很显然，只要 s 的最后一个字符不是 '0'，就可以将最后一个字符解码成 A~I 中的某个字母，此时的解码方法数为 dp[i-1]。

如果最后一步是解码 s 中的最后两个字符，那么我们需要确保最后两个字符可以被正确解码。如果最后两个字符可以被解码，那么此时的解码方法数为 dp[i-2]。

因此，我们可以得到状态转移方程：

dp[i] = dp[i-1] + dp[i-2]，如果 s[i-1] != '0' 且 s[i-2]s[i-1] 在 [10, 26] 之间
dp[i] = dp[i-1]，如果 s[i-1] != '0' 且 s[i-2]s[i-1] 不在 [10, 26] 之间
dp[i] = 0，如果 s[i-1] == '0' 且 s[i-2]s[i-1] 不在 [10, 26] 之间

解决方案：

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = s[0] == '0' ? 0 : 1;
        for (int i = 2; i <= n; i++) {
            int one = stoi(s.substr(i-1, 1));
            int two = stoi(s.substr(i-2, 2));
            if (one >= 1 && one <= 9) {
                dp[i] += dp[i-1];
            }
            if (two >= 10 && two <= 26) {
                dp[i] += dp[i-2];
            }
        }
        return dp[n];
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。