题目编号：975

题目：奇偶跳

难度：困难

考察范围：动态规划、有序集合

题干：

给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。

你可以按以下方式从索引 i 向前或向后跳转：

奇数跳：（向右跳转）从索引 i 移动到索引 j，其中 i < j 且 A[i] <= A[j]。
偶数跳：（向左跳转）从索引 i 移动到索引 j，其中 i > j 且 A[i] >= A[j]。
（也就是说，对于奇数跳跃，你只能跳到比当前元素大的位置，对于偶数跳跃，你只能跳到比当前元素小的位置。）

此外，你可以只按需要跳跃任意次数。

你的目标是到达数组的最后一个索引（索引 N-1），你的跳跃次数必须是偶数次（也就是说，最后一次跳跃是偶数跳跃）。

如果有多个起始索引能够到达数组的最后一个索引，则返回索引最小的那个起始索引。

注意：

1 <= A.length <= 20000
0 <= A[i] < 100000

解题思路：

本题可以使用动态规划来解决，具体思路如下：

1. 定义两个数组 odd 和 even，其中 odd[i] 表示从第 i 个位置开始进行奇数跳跃能否到达最后一个位置，even[i] 表示从第 i 个位置开始进行偶数跳跃能否到达最后一个位置。

2. 从后往前遍历数组，对于每个位置 i，使用有序集合（set）来找到比当前位置大的最小值和比当前位置小的最大值，然后更新 odd[i] 和 even[i]。

3. 最后返回 odd 数组中值为 true 且 even 数组中值为 true 的最小下标即可。

解决方案：

```cpp
class Solution {
public:
    int oddEvenJumps(vector<int>& A) {
        int n = A.size();
        vector<bool> odd(n), even(n);
        odd[n - 1] = even[n - 1] = true; // 最后一个位置可以到达
        map<int, int> mp; // 记录每个数对应的下标
        mp[A[n - 1]] = n - 1;
        int ans = 1; // 记录能够到达最后一个位置的起始位置个数
        for (int i = n - 2; i >= 0; i--) {
            auto it1 = mp.lower_bound(A[i]); // 找到比当前位置大的最小值
            auto it2 = mp.upper_bound(A[i]); // 找到比当前位置小的最大值
            if (it1 != mp.end()) odd[i] = even[it1->second]; // 更新 odd[i]
            if (it2 != mp.begin()) even[i] = odd[(--it2)->second]; // 更新 even[i]
            if (odd[i]) ans++; // 如果当前位置可以进行奇数跳跃到达最后一个位置，则答案加一
            mp[A[i]] = i; // 记录当前位置
        }
        return ans;
    }
};
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。其中，n 为数组 A 的长度。