题目编号：1000

题目：合并石头的最低成本

难度：困难

考察范围：动态规划、贪心算法

题干：

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

解题思路：

这是一道经典的动态规划问题，但是状态转移方程比较难想。

首先，我们可以先考虑只合并两堆石头的情况。假设有三堆石头，分别为 a, b, c，那么合并 a 和 b 的成本为 a+b，合并 b 和 c 的成本为 b+c。如果我们先合并 a 和 b，再合并新的 ab 和 c，那么总成本为 a+b+b+c=a+2b+c。如果我们先合并 b 和 c，再合并 a 和新的 bc，那么总成本为 b+c+a+b=a+2b+c。可以发现，无论先合并哪两堆石头，最终的总成本都是一样的。

因此，我们可以将问题转化为先合并 K 堆石头的情况。假设有 K 堆石头，分别为 a1, a2, ..., ak，那么合并它们的成本为 sum(a1, a2, ..., ak)。如果我们先合并前 i 堆石头，再合并剩下的 k-i 堆石头，那么总成本为 dp[i][k]+dp[k-i][i]，其中 dp[i][j] 表示合并第 i 堆到第 j 堆石头的最小成本。

但是，这个状态转移方程并不完整。因为在合并前 i 堆石头时，可能需要先合并其中的一些堆石头，才能得到最小成本。因此，我们需要枚举中间点 j，将问题分成两个子问题：合并前 i 堆石头和合并 j+1 到 k 堆石头。这样，状态转移方程就变成了：

dp[i][k] = min(dp[i][j]+dp[j+1][k]) + sum(a[i], a[i+1], ..., a[k])

其中，i<=j<k。

解决方案：

根据上面的状态转移方程，我们可以使用动态规划来解决这个问题。具体来说，我们可以使用一个二维数组 dp，其中 dp[i][j] 表示合并第 i 堆到第 j 堆石头的最小成本。初始时，dp[i][i]=0，因为一堆石头不需要合并。

然后，我们可以使用两个循环来枚举子问题的起点和终点。具体来说，外层循环枚举子问题的长度 len，内层循环枚举子问题的起点 i。根据起点和长度，可以计算出子问题的终点 j=i+len-1。然后，我们可以使用一个循环来枚举中间点 k，计算出 dp[i][j] 的值。具体来说，dp[i][j] 的值为 min(dp[i][k]+dp[k+1][j])+sum(a[i], a[i+1], ..., a[j])，其中 i<=k<j。

最终，dp[1][n] 就是合并所有石头的最小成本。如果 dp[1][n] 为无穷大，说明无法合并所有石头，返回 -1。

下面是代码实现：

```cpp
class Solution {
public:
    int mergeStones(vector<int>& stones, int K) {
        int n = stones.size();
        if ((n - 1) % (K - 1) != 0) {
            return -1;
        }
        vector<int> prefix(n + 1);
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + stones[i];
        }
        vector<vector<int>> dp(n, vector<int>(n));
        for (int len = K; len <= n; len++) {
            for (int i = 0; i + len <= n; i++) {
                int j = i + len - 1;
                dp[i][j] = INT_MAX;
                for (int k = i; k < j; k += K - 1) {
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
                }
                if ((j - i) % (K - 1) == 0) {
                    dp[i][j] += prefix[j + 1] - prefix[i];
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

算法复杂度：

时间复杂度为 O(n^3/K)，其中 n 是石头的数量。因为每次循环中，内层循环的次数为 O(n/K)，而计算 dp[i][j] 的时间复杂度为 O(K)。因此，总时间复杂度为 O(n^3/K)。

空间复杂度为 O(n^2)，因为需要使用一个二维数组 dp 来保存状态。