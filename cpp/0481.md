题目编号：481

题目：神奇字符串

难度：中等

考察范围：字符串、模拟

题干：

神奇的字符串 S 只包含 '1' 和 '2'，并遵守以下规则：

字符串 S 是神奇的，因为串联字符 '1' 和 '2' 的连续出现次数会生成字符串 S 本身。

字符串 S 的前几个元素如下：S = “1221121221221121122 ......”

如果我们将 S 中连续的 1 和 2 进行分组，它将变成：

1 22 11 2 1 22 1 22 11 2 11 22 ......

并且每个组中 '1' 或 '2' 的出现次数分别是：

1 2 2 1 1 2 1 2 2 1 2 2 ......

你可以看到上面的出现次数就是 S 本身。

给定一个整数 n 作为输入，返回神奇字符串 S 中前 n 个数字中的 '1' 的数目。

注意：n 不会超过 100,000。

解题思路：

根据题目中的规律，我们可以发现，神奇字符串 S 的生成过程是一个递归的过程，每次生成的字符串都是由上一次生成的字符串中的数字按照一定规律生成的。

具体来说，我们可以定义一个指针 p，初始时指向字符串 S 的第一个字符，然后不断地向后遍历字符串，每次遇到一个数字 x，就将其后面的 x 个数字加入到字符串中。例如，当 p 指向字符 '2' 时，我们将字符 '2' 后面的 2 个数字 '1' 和 '2' 加入到字符串中，得到新的字符串 S' = "1221121221221121122"。

在遍历字符串的过程中，我们可以用一个变量 count 来记录当前已经生成的字符串中 '1' 的个数。每次遇到一个 '1'，就将 count 加 1。最后返回前 n 个数字中 '1' 的个数即可。

解决方案：

```cpp
class Solution {
public:
    int magicalString(int n) {
        if (n == 0) return 0;
        if (n <= 3) return 1;
        string s = "122";
        int p = 2, count = 1;
        while (s.size() < n) {
            int x = s.back() - '0';
            if (x == 1) {
                if (s[p] == '1') s += '2';
                else s += '1';
                p++;
            } else {
                if (s[p] == '1') s += "22";
                else s += "11";
                p += 2;
            }
        }
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') count++;
        }
        return count;
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。