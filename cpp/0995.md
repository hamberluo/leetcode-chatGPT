题目编号：995

题目：K 连续位的最小翻转次数

难度：困难

考察范围：贪心算法、滑动窗口

题干：

在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，并将子数组中的每个 0 更改为 1，而每个 1 更改为 0。

返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。

解题思路：

我们可以使用贪心算法来解决这个问题。我们从左到右扫描数组 A，如果当前位置 i 的值为 0，那么我们需要翻转以 i 开始的长度为 K 的子数组，使得 A[i] 变成 1。但是，如果我们翻转了以 i 开始的子数组，那么后面的一些位置也会被翻转，这是我们不想看到的。因此，我们可以使用一个变量 flip 记录当前位置是否被翻转过，如果 flip 为 true，那么我们就不需要再翻转以 i 开始的子数组了。

我们可以使用一个队列来记录当前需要翻转的子数组的位置。如果当前位置 i 的值为 0，那么我们将 i 加入队列中。如果队列中的长度大于 K，那么我们需要弹出队列的头部元素，因为它已经不再需要翻转了。如果队列的长度为 K，那么我们就需要翻转队列中的所有元素，并将 flip 置为 true。

如果我们扫描完整个数组 A，那么我们需要检查数组中是否还有值为 0 的元素。如果有，那么说明无法将数组中的所有元素都变成 1，返回 -1。否则，返回翻转的次数。

解决方案：

```cpp
class Solution {
public:
    int minKBitFlips(vector<int>& A, int K) {
        int n = A.size();
        int flip = 0;
        int ans = 0;
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (!q.empty() && q.front() + K == i) {
                q.pop();
                flip ^= 1;
            }
            if (A[i] == flip) {
                if (i + K > n) {
                    return -1;
                }
                q.push(i);
                flip ^= 1;
                ans++;
            }
        }
        return ans;
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(k)。