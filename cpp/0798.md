题目编号：798

题目：得分最高的最小轮调

难度：困难

考察范围：贪心算法、二分查找

题干：

有一个长度为 n 的数组，每次轮调操作可以将数组的最后一个元素移动到数组的第一个位置，其余元素顺次向后移动一个位置。比如，对于数组 [3,2,1]，经过一次轮调操作后变为 [1,3,2]。

给定一个数组 A，你可以执行任意次数的轮调操作。返回数组 A 中得分最高的情况下，执行轮调操作的最小次数。

数组的得分定义为：对于数组中的任意两个相邻元素，它们的乘积再求和。比如，数组 [1,3,2] 的得分为：(1*3 + 3*2) = 9。

解题思路：

首先，我们可以发现，对于一个数组 A，如果我们将其进行一次轮调操作，得分不会发生变化。因此，我们可以将数组 A 进行若干次轮调操作，使得数组中的最大值尽可能地靠前，从而得到最高的得分。

具体地，我们可以先找到数组 A 中的最大值 max_val，然后将其移动到数组的第一个位置。此时，我们可以将数组分为两个部分：以 max_val 为分界点的左半部分和右半部分。对于左半部分，我们可以将其逆序，使得最大值尽可能地靠前。对于右半部分，我们可以将其顺序不变，因为右半部分的元素对于得分的贡献是相同的。

最后，我们可以将左半部分和右半部分拼接起来，得到一个新的数组 B。此时，我们可以发现，数组 B 的得分与数组 A 的得分相同，但是数组 B 中的最大值已经在第一个位置了。因此，我们可以将数组 B 视为新的数组 A，重复上述操作，直到数组 A 中的最大值已经在第一个位置了。

解决方案：

```cpp
class Solution {
public:
    int maxRotateFunction(vector<int>& A) {
        int n = A.size();
        long long sum = 0, f = 0;
        for (int i = 0; i < n; i++) {
            sum += A[i];
            f += i * A[i];
        }
        long long ans = f;
        for (int i = n - 1; i >= 1; i--) {
            f = f + sum - n * A[i];
            ans = max(ans, f);
        }
        return ans;
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。