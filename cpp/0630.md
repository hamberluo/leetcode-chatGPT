题目编号：630

题目：课程表 III

难度：中等

考察范围：贪心算法、堆

题干：

这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时才能完成，你将会从第 1 天开始。

给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。

示例：

输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 200 天关闭课程。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 且第 1250 天是关闭课程大限。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天时关闭它。

注意:

整数 1 <= d, t, n <= 10,000 。
你不能同时修两门课程。

解题思路：

首先，我们可以将所有课程按照关闭时间从小到大排序，然后遍历每个课程，对于每个课程，我们可以选择修或不修。

如果选择修这门课程，我们需要将其加入到一个已选课程的集合中，并且更新当前已选课程的总时间。如果当前已选课程的总时间超过了该课程的关闭时间，我们需要将已选课程中耗时最长的课程删除，以保证当前已选课程的总时间不超过该课程的关闭时间。

如果不选择修这门课程，我们不需要做任何操作。

最终，已选课程的数量就是最多可以修的课程数量。

解决方案：

```cpp
class Solution {
public:
    int scheduleCourse(vector<vector<int>>& courses) {
        sort(courses.begin(), courses.end(), [](vector<int>& a, vector<int>& b) {
            return a[1] < b[1];
        });
        priority_queue<int> pq;
        int time = 0;
        for (auto& c : courses) {
            if (time + c[0] <= c[1]) {
                pq.push(c[0]);
                time += c[0];
            } else if (!pq.empty() && pq.top() > c[0]) {
                time += c[0] - pq.top();
                pq.pop();
                pq.push(c[0]);
            }
        }
        return pq.size();
    }
};
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)。