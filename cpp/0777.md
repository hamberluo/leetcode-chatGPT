题目编号：777

题目：在LR字符串中交换相邻字符

难度：中等

考察范围：字符串、双指针

题干：

在LR字符串中，L表示向左移动，R表示向右移动。给定两个相邻的字符串s和t，你需要判断是否可以通过交换s中的任意两个相邻字符得到t。

例如，对于字符串s = "RXXLRXRXL"和t = "XRLXXRRLX"，我们可以通过交换s中的第二个和第三个字符得到t。

解题思路：

首先，我们可以观察到，如果s中的L在t中的位置比s中的R在t中的位置更靠左，那么无论如何都无法通过交换s中的任意两个相邻字符得到t。因为L只能向左移动，R只能向右移动，所以L在t中的位置比R在t中的位置更靠左，就意味着L在s中的位置也比R在s中的位置更靠左，无论如何也无法通过交换相邻字符将L移到R的右边。

其次，我们可以观察到，如果s中的L在t中的位置比s中的R在t中的位置更靠右，那么同样无法通过交换s中的任意两个相邻字符得到t。因为L只能向左移动，R只能向右移动，所以R在t中的位置比L在t中的位置更靠右，就意味着R在s中的位置也比L在s中的位置更靠右，无论如何也无法通过交换相邻字符将R移到L的左边。

最后，我们可以观察到，如果s中的L在t中的位置比s中的R在t中的位置在同一侧，那么就可以通过交换s中的任意两个相邻字符得到t。因为L只能向左移动，R只能向右移动，所以L和R在同一侧，就意味着它们之间的距离不会改变，只需要将它们交换位置即可。

解决方案：

根据上述思路，我们可以编写如下的cpp代码：

```cpp
class Solution {
public:
    bool canTransform(string s, string t) {
        int n = s.size();
        int i = 0, j = 0;
        while (i < n && j < n) {
            while (i < n && s[i] == 'X') i++;
            while (j < n && t[j] == 'X') j++;
            if (s[i] != t[j]) return false;
            if (s[i] == 'L' && i < j) return false;
            if (s[i] == 'R' && i > j) return false;
            i++;
            j++;
        }
        while (i < n && s[i] == 'X') i++;
        while (j < n && t[j] == 'X') j++;
        return i == j;
    }
};
```

算法复杂度：时间复杂度为O(n)，空间复杂度为O(1)。