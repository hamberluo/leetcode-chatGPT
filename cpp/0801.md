题目编号：801

题目：使序列递增的最小交换次数

难度：中等

考察范围：贪心算法、动态规划

题干：给定一个长度为 n 的整数序列，你需要找到一个最小的交换次数，使得交换任意两个元素后，序列变得递增。输出最小的交换次数。

解题思路：本题可以使用贪心算法或动态规划来解决。这里介绍一种贪心算法的思路。

首先，我们需要明确一点，即对于一个递增的序列，我们只需要考虑相邻两个元素之间的大小关系，而不需要考虑其他元素之间的大小关系。因此，我们可以将原序列中的每个元素与其在递增序列中的位置进行配对，得到一个位置序列 pos。

接下来，我们需要找到一个最长的递增子序列，使得这个子序列中的元素在原序列中的位置也是递增的。我们可以使用动态规划来解决这个问题，具体做法是维护一个数组 dp，其中 dp[i] 表示以第 i 个元素为结尾的最长递增子序列的长度。状态转移方程为：

dp[i] = max(dp[j] + 1)，其中 j < i 且 nums[j] < nums[i]

最终的最长递增子序列的长度为 max(dp[i])。

接下来，我们需要计算最小交换次数。我们可以从前往后遍历原序列，对于每个元素，如果它在递增序列中的位置与它在原序列中的位置不同，那么我们就需要将它与它在递增序列中的位置对应的元素进行交换。具体做法是，对于每个元素 i，我们找到它在递增序列中的位置 j，然后将 nums[i] 和 nums[pos[j]] 进行交换。交换后，我们需要更新 pos 数组，将 pos[i] 和 pos[j] 的值进行交换。

最终的最小交换次数就是所有交换次数的和。

解决方案：

```cpp
class Solution {
public:
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        vector<int> dp(n, n);
        dp[0] = 0;
        vector<int> pos(n);
        for (int i = 0; i < n; i++) {
            pos[i] = i;
        }
        for (int i = 1; i < n; i++) {
            if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
                dp[i] = dp[i - 1];
                pos[i] = pos[i - 1];
            }
            if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
                dp[i] = min(dp[i], dp[i - 1] + 1);
                int j = pos[i - 1];
                pos[i] = pos[j];
                pos[j] = i;
            }
        }
        return dp[n - 1];
    }
};
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。