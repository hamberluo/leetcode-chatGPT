题目编号：639

题目：解码方法 II

难度：困难

考察范围：动态规划

题干：

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'，可以表示从 1 到 9 的任意数字（不包括 0）。例如，字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18"、"19"。

给定一串数字解码后的消息，判断有多少种解码方式。

解题思路：

这道题是一道动态规划的题目，我们可以定义 dp[i] 表示前 i 个字符的解码方式数量。

对于第 i 个字符，我们需要考虑以下几种情况：

1. 当前字符为数字 1-9，那么它可以单独解码，即 dp[i] += dp[i-1]。

2. 当前字符为 *，那么它可以表示 1-9 中的任意一个数字，所以它可以单独解码，即 dp[i] += 9 * dp[i-1]。

3. 当前字符为数字 0，那么它只能和前一个字符组成 10 或 20，即 dp[i] += dp[i-2]。

4. 当前字符为 *，且前一个字符为 1，那么它可以表示 11-19 中的任意一个数字，即 dp[i] += 9 * dp[i-2]。

5. 当前字符为 *，且前一个字符为 2，那么它可以表示 21-26 中的任意一个数字，即 dp[i] += 6 * dp[i-2]。

6. 当前字符为 *，且前一个字符为 *，那么它可以表示 11-26 中的任意一个数字，即 dp[i] += 15 * dp[i-2]。

需要注意的是，由于题目要求对结果取模，所以在计算 dp[i] 的时候需要对结果取模。

解决方案：

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        const int mod = 1e9 + 7;
        vector<long long> dp(n+1);
        dp[0] = 1;
        if (s[0] == '0') {
            return 0;
        }
        dp[1] = (s[0] == '*') ? 9 : 1;
        for (int i = 2; i <= n; i++) {
            char c1 = s[i-2], c2 = s[i-1];
            if (c2 >= '1' && c2 <= '9') {
                dp[i] += dp[i-1];
                dp[i] %= mod;
            }
            if (c2 == '*') {
                dp[i] += 9 * dp[i-1];
                dp[i] %= mod;
            }
            if (c1 == '1' && c2 == '*') {
                dp[i] += 9 * dp[i-2];
                dp[i] %= mod;
            }
            if (c1 == '2' && c2 == '*') {
                dp[i] += 6 * dp[i-2];
                dp[i] %= mod;
            }
            if (c1 == '*' && c2 == '*') {
                dp[i] += 15 * dp[i-2];
                dp[i] %= mod;
            }
            if (c1 == '1' && c2 >= '0' && c2 <= '9') {
                dp[i] += dp[i-2];
                dp[i] %= mod;
            }
            if (c1 == '2' && c2 >= '0' && c2 <= '6') {
                dp[i] += dp[i-2];
                dp[i] %= mod;
            }
            if (c1 == '*' && c2 >= '0' && c2 <= '6') {
                dp[i] += 2 * dp[i-2];
                dp[i] %= mod;
            }
            if (c1 == '*' && c2 >= '7' && c2 <= '9') {
                dp[i] += dp[i-2];
                dp[i] %= mod;
            }
        }
        return dp[n];
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。