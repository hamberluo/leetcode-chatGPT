题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：

你的音乐播放器里有 n 首不同的歌，在旅途中，你的旅伴想要听 l 首歌（不一定不同，即，允许重复）。请你为她按如下规则创建一个播放列表：

每首歌都至少播放一次。
一首歌只有在其他 k 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

解题思路：

这是一道动态规划的题目，我们可以定义 dp[i][j] 表示在播放列表中，已经播放了 i 首歌，其中有 j 首歌是不同的。那么我们可以得到状态转移方程：

dp[i][j] = dp[i-1][j-1] * (n-j+1) + dp[i-1][j] * max(j-k, 0)

其中，第一项表示在已经播放了 i-1 首歌，其中有 j-1 首是不同的情况下，再加上一首不同的歌，有 (n-j+1) 种选择。第二项表示在已经播放了 i-1 首歌，其中有 j 首是不同的情况下，再加上一首歌，有 max(j-k, 0) 种选择，其中 k 表示一首歌只有在其他 k 首歌播放完之后才能再次播放。

最终的答案就是 dp[l][n]。

解决方案：

```cpp
class Solution {
public:
    int numMusicPlaylists(int n, int l, int k) {
        int mod = 1e9 + 7;
        vector<vector<long long>> dp(l+1, vector<long long>(n+1));
        dp[0][0] = 1;
        for (int i = 1; i <= l; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (dp[i-1][j-1] * (n-j+1) + dp[i-1][j] * max(j-k, 0)) % mod;
            }
        }
        return dp[l][n];
    }
};
```

算法复杂度：时间复杂度为 O(nl)，空间复杂度为 O(nl)。