题目编号：264

题目：丑数 II

难度：中等

考察范围：动态规划、堆

题干：

编写一个程序，找出第 n 个丑数。

丑数就是只包含质因数 2、3 和/或 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明:  

1 是丑数。
n 不超过1690。

解题思路：

丑数的定义是只包含质因数 2、3 和/或 5 的正整数，因此第 n 个丑数一定可以表示为 2^i * 3^j * 5^k 的形式，其中 i,j,k 都是非负整数。

我们可以从小到大枚举 i,j,k，每次计算出当前的丑数，直到找到第 n 个丑数为止。但是这种方法的时间复杂度为 O(n^3)，无法通过本题。

我们可以使用动态规划的思想来优化时间复杂度。我们定义一个数组 dp，其中 dp[i] 表示第 i 个丑数。显然，dp[1]=1。

我们考虑如何计算 dp[i]。我们可以从 dp[i-1] 开始，分别乘以 2、3 和 5，得到三个数，分别记为 a,b,c。那么 dp[i] 就是这三个数中最小的那个，即 dp[i]=min(a,b,c)。

但是这种方法会有重复计算的问题，例如当 i=4 时，我们需要计算 dp[4]=min(dp[2]*2,dp[1]*3,dp[1]*5)，但是 dp[2]*2 和 dp[1]*3 在计算 dp[5] 时已经被计算过了，因此我们需要记录上一次计算的位置，避免重复计算。

我们可以使用三个指针 p2,p3,p5，分别表示下一个丑数是当前指针指向的数乘以 2、3 和 5 得到的，初始时，p2=p3=p5=1。每次计算 dp[i] 时，我们将 dp[i]=min(dp[p2]*2,dp[p3]*3,dp[p5]*5)，然后将对应的指针加 1，表示下一个丑数是当前指针指向的数乘以对应的因子得到的。

解决方案：

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n+1);
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for (int i = 2; i <= n; i++) {
            int a = dp[p2] * 2, b = dp[p3] * 3, c = dp[p5] * 5;
            dp[i] = min(a, min(b, c));
            if (dp[i] == a) p2++;
            if (dp[i] == b) p3++;
            if (dp[i] == c) p5++;
        }
        return dp[n];
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。