题目编号：807

题目：保持城市天际线

难度：中等

考察范围：数组、模拟

题干：

在二维数组 grid 中，grid[i][j] 代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。

最后，从新数组中的所有建筑物中选出最高的  MaxHeight 。 重要的是，从天际线的角度来看，仅仅增加建筑物高度而不增加建筑物数量是没有意义的。

因此，返回能够增加建筑物高度的最大总和，以及由此产生的新数组。

示例 1:

输入: [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
输出: 35
解释:
第一个维度方向上，增加高度后数组变为:
[[3,0,8,4],
 [2,4,5,7],
 [9,2,6,3],
 [0,3,1,0]]
第二个维度方向上，增加高度后数组变为:
[[8,4,8,7],
 [7,4,7,7],
 [9,4,8,7],
 [3,3,3,3]]

新数组中的最大值为9，最大值出现在了新数组的第二个维度的第三个位置，因此返回结果为35。

解题思路：

首先，我们需要找到每行每列的最大值，这些最大值就是天际线。然后，我们需要将每个建筑物的高度增加到其所在行和列的天际线高度中的较小值。这样，我们就可以保证增加建筑物高度而不增加建筑物数量。

解决方案：

```cpp
class Solution {
public:
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<int> rowMax(n, 0);
        vector<int> colMax(n, 0);
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                rowMax[i] = max(rowMax[i], grid[i][j]);
                colMax[j] = max(colMax[j], grid[i][j]);
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                ans += min(rowMax[i], colMax[j]) - grid[i][j];
            }
        }
        return ans;
    }
};
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。