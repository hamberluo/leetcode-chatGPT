题目编号：571

题目：给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前 k 个字符进行反转。

如果剩余少于 k 个字符，则将剩余所有字符都反转。

如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，其余字符保持原样。

难度：中等

考察范围：字符串、双指针

题干：

示例 1：

输入：s = "abcdefg", k = 2
输出："bacdfeg"
解释：
每个 2k 字符串反转前 2 个字符。
"bacd" 无需反转，因为长度小于 k。
"fe" 也无需反转，因为它的长度小于 k。
因此，反转后的字符串为 "bacdfeg"。

示例 2：

输入：s = "abcd", k = 2
输出："bacd"
解释：每个 2k 字符串反转前 2 个字符。
"bacd" 无需反转，因为长度小于 k。
因此，反转后的字符串为 "bacd"。

解题思路：双指针

我们可以使用双指针的方法，每次将指针 i 和 j 分别指向每个 2k 的起始位置和结束位置，然后将 i 到 i+k-1 的字符与 j 到 j-k+1 的字符交换位置，即可完成反转。

需要注意的是，当剩余字符不足 k 个时，只需要将剩余字符全部反转即可。

解决方案：

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.size();
        for (int i = 0; i < n; i += 2 * k) {
            int j = min(i + k - 1, n - 1);
            reverse(s.begin() + i, s.begin() + j + 1);
        }
        return s;
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。