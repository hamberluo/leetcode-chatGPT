题目编号：968

题目：监控二叉树

难度：困难

考察范围：二叉树、贪心算法、递归

题干：

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

解题思路：

本题是一道贪心算法的题目，我们需要从叶子节点开始递归，对于每个节点，我们需要考虑三种情况：

1.该节点已经被覆盖：即该节点的子节点中已经有摄像头了，那么该节点就不需要再放置摄像头了。

2.该节点需要放置摄像头：即该节点的子节点中没有被覆盖的节点，那么该节点就需要放置摄像头。

3.该节点不需要放置摄像头，但需要被覆盖：即该节点的子节点中有已经被覆盖的节点，那么该节点就不需要放置摄像头，但需要被覆盖。

对于每个节点，我们需要返回一个状态，表示该节点的状态，具体如下：

0：该节点需要被覆盖

1：该节点已经被覆盖

2：该节点需要放置摄像头

对于每个节点，我们需要根据其子节点的状态来判断该节点的状态，具体如下：

1.如果该节点的左右子节点的状态都是1，那么该节点的状态就是0。

2.如果该节点的左右子节点中有一个状态是2，那么该节点的状态就是1。

3.如果该节点的左右子节点的状态都是0或者其中一个是0，另一个是1，那么该节点的状态就是2。

对于根节点，我们需要特殊处理，如果根节点的状态是0，那么我们需要在根节点处放置一个摄像头。

解决方案：

```cpp
class Solution {
public:
    int minCameraCover(TreeNode* root) {
        int ans = 0;
        if (dfs(root, ans) == 0) ans++;
        return ans;
    }

    int dfs(TreeNode* node, int& ans) {
        if (!node) return 1;
        int left = dfs(node->left, ans);
        int right = dfs(node->right, ans);
        if (left == 0 || right == 0) {
            ans++;
            return 2;
        } else if (left == 2 || right == 2) {
            return 1;
        } else {
            return 0;
        }
    }
};
```

算法复杂度：时间复杂度为O(n)，空间复杂度为O(h)，其中n为节点数，h为树的高度。