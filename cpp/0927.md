题目编号：927

题目：三等分

难度：困难

考察范围：数组、双指针

题干：

给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。

如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：

A[0], A[1], ..., A[i] 组成第一部分；
A[i+1], A[i+2], ..., A[j-1] 作为第二部分；
A[j], A[j+1], ..., A[A.length - 1] 是第三部分。
这三个部分所表示的二进制值相等。如果无法做到，就返回 [-1, -1]。

注意，在考虑每个部分所表示的二进制值时，应将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。

解题思路：

首先，我们可以统计数组中 1 的个数，如果 1 的个数不是 3 的倍数，那么无法分成三等分，直接返回 [-1, -1]。

然后，我们可以计算出每一部分应该表示的二进制值，即 sum / 3，其中 sum 是数组中 1 的个数。

接下来，我们可以使用双指针，分别从数组的两端开始向中间遍历，找到第一个部分和第二个部分的结束位置 i 和 j，使得它们所表示的二进制值都等于 sum / 3。如果找不到这样的 i 和 j，直接返回 [-1, -1]。

最后，我们只需要判断第三个部分是否也等于 sum / 3，如果是，就返回 [i, j+1]，否则返回 [-1, -1]。

解决方案：

```cpp
class Solution {
public:
    vector<int> threeEqualParts(vector<int>& A) {
        int n = A.size();
        int ones = count(A.begin(), A.end(), 1);
        if (ones % 3 != 0) {
            return {-1, -1};
        }
        if (ones == 0) {
            return {0, n-1};
        }
        int k = ones / 3;
        int i = 0, j = n-1;
        int cnt = 0;
        while (cnt < k) {
            if (A[i] == 1) {
                cnt++;
            }
            i++;
        }
        cnt = 0;
        while (cnt < k) {
            if (A[j] == 1) {
                cnt++;
            }
            j--;
        }
        int x = i, y = j;
        while (A[x] == 0) {
            x++;
        }
        while (A[y] == 0) {
            y--;
        }
        int a = 0, b = 0, c = 0;
        for (int p = 0; p < i; p++) {
            a = a * 2 + A[p];
        }
        for (int p = i; p <= j; p++) {
            b = b * 2 + A[p];
        }
        for (int p = j+1; p < n; p++) {
            c = c * 2 + A[p];
        }
        if (a != b || b != c) {
            return {-1, -1};
        }
        int len1 = i-1, len2 = j-i, len3 = n-j-1;
        if (len3 > len1 || len3 > len2) {
            return {-1, -1};
        }
        return {j+len3, j+len3+1};
    }
};
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。