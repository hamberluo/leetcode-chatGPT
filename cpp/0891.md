题目编号：891

题目：子序列宽度之和

难度：困难

考察范围：动态规划、数学

题干：

给定一个整数数组 A ，考虑 A 的所有非空子序列。

对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。

返回 A 的所有子序列的宽度之和。

由于答案可能非常大，请返回答案模 10^9+7。

示例：

输入：[2,1,3]
输出：6
解释：
子序列为 [2]，[1]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。
相应的宽度是 0，0，0，1，1，2，2 。
这些宽度之和是 6 。

提示：

1 <= A.length <= 20000
1 <= A[i] <= 20000

解题思路：

首先，我们可以将 A 数组排序，这样最大值和最小值就可以直接取到了。

然后，我们考虑对于每个数 A[i]，它在多少个子序列中是最大值或最小值。

对于最大值，它在所有以 A[i] 结尾的子序列中都是最大值，而在所有以 A[i] 开头的子序列中都不是最大值。

对于最小值，同理。

因此，我们可以先对 A 数组排序，然后对于每个数 A[i]，计算出它在多少个子序列中是最大值或最小值，然后将这个数对答案的贡献加上即可。

具体来说，我们可以用 dp1[i] 表示以 A[i] 结尾的子序列中，A[i] 是最大值的子序列个数，dp2[i] 表示以 A[i] 结尾的子序列中，A[i] 是最小值的子序列个数。

对于 dp1[i]，我们可以枚举 A[j]（j < i），如果 A[j] < A[i]，那么以 A[j] 结尾的子序列中，A[i] 可以作为最大值，因此 dp1[i] += dp1[j] + 1。

对于 dp2[i]，同理。

最后，我们将所有数的贡献加起来即可。

解决方案：

```cpp
class Solution {
public:
    int sumSubseqWidths(vector<int>& A) {
        const int MOD = 1e9 + 7;
        int n = A.size();
        sort(A.begin(), A.end());
        vector<long long> dp1(n), dp2(n);
        dp1[0] = dp2[0] = 1;
        for (int i = 1; i < n; i++) {
            dp1[i] = dp2[i] = 1;
            for (int j = 0; j < i; j++) {
                if (A[j] < A[i]) {
                    dp1[i] = (dp1[i] + dp1[j] + 1) % MOD;
                }
                if (A[j] > A[i]) {
                    dp2[i] = (dp2[i] + dp2[j] + 1) % MOD;
                }
            }
        }
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            ans = (ans + (dp1[i] - 1) * A[i] % MOD - (dp2[i] - 1) * A[i] % MOD + MOD) % MOD;
        }
        return ans;
    }
};
```

算法复杂度：时间复杂度 O(n^2)，空间复杂度 O(n)。