题目编号：847

题目：访问所有节点的最短路径

难度：困难

考察范围：图论、BFS、状态压缩

题干：给定一个包含 n 个节点的有向图 G，你需要从节点 0 出发，访问所有节点恰好一次。请你求出需要的最少移动次数。如果从 s 到 t 有多条路径，需要保证每次移动都是移动到下一个未访问的节点上，且这些节点构成了访问所有未访问过的节点的第一条路径。

解题思路：本题是一道典型的图论问题，需要用到 BFS 算法。由于需要访问所有节点，因此可以使用状态压缩来记录当前已经访问过的节点。具体来说，可以使用一个二进制数来表示当前已经访问过的节点，第 i 位为 1 表示已经访问过节点 i，为 0 表示未访问过。例如，对于一个有 4 个节点的图，初始状态为 0000，表示所有节点均未访问过。当访问了节点 0 和节点 2 后，状态变为 0101，表示节点 0 和节点 2 已经访问过，而节点 1 和节点 3 未访问过。

在 BFS 算法中，需要记录当前所在节点以及已经访问过的节点状态。由于需要记录两个信息，因此可以使用 pair 类型来表示 BFS 队列中的元素。具体来说，pair 的第一个元素表示当前所在节点，第二个元素表示已经访问过的节点状态。例如，对于一个有 4 个节点的图，当前所在节点为 0，已经访问过的节点状态为 0101，可以表示为 (0, 5)。

在 BFS 算法中，需要遍历当前节点的所有出边，并将未访问过的节点加入队列中。由于需要保证每次移动都是移动到下一个未访问的节点上，因此需要记录当前已经访问过的节点状态。具体来说，对于当前节点 i，如果它的一个出边指向节点 j，且节点 j 未访问过，那么可以将节点 j 加入队列中，并将已经访问过的节点状态更新为当前状态加上节点 j 的状态。例如，对于一个有 4 个节点的图，当前所在节点为 0，已经访问过的节点状态为 0101，如果节点 0 的一个出边指向节点 1，且节点 1 未访问过，那么可以将节点 (1, 5) 加入队列中，其中 5 表示节点 0 和节点 2 已经访问过，而节点 1 和节点 3 未访问过。

解决方案：

```cpp
class Solution {
public:
    int shortestPathLength(vector<vector<int>>& graph) {
        int n = graph.size();
        queue<pair<int, int>> q;
        vector<vector<bool>> vis(n, vector<bool>(1 << n));
        for (int i = 0; i < n; i++) {
            q.push({i, 1 << i});
            vis[i][1 << i] = true;
        }
        int step = 0;
        while (!q.empty()) {
            int sz = q.size();
            while (sz--) {
                auto [u, state] = q.front();
                q.pop();
                if (state == (1 << n) - 1) {
                    return step;
                }
                for (int v : graph[u]) {
                    int new_state = state | (1 << v);
                    if (!vis[v][new_state]) {
                        q.push({v, new_state});
                        vis[v][new_state] = true;
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
```

算法复杂度：时间复杂度为 O(n * 2^n)，空间复杂度为 O(n * 2^n)。其中 n 表示节点数。在 BFS 算法中，每个节点最多会被访问一次，因此时间复杂度为 O(n * 2^n)。在 vis 数组中，需要记录每个节点的 2^n 种状态，因此空间复杂度为 O(n * 2^n)。