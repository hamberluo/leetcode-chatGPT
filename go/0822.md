题目编号：822

题目：翻转卡片游戏

难度：中等

考察范围：数组、模拟

题干：在桌子上有一堆牌，每张牌上都写着一个整数。此外，还有一个长度相同的卡牌正面朝下地放在桌子上。只有当你选择一张写着 x 的牌时，才能查看卡牌上写着什么。现在，你需要通过翻转牌的方式使得牌上的整数全部相等。每次翻牌可以选择任意一张牌，然后将这张牌翻转，即如果这张牌正面朝上，则翻转成背面朝上；如果这张牌背面朝上，则翻转成正面朝上。你需要至少翻转多少次才能使所有牌上的整数相等？

解题思路：首先，我们需要知道的是，如果有一张牌上的数字出现的次数大于等于总牌数的一半，那么这张牌上的数字就是我们要找的数字。因为如果有一张牌上的数字出现的次数大于等于总牌数的一半，那么我们只需要翻转其他牌上的数字，就可以使得所有牌上的数字都变成这个数字。所以我们只需要统计每个数字出现的次数，然后找出出现次数最多的数字，计算翻转其他牌上的数字的次数即可。

解决方案：

```go
func flipgame(fronts []int, backs []int) int {
    n := len(fronts)
    cnt := make([]int, 2001) // 统计每个数字出现的次数
    for i := 0; i < n; i++ {
        cnt[fronts[i]]++
        cnt[backs[i]]++
    }
    ans := 2001
    for i := 0; i < n; i++ {
        if fronts[i] == backs[i] { // 如果正反面数字相同，那么这个数字只需要翻转一次
            ans = min(ans, fronts[i])
        } else {
            if cnt[fronts[i]] <= n && cnt[backs[i]] <= n { // 如果这个数字不是所有牌上的数字，那么这个数字需要翻转两次
                ans = min(ans, min(fronts[i], backs[i]))
            }
        }
    }
    if ans == 2001 { // 如果所有牌上的数字都相同，那么返回 0
        return 0
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。