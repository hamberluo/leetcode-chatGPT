题目编号：798

题目：得分最高的最小轮调

难度：困难

考察范围：贪心算法

题干：

给定一个数组 A，我们可以将它按一个非负整数 K 进行轮调，这样可以使数组变为 A[K], A[K+1], A[K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1] 的形式。此后，任何值小于或等于其索引的元素都可以视为「正确的」。

例如，如果数组为 [1, 5, 3, 2, 4]，则按 3 进行轮调后，可以得到 [2, 4, 1, 5, 3]，此时数组中的值 2、4、1 都可以视为正确的。

给定一个包含 [0, A.length - 1] 范围内整数的数组 A，求出在一次轮调操作后，任何值小于或等于其索引的最大值是多少。

解题思路：

首先，我们可以发现，对于一个数组 A，如果我们将其按照某个位置 K 进行轮调，那么对于任意一个位置 i，其正确的值应该是 A[(i+K)%n]，其中 n 是数组 A 的长度。

接下来，我们考虑如何求出在一次轮调操作后，任何值小于或等于其索引的最大值。

我们可以使用二分查找的思想，假设当前我们要查找的值为 x，那么我们可以将数组 A 按照某个位置 K 进行轮调，使得 A[K] = x，然后我们可以遍历数组 A，找到最大的 i，使得 A[i] <= i。

如果 i < K，那么我们可以将数组 A 按照 i 进行轮调，使得 A[i] = x，然后我们可以遍历数组 A，找到最大的 j，使得 A[j] <= j。

如果 j < i，那么我们可以将数组 A 按照 j 进行轮调，使得 A[j] = x，然后我们可以遍历数组 A，找到最大的 k，使得 A[k] <= k。

以此类推，直到找到最大的 m，使得 A[m] <= m。

解决方案：

下面是使用上述思路的 go 代码实现：

```go
func bestRotation(A []int) int {
    n := len(A)
    bad := make([]int, n)
    for i := 0; i < n; i++ {
        left, right := (i-A[i]+1+n)%n, (i+1)%n
        bad[left]--
        bad[right]++
        if left > right {
            bad[0]--
        }
    }
    ans, best := -n, -n
    sum := 0
    for i := 0; i < n; i++ {
        sum += bad[i]
        if sum > ans {
            ans = sum
            best = i
        }
    }
    return best
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。