题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：

你的音乐播放器里有 n 首不同的歌，在旅途中，你的旅伴想要听 m 首歌（不一定不同，即，允许重复）。请你按照如下规则创建一个播放列表：

每首歌都至少播放一次。
一首歌只有在其他 k 首歌播放完之后才能再次播放。
返回可以创建的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

解题思路：

这是一道动态规划的题目，我们可以定义 dp[i][j] 表示在播放列表中放置 i 首歌，其中有 j 首不同的歌的方案数。我们可以考虑最后一首歌是否和之前的歌相同，如果相同，那么最后一首歌可以和之前的任意一首歌交换位置，所以方案数为 dp[i-1][j-1] * (n-j+1)；如果不同，那么最后一首歌只能从剩下的 n-j 首歌中选择，所以方案数为 dp[i-1][j] * (n-j)。

解决方案：

```go
func numMusicPlaylists(n int, m int, k int) int {
    mod := int(1e9 + 7)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    dp[0][0] = 1
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            dp[i][j] = (dp[i-1][j-1] * (n-j+1) + dp[i-1][j] * j) % mod
        }
    }
    return dp[m][n]
}
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。