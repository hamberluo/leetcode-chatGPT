题目编号：650

题目：只有两个键的键盘

难度：中等

考察范围：动态规划

题干：

最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

- Copy All（复制全部）：复制这个记事本中的所有字符（不允许部分复制）。
- Paste（粘贴）：粘贴 上一次 复制的字符。

给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。

解题思路：

本题可以使用动态规划来解决。

首先，我们可以将 n 分解成若干个质数的乘积，例如 12 = 2 * 2 * 3。

对于每个质数 p，我们可以将其分解成若干个因子 p = p1 * p2 * ... * pk，其中 p1, p2, ..., pk 都是质数。那么，我们可以将 n 分解成若干个因子的乘积，例如 12 = 2 * 2 * 3 = (2 * 2) * 3 = 2 * (2 * 3)。

对于每个因子 p，我们可以使用 Copy All 和 Paste 操作来得到 p 个 'A'，需要的操作次数为 p。

对于每个质数 p，我们可以使用上述方法得到其所有因子的最小操作次数，然后取最小值即可。

例如，对于质数 2，其所有因子为 1, 2, 4, 8, ...，需要的操作次数分别为 0, 2, 4, 6, ...，取最小值为 4。

最终，我们可以将 n 分解成若干个质数的乘积，然后将每个质数的最小操作次数相加即可得到答案。

解决方案：

```go
func minSteps(n int) int {
    if n == 1 {
        return 0
    }
    // 分解质因数
    factors := make([]int, 0)
    for i := 2; i <= n; i++ {
        for n % i == 0 {
            factors = append(factors, i)
            n /= i
        }
    }
    // 计算每个质因数的最小操作次数
    ans := 0
    for _, factor := range factors {
        ans += factor
    }
    return ans
}
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(logn)。