题目编号：465

题目：最优账单平衡

难度：困难

考察范围：贪心算法、动态规划

题干：

假设你是一位银行家，主要业务是提供资金流转服务。客户会在你这里开设账户，存入或取出一定数量的资金。每个客户的账户都有一个初始余额 balance ，并且支持下列两种操作：

- 账户间转账，如果客户 A 的账户余额为 x，客户 B 的账户余额为 y，客户 A 向客户 B 转账 z 元后，A 的账户余额变成 x - z ，B 的账户余额变成 y + z ，其中 z 要么为正整数，要么为负整数；
- 客户提出申请，要求将账户余额变为零。

在所有客户提出申请之后，不允许执行任何转账操作。请判断是否能够通过一系列的转账操作后，使得每个客户的账户余额变为零。

示例 1：

输入：[[0,1,10],[2,0,5]]
输出：true
解释：
Tansfer #1: 1 -> 0  10
Transfer #2: 2 -> 0  5
总共转账 15 ，客户 0 的账户余额变为 -15 ，客户 1 的账户余额变为 0 ，客户 2 的账户余额变为 0 。

示例 2：

输入：[[0,1,10],[1,0,1],[1,2,5],[2,0,5]]
输出：false
解释：
Transfer #1: 1 -> 0  10
Transfer #2: 0 -> 1  1
Transfer #3: 1 -> 2  5
Transfer #4: 2 -> 0  5
总共转账 21 ，客户 0 的账户余额变为 -16 ，客户 1 的账户余额变为 -4 ，客户 2 的账户余额变为 20 。
因此，我们无法满足所有客户的要求。

解题思路：

本题可以使用贪心算法或者动态规划来解决。

贪心算法思路：

首先，我们可以将所有的转账记录进行合并，得到每个客户的总收入和总支出。如果总收入等于总支出，那么说明所有客户的账户余额可以变为零，返回 true。否则，返回 false。

动态规划思路：

我们可以将每个客户的账户余额看作一个状态，使用动态规划来解决。具体来说，我们可以使用一个二进制数来表示每个客户的账户余额，其中二进制数的第 i 位表示第 i 个客户的账户余额是否为零。例如，如果二进制数为 1010，那么第 1 个客户和第 3 个客户的账户余额为零，第 2 个客户和第 4 个客户的账户余额不为零。

我们可以使用一个数组 dp 来表示每个状态是否可以通过一系列的转账操作变为全零状态。具体来说，dp[i] 表示二进制数为 i 的状态是否可以通过一系列的转账操作变为全零状态。初始时，dp[0] = true，表示全零状态可以通过一系列的转账操作变为全零状态。然后，我们枚举所有的转账记录，对于每个转账记录 (u, v, w)，如果二进制数为 i 的状态可以通过一系列的转账操作变为全零状态，并且 u 和 v 的账户余额不为零，那么我们可以将状态 i 转移到状态 i ^ (1 << u) ^ (1 << v)，其中 ^ 表示按位异或运算符，表示将二进制数 i 和 (1 << u) 和 (1 << v) 的二进制位进行异或运算。例如，如果 i = 1010，u = 1，v = 3，那么 i ^ (1 << u) ^ (1 << v) = 0100，表示第 2 个客户的账户余额变为零，第 4 个客户的账户余额变为 10。

最终，如果 dp[(1 << n) - 1] = true，那么说明全零状态可以通过一系列的转账操作变为全零状态，返回 true。否则，返回 false。

解决方案：

贪心算法解决方案：

```go
func balanceTransfers(transactions [][]int) bool {
    balance := make(map[int]int)
    for _, t := range transactions {
        balance[t[0]] -= t[2]
        balance[t[1]] += t[2]
    }
    var b []int
    for _, v := range balance {
        if v != 0 {
            b = append(b, v)
        }
    }
    n := len(b)
    if n == 0 {
        return true
    }
    if n == 1 {
        return false
    }
    sort.Ints(b)
    if b[0] > 0 {
        return false
    }
    if b[n-1] < 0 {
        return false
    }
    i, j := 0, n-1
    for i < j {
        if b[i]+b[j] == 0 {
            i++
            j--
        } else if b[i]+b[j] > 0 {
            j--
        } else {
            i++
        }
    }
    return i == j && b[i] == 0
}
```

动态规划解决方案：

```go
func balanceTransfers(transactions [][]int) bool {
    balance := make(map[int]int)
    for _, t := range transactions {
        balance[t[0]] -= t[2]
        balance[t[1]] += t[2]
    }
    var b []int
    for _, v := range balance {
        if v != 0 {
            b = append(b, v)
        }
    }
    n := len(b)
    if n == 0 {
        return true
    }
    if n == 1 {
        return false
    }
    dp := make([]bool, 1<<n)
    dp[0] = true
    for i := 1; i < 1<<n; i++ {
        for j := 0; j < n; j++ {
            if i&(1<<j) != 0 {
                for k := 0; k < j; k++ {
                    if i&(1<<k) != 0 {
                        if b[j]+b[k] == 0 {
                            dp[i] = dp[i] || dp[i^(1<<j)^(1<<k)]
                        }
                    }
                }
            }
        }
    }
    return dp[(1<<n)-1]
}
```

算法复杂度：

贪心算法的时间复杂度为 O(nlogn)，其中 n 是转账记录的数量。排序的时间复杂度为 O(nlogn)，双指针的时间复杂度为 O(n)。

动态规划的时间复杂度为 O(3^n * n^2)，其中 n 是客户的数量。状态总数为 2^n，转移的时间复杂度为 O(n^2)。空间复杂度为 O(2^n)。