题目编号：375

题目：猜数字大小 II

难度：中等

考察范围：动态规划

题干：我们正在玩一个猜数游戏，游戏规则如下：
我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。
每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。
然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。
直到你猜到我选的数字，你才算赢得了这个游戏。
给定一个范围为 [1, n] 的整数，你的任务是确定你需要支付的最小现金数，确保在游戏中能够赢得最多的钱。

解题思路：动态规划

对于这道题，我们可以使用动态规划来解决。

我们定义 dp[i][j] 表示在区间 [i, j] 中猜数字需要的最小现金数。

对于每一个区间 [i, j]，我们可以枚举其中的每一个数 k，然后计算在猜 k 的情况下需要的最小现金数。

因为我们不知道 k 是否是正确答案，所以我们需要考虑两种情况：

1. 如果 k 是正确答案，那么我们需要支付 k 的现金，然后继续猜数字，这个时候我们需要考虑区间 [i, k-1] 和区间 [k+1, j]，因为我们已经猜对了，所以需要取两个区间中需要的最小现金数的最大值，即 max(dp[i][k-1], dp[k+1][j])。

2. 如果 k 不是正确答案，那么我们需要支付 k 的现金，然后继续猜数字，这个时候我们只需要考虑区间 [i, k-1] 和区间 [k+1, j]，因为我们猜错了，所以需要取两个区间中需要的最小现金数的最小值，即 min(dp[i][k-1], dp[k+1][j])。

最后，我们需要在所有可能的 k 中取需要的最小现金数的最小值，即 min(dp[i][j])。

解决方案：

```go
func getMoneyAmount(n int) int {
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for len := 2; len <= n; len++ {
        for i := 1; i <= n-len+1; i++ {
            j := i + len - 1
            dp[i][j] = math.MaxInt32
            for k := i; k <= j; k++ {
                dp[i][j] = min(dp[i][j], k+max(dp[i][k-1], dp[k+1][j]))
            }
        }
    }
    return dp[1][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。