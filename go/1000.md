题目编号：1000

题目：合并石头的最低成本

难度：困难

考察范围：动态规划、贪心算法

题干：

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

解题思路：

这是一道经典的动态规划问题，但是状态转移方程比较难想。

首先，我们可以先考虑只有两堆石头的情况，假设这两堆石头的数量分别为 a 和 b，那么它们合并的成本为 a+b。但是，如果我们再加入一堆石头 c，那么它们的合并顺序就有两种情况：先合并 a 和 b，再合并 c 和 (a+b)；或者先合并 b 和 c，再合并 a 和 (b+c)。这两种情况的成本分别为 a+b+c 和 b+c+a，显然是相等的。

因此，我们可以得到一个结论：对于任意一组石头，无论它们的合并顺序如何，最终的成本都是相等的。

接下来，我们考虑如何将这个结论应用到动态规划中。我们定义 dp[i][j] 表示将第 i 到 j 堆石头合并成一堆的最低成本。显然，当 i=j 时，dp[i][j]=0，因为只有一堆石头不需要合并。

当 i<j 时，我们可以枚举最后一次合并的位置 k，其中 i<=k<j。假设第 i 到 k 堆石头已经合并成了一堆，成本为 dp[i][k]，第 k+1 到 j 堆石头已经合并成了一堆，成本为 dp[k+1][j]，那么将这两堆石头合并的成本为 sum[i][j]，其中 sum[i][j] 表示第 i 到 j 堆石头的总数。

因此，我们可以得到状态转移方程：

dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[i][j])，其中 i<=k<j

最终的答案为 dp[1][n]，其中 n 表示石头的总数。

解决方案：

```go
func mergeStones(stones []int, K int) int {
    n := len(stones)
    if (n-1)%(K-1) != 0 {
        return -1
    }

    // 前缀和
    prefixSum := make([]int, n+1)
    for i := 1; i <= n; i++ {
        prefixSum[i] = prefixSum[i-1] + stones[i-1]
    }

    // dp[i][j] 表示将第 i 到 j 堆石头合并成一堆的最低成本
    dp := make([][]int, n+1)
    for i := 1; i <= n; i++ {
        dp[i] = make([]int, n+1)
    }

    // 枚举区间长度
    for len := K; len <= n; len++ {
        // 枚举区间起点
        for i := 1; i+len-1 <= n; i++ {
            j := i+len-1
            dp[i][j] = math.MaxInt32
            // 枚举最后一次合并的位置
            for k := i; k < j; k += K-1 {
                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j])
            }
            // 如果区间长度正好为 K，还需要加上区间内所有石头的总数
            if (len-1)%(K-1) == 0 {
                dp[i][j] += prefixSum[j]-prefixSum[i-1]
            }
        }
    }

    return dp[1][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。