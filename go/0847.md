题目编号：847

题目：访问所有节点的最短路径

难度：困难

考察范围：图、广度优先搜索、状态压缩

题干：

给出 graph 为一个含有 n 个节点（编号为 0～n-1）的无向连通图。 

给出 start 和 end 分别表示你的起始和目标节点。 

现在请你找出一条从起始节点到目标节点的最短路径，每一步的操作是任意一个节点（包括起点和终点）跳到它的任意邻居节点中的一个。

我们约定跳到任意一个邻居节点都算作一次移动操作。

返回最短路径的长度。如果不存在从 start 到 end 的路径，请返回 -1 。

解题思路：

本题是一道图论问题，需要求出从起点到终点的最短路径。由于每一步可以跳到任意一个邻居节点中的一个，因此可以使用广度优先搜索（BFS）来解决。

在 BFS 中，我们需要记录每个节点的状态，即是否已经访问过。由于本题中节点数较多，因此需要使用状态压缩来记录每个节点的状态。具体来说，可以使用一个二进制数来表示当前已经访问过的节点，其中第 i 位为 1 表示第 i 个节点已经访问过，为 0 表示未访问过。

在 BFS 中，我们需要维护一个队列，用于存储当前已经访问过的节点以及它们的状态。初始时，队列中只包含起点和起点的状态。每次从队列中取出一个节点以及它的状态，然后遍历它的所有邻居节点，如果邻居节点的状态未被访问过，则将邻居节点以及它的状态加入队列中。如果邻居节点的状态已经被访问过，则忽略该节点。

当队列为空时，表示已经遍历完所有可能的路径，此时如果还没有找到终点，则说明不存在从起点到终点的路径，返回 -1。否则，返回最短路径的长度。

解决方案：

```go
func shortestPathLength(graph [][]int) int {
    n := len(graph)
    type tuple struct{ u, mask, dist int }
    q := []tuple{}
    seen := make([][]bool, n)
    for i := range seen {
        seen[i] = make([]bool, 1<<n)
        seen[i][1<<i] = true
        q = append(q, tuple{i, 1 << i, 0})
    }

    for {
        t := q[0]
        q = q[1:]
        if t.mask == 1<<n-1 {
            return t.dist
        }
        // 搜索相邻的节点
        for _, v := range graph[t.u] {
            maskV := t.mask | 1<<v
            if !seen[v][maskV] {
                q = append(q, tuple{v, maskV, t.dist + 1})
                seen[v][maskV] = true
            }
        }
    }
}

```

算法复杂度：时间复杂度为 O(n * 2^n)，空间复杂度为 O(n * 2^n)。其中 n 表示节点数。