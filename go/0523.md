题目编号：523

题目：连续的子数组和

难度：中等

考察范围：前缀和、哈希表

题干：

给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

示例 1:

输入: [23,2,4,6,7], k = 6
输出: True
解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。

示例 2:

输入: [23,2,6,4,7], k = 6
输出: True
解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。

说明:

数组的长度不会超过10,000。
你可以认为所有数字总和在 32 位有符号整数范围内。

解题思路：

本题可以使用前缀和和哈希表来解决。

首先，我们可以用前缀和来计算数组中每个位置的前缀和，即从数组开头到当前位置的和。然后，我们可以枚举每个子数组的起始位置和结束位置，计算这个子数组的和。如果这个子数组的和是 k 的倍数，那么我们就找到了一个符合要求的子数组。

但是，这种方法的时间复杂度是 O(n^2)，会超时。因此，我们需要优化这个算法。

我们可以用哈希表来记录每个前缀和模 k 的余数第一次出现的位置。如果我们找到了两个前缀和模 k 的余数相同的位置 i 和 j，那么说明从位置 i 到位置 j 的子数组的和是 k 的倍数。因为这个子数组的和可以表示为 (sum[j] - sum[i-1]) % k，而 (sum[j] - sum[i-1]) % k = 0。

解决方案：

```go
func checkSubarraySum(nums []int, k int) bool {
    n := len(nums)
    if n < 2 {
        return false
    }
    mp := map[int]int{0: -1}
    remainder := 0
    for i, num := range nums {
        remainder = (remainder + num) % k
        if prevIndex, has := mp[remainder]; has {
            if i-prevIndex >= 2 {
                return true
            }
        } else {
            mp[remainder] = i
        }
    }
    return false
}
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(min(n,k))。