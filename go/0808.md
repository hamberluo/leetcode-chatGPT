题目编号：808

题目：分汤

难度：中等

考察范围：递归、动态规划

题干：

有 A 和 B 两个容器，容量分别为 `x` 升和 `y` 升。每个容器都以某种颜色填充，A 容器为红色，B 容器为绿色。

开始时，我们用一些红色液体和绿色液体填充了容器。

当两个容器中的颜色相同时，我们可以执行以下操作：

把 A 中的一些液体倒入 B 中，使 B 容器恰好填满。
把 B 中的一些液体倒入 A 中，使 A 容器恰好填满。
重复以上操作任意次。
假设我们从 A 和 B 中都至少取出了一些液体，则当存在一些容器被恰好填满时，我们称这些容器是半满的。

返回能够使两个容器半满的操作序列的最小数量，如果无法做到，则返回 -1。

解题思路：

本题可以使用递归或者动态规划来解决。

递归思路：

我们可以将两个容器的状态表示为 `(a, b)`，其中 `a` 表示 A 容器中红色液体的数量，`b` 表示 B 容器中绿色液体的数量。

我们可以定义一个递归函数 `dfs(a, b)`，表示从 `(a, b)` 开始，能否通过一系列操作使得两个容器都恰好填满。

在递归函数中，我们可以枚举每一步操作：

将 A 中的一些液体倒入 B 中，使 B 容器恰好填满。
将 B 中的一些液体倒入 A 中，使 A 容器恰好填满。
如果两个容器中的颜色相同，我们可以执行上述两种操作中的任意一种。
如果两个容器中的颜色不同，我们无法进行任何操作。
如果两个容器都恰好填满了，我们就找到了一种可行的操作序列，返回 0。
如果我们已经进行了 `k` 步操作，但两个容器都没有恰好填满，那么我们就无法再进行操作了，返回一个很大的数。

动态规划思路：

我们可以将两个容器的状态表示为 `(a, b)`，其中 `a` 表示 A 容器中红色液体的数量，`b` 表示 B 容器中绿色液体的数量。

我们可以定义一个二维数组 `dp`，其中 `dp[i][j]` 表示从 `(i, j)` 开始，能否通过一系列操作使得两个容器都恰好填满。

在动态规划中，我们可以枚举每一步操作：

将 A 中的一些液体倒入 B 中，使 B 容器恰好填满。
将 B 中的一些液体倒入 A 中，使 A 容器恰好填满。
如果两个容器中的颜色相同，我们可以执行上述两种操作中的任意一种。
如果两个容器中的颜色不同，我们无法进行任何操作。
如果两个容器都恰好填满了，我们就找到了一种可行的操作序列，`dp[i][j]` 设为 0。
如果我们已经进行了 `k` 步操作，但两个容器都没有恰好填满，那么我们就无法再进行操作了，`dp[i][j]` 设为一个很大的数。

最终，我们只需要返回 `dp[x][y]` 即可。

解决方案：

递归解法：

```go
func soupServings(n int) float64 {
    if n >= 4800 {
        return 1.0
    }
    memo := make(map[[2]int]float64)
    return dfs(n, n, memo)
}

func dfs(a, b int, memo map[[2]int]float64) float64 {
    if a <= 0 && b <= 0 {
        return 0.5
    }
    if a <= 0 {
        return 1.0
    }
    if b <= 0 {
        return 0.0
    }
    if v, ok := memo[[2]int{a, b}]; ok {
        return v
    }
    memo[[2]int{a, b}] = 0.25 * (dfs(a-100, b, memo) + dfs(a-75, b-25, memo) + dfs(a-50, b-50, memo) + dfs(a-25, b-75, memo))
    return memo[[2]int{a, b}]
}
```

动态规划解法：

```go
func soupServings(n int) float64 {
    if n >= 4800 {
        return 1.0
    }
    n = (n + 24) / 25
    dp := make([][]float64, n+1)
    for i := range dp {
        dp[i] = make([]float64, n+1)
    }
    dp[0][0] = 0.5
    for i := 1; i <= n; i++ {
        dp[0][i] = 1.0
        dp[i][0] = 0.0
    }
    for i := 1; i <= n; i++ {
        for j := 1; j <= n; j++ {
            dp[i][j] = 0.25 * (dp[max(i-4, 0)][j] + dp[max(i-3, 0)][max(j-1, 0)] + dp[max(i-2, 0)][max(j-2, 0)] + dp[max(i-1, 0)][max(j-3, 0)])
        }
    }
    return dp[n][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

算法复杂度：

递归解法：

- 时间复杂度：O(n^2)，其中 n 表示题目中的 n。
- 空间复杂度：O(n^2)。

动态规划解法：

- 时间复杂度：O(n^2)，其中 n 表示题目中的 n。
- 空间复杂度：O(n^2)。