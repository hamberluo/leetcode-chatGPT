题目编号：842

题目：将数组拆分成斐波那契序列

难度：中等

考察范围：回溯算法、字符串处理

题干：

给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。

形式上，斐波那契式序列是一个非负整数列表 F，且满足：

0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；
F.length >= 3；
对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。
另外，注意：可以认为斐波那契式序列中不含有任何前导零，且不能使用 2^31 - 1 作为其中一个元素。

给定一个形如 "123456579" 的数字字符串，写一个函数，以字符串形式返回所有可能的斐波那契式序列，顺序为：

[123, 456, 579]
[123, 579, 702]
解题思路：

这道题可以使用回溯算法来解决。回溯算法的基本思路是：从第一个数开始，枚举所有可能的数，然后递归到下一个数，直到找到符合条件的序列或者无法继续递归为止。

具体来说，我们可以从第一个数开始枚举所有可能的数，然后递归到下一个数。在递归到下一个数的时候，我们需要判断当前的数是否符合斐波那契数列的定义，如果符合，则继续递归，否则回溯到上一个数，继续枚举下一个数。

在实现的时候，我们可以使用两个指针 i 和 j 来表示当前序列的起始位置和结束位置，以及一个数组 res 来保存符合条件的序列。在递归的过程中，我们需要记录当前序列的和 sum，以及上一个数 prev，以便于判断当前数是否符合斐波那契数列的定义。

解决方案：

func splitIntoFibonacci(S string) []int {
    res := []int{}
    backtrack(S, &res, 0, 0, 0)
    return res
}

func backtrack(S string, res *[]int, i, sum, prev int) bool {
    if i == len(S) {
        return len(*res) > 2
    }
    num := 0
    for j := i; j < len(S); j++ {
        if j > i && S[i] == '0' {
            break
        }
        num = num*10 + int(S[j]-'0')
        if num > math.MaxInt32 {
            break
        }
        if len(*res) >= 2 {
            if num < sum {
                continue
            } else if num > sum {
                break
            }
        }
        *res = append(*res, num)
        if backtrack(S, res, j+1, prev+num, num) {
            return true
        }
        *res = (*res)[:len(*res)-1]
    }
    return false
}

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。其中 n 是字符串 S 的长度。