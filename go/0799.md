题目编号：799

题目：香槟塔

难度：中等

考察范围：动态规划

题干：

我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，依此类推。（如果最底层的玻璃杯满了，就会将多余的香槟流出去。）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放了一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯：顶层的一个和第二层的两个，但只有一半的香槟倒入了第三层的玻璃杯中。

当倾倒了对应杯数的香槟后，第i行第j个玻璃杯所盛放的香槟量为glass[i][j]。

请你返回顶层满杯的那一杯香槟所在的位置，即[full_row,full_glass]。如果顶层满杯的玻璃杯在最后一行，返回[-1,-1]。

解题思路：

动态规划

我们可以用一个二维数组dp[i][j]表示第i行第j个杯子当前的香槟量，dp[i][j]表示从顶部倒入的香槟量，dp[i][j]的值只有可能是0或1，表示这个杯子是否被倒入过香槟。

对于第i行第j个杯子，它的香槟来源只有两个：它正上方的杯子和它左上方的杯子，因此我们可以得到状态转移方程：

dp[i][j] = (dp[i-1][j-1]-1)/2 + (dp[i-1][j]-1)/2

其中，(dp[i-1][j-1]-1)/2表示从左上方的杯子倒入的香槟量，(dp[i-1][j]-1)/2表示从正上方的杯子倒入的香槟量，因为每个杯子最多只能盛放250ml的香槟，所以需要减去1再除以2。

最后，我们只需要从顶部开始倒入香槟，按照上述状态转移方程更新dp数组，直到顶部的杯子满了为止，此时dp[0][0]的值为1，我们就可以得到满杯的位置。

解决方案：

```go
func champagneTower(poured int, query_row int, query_glass int) float64 {
    dp := make([][]float64, 101)
    for i := range dp {
        dp[i] = make([]float64, i+1)
    }
    dp[0][0] = float64(poured)
    for i := 0; i < 100; i++ {
        for j := 0; j <= i; j++ {
            if dp[i][j] > 1 {
                dp[i+1][j] += (dp[i][j] - 1) / 2
                dp[i+1][j+1] += (dp[i][j] - 1) / 2
                dp[i][j] = 1
            }
        }
    }
    if dp[query_row][query_glass] > 1 {
        return 1
    }
    return dp[query_row][query_glass]
}
```

算法复杂度：时间复杂度O(n^2)，空间复杂度O(n^2)。其中n为金字塔的层数。