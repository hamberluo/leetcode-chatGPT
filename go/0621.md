题目编号：621

题目：任务调度器

难度：中等

考察范围：贪心算法

题干：

给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写字母 A - Z 表示的 26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个相同种类的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的最短时间。

示例 1：

输入: tasks = ["A","A","A","B","B","B"], n = 2
输出: 8
执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.

解题思路：

贪心算法

我们可以先统计出每个任务出现的次数，然后按照出现次数从大到小排序。在排序后的序列中，我们按照贪心策略，每次选择出现次数最多的任务执行，直到所有任务都被执行完毕。

在执行任务的过程中，我们需要记录当前时间以及每个任务的冷却时间。具体来说，对于每个任务，我们记录其最后一次执行的时间 last，以及当前需要等待的冷却时间。在选择任务时，我们选择所有未完成的任务中，冷却时间最短的那个任务，并将其冷却时间更新为 n+1。

解决方案：

```go
func leastInterval(tasks []byte, n int) int {
    freq := make([]int, 26)
    for _, ch := range tasks {
        freq[ch-'A']++
    }
    sort.Ints(freq)
    maxExec, maxExecCnt := freq[25], 1
    for i := 24; i >= 0 && freq[i] == maxExec; i-- {
        maxExecCnt++
    }
    return max((maxExec-1)*(n+1)+maxExecCnt, len(tasks))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

算法复杂度：时间复杂度为 O(nlogn)，其中 n 是数组 tasks 的长度。排序的时间复杂度为 O(26log26)=O(1)，for 循环的时间复杂度为 O(n)，因此总时间复杂度为 O(nlogn)。空间复杂度为 O(1)。