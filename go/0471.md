题目编号：471

题目：编码最短长度的字符串

难度：困难

考察范围：动态规划、字符串处理

题干：

给定一个非空字符串，将其编码为其最短长度的字符串。

编码规则是将字符串分解为子字符串，其中每个子字符串的重复次数大于等于2时，将其替换为重复次数和该子字符串的组合。例如，字符串 "aabaaa" 可以被编码为 "2[aab]3[a]"，但不是 "aabaa"，因为 "aabaa" 可以被编码为 "a2[b]a"，其中 "b" 为字符串 "aa"。

注意，编码的字符串不应包含任何未编码的字符串。

解题思路：

本题可以使用动态规划来解决。我们可以定义状态 dp[i][j] 表示从字符串的第 i 个位置开始，长度为 j 的子串的最短编码长度。状态转移方程如下：

dp[i][j] = min(dp[i][j], dp[i][k] + dp[i+k][j-k])，其中 k ∈ [1, j-1]，且 j % k == 0。

这个方程的意思是，我们枚举子串的长度 k，然后将长度为 j 的子串分为两个部分，分别是长度为 k 的子串和长度为 j-k 的子串。如果长度为 k 的子串可以被重复多次得到长度为 j 的子串，那么我们就可以将长度为 j 的子串编码为重复次数和长度为 k 的子串的组合，其编码长度为 dp[i][k] + 2 + len(str(j/k)) + dp[i+k][j-k]，其中 2 表示左右括号的长度，len(str(j/k)) 表示重复次数的长度。我们需要枚举所有的 k，然后取最小值作为 dp[i][j] 的值。

最终的答案就是 dp[0][n]，其中 n 是字符串的长度。

解决方案：

```go
func encode(s string) string {
    n := len(s)
    dp := make([][]string, n)
    for i := range dp {
        dp[i] = make([]string, n+1)
        for j := range dp[i] {
            dp[i][j] = s[i:i+j]
        }
    }
    for l := 2; l <= n; l++ {
        for i := 0; i+l <= n; i++ {
            j := i + l
            for k := i+1; k < j; k++ {
                if l % (j-k) == 0 && dp[i][k] == dp[j-k][l-(j-k)] {
                    dp[i][l] = fmt.Sprintf("%d[%s]", l/(j-k), dp[i][k])
                    break
                }
                if len(dp[i][l]) > len(dp[i][k])+len(dp[j-k][l-(j-k)]) {
                    dp[i][l] = dp[i][k] + dp[j-k][l-(j-k)]
                }
            }
        }
    }
    return dp[0][n]
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。