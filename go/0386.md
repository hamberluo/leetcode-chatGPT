题目编号：386

题目：字典序排数

难度：中等

考察范围：递归、字典序

题干：

给定一个整数 n, 返回从 1 到 n 的字典顺序。

例如，

给定 n = 13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9]。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 同样会确保合法，输入的数据 n 的范围在 [1, 5 * 10^4]。

解题思路：

题目要求按照字典序排列从1到n的所有数字，可以将其看作一棵树，从1开始，每个节点的子节点是该节点乘以10和该节点加1，直到节点大于n为止。然后对这棵树进行先序遍历，即可得到答案。

解决方案：

```go
func lexicalOrder(n int) []int {
    res := make([]int, 0, n)
    for i := 1; i <= 9; i++ {
        dfs(i, n, &res)
    }
    return res
}

func dfs(cur, n int, res *[]int) {
    if cur > n {
        return
    }
    *res = append(*res, cur)
    for i := 0; i <= 9; i++ {
        dfs(cur*10+i, n, res)
    }
}
```

算法复杂度：时间复杂度为O(n)，空间复杂度为O(n)。