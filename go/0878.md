题目编号：878

题目：第 N 个神奇数字

难度：困难

考察范围：数学、二分查找

题干：

如果正整数可以被 A 或 B 整除，那么它是神奇的。

返回第 N 个神奇数字。由于答案可能非常大，返回它模 10^9 + 7 的结果。

示例 1：

输入：N = 1, A = 2, B = 3
输出：2

示例 2：

输入：N = 4, A = 2, B = 3
输出：6

示例 3：

输入：N = 5, A = 2, B = 4
输出：10

示例 4：

输入：N = 3, A = 6, B = 4
输出：8

提示：

1 <= N <= 10^9
2 <= A <= 40000
2 <= B <= 40000

解题思路：

本题可以使用二分查找来解决。

首先，我们可以发现，第 N 个神奇数字一定是在 [1, A * B] 的范围内的。因此，我们可以使用二分查找来找到第 N 个神奇数字。

对于一个数 mid，我们可以计算出在 [1, mid] 范围内有多少个神奇数字。具体来说，我们可以计算出在 [1, mid] 范围内有多少个数可以被 A 整除，多少个数可以被 B 整除，以及多少个数可以同时被 A 和 B 整除。然后，我们可以使用容斥原理来计算出在 [1, mid] 范围内有多少个神奇数字。

如果在 [1, mid] 范围内有 k 个神奇数字，那么我们可以比较 k 和 N 的大小关系，来决定下一步搜索的范围。具体来说，如果 k < N，那么第 N 个神奇数字一定在 [mid+1, right] 的范围内；如果 k >= N，那么第 N 个神奇数字一定在 [left, mid] 的范围内。

解决方案：

```go
func nthMagicalNumber(N int, A int, B int) int {
    mod := int(1e9 + 7)
    lcm := A * B / gcd(A, B)
    left, right := 1, int(1e15)
    for left < right {
        mid := (left + right) / 2
        if mid/A+mid/B-mid/lcm < N {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left % mod
}

func gcd(a, b int) int {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}
```

算法复杂度：时间复杂度为 O(logN)，空间复杂度为 O(1)。