题目编号：552

题目：学生出勤记录 II

难度：困难

考察范围：动态规划

题干：

给定一个正整数 n，表示该学生的出勤记录的长度为 n。正整数 m 表示该学生最多缺席 m 次课程。出勤记录是一个字符串，记录了该学生的出勤情况，其中 ‘A’ 表示缺席一次课程，‘L’ 表示该学生在这一天是到场状态，‘P’ 表示该学生在这一天是缺席状态。

如果该学生的出勤记录中不超过 m 次缺席，并且不存在 连续 3 天或以上的缺席记录，则称该学生的出勤记录良好。

给定 n 和 m，求出长度为 n 且记录良好的出勤记录的数量。答案可能非常大，所以需要返回它对 10^9 + 7 取模的结果。

解题思路：

本题可以使用动态规划来解决。

定义 dp[i][j][k] 表示前 i 天中，缺席了 j 次，结尾连续有 k 个 ‘L’ 的出勤记录的数量。

对于第 i 天，有以下三种情况：

1. 该学生出席了当天的课程，即 s[i] = ‘P’：

    dp[i][j][0] = (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]) % mod

    dp[i][j+1][0] = (dp[i-1][j+1][0] + dp[i-1][j+1][1] + dp[i-1][j+1][2]) % mod

2. 该学生缺席了当天的课程，即 s[i] = ‘A’：

    dp[i][j][0] = (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]) % mod

    dp[i][j+1][0] = (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]) % mod

3. 该学生迟到了当天的课程，即 s[i] = ‘L’：

    dp[i][j][k] = (dp[i-1][j][k-1] + dp[i-1][j][k]) % mod

其中，mod 为取模数，本题要求对 10^9 + 7 取模。

最终答案为 dp[n][m][0] + dp[n][m][1] + dp[n][m][2]。

解决方案：

```go
func checkRecord(n int) int {
    mod := int(1e9 + 7)
    dp := make([][][]int, n+1)
    for i := range dp {
        dp[i] = make([][]int, 2)
        for j := range dp[i] {
            dp[i][j] = make([]int, 3)
        }
    }
    dp[0][0][0] = 1
    for i := 1; i <= n; i++ {
        // 该学生出席了当天的课程
        dp[i][0][0] = (dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % mod
        dp[i][0][1] = dp[i-1][0][0]
        dp[i][0][2] = dp[i-1][0][1]
        // 该学生缺席了当天的课程
        dp[i][1][0] = (dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2] + dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % mod
        dp[i][1][1] = dp[i-1][1][0]
        dp[i][1][2] = dp[i-1][1][1]
        // 该学生迟到了当天的课程
        dp[i][0][0] = (dp[i][0][0] + dp[i-1][0][0]) % mod
        dp[i][0][1] = (dp[i][0][1] + dp[i-1][0][1]) % mod
        dp[i][0][2] = (dp[i][0][2] + dp[i-1][0][2]) % mod
        dp[i][1][0] = (dp[i][1][0] + dp[i-1][1][0]) % mod
        dp[i][1][1] = (dp[i][1][1] + dp[i-1][1][1]) % mod
        dp[i][1][2] = (dp[i][1][2] + dp[i-1][1][2]) % mod
    }
    ans := 0
    for i := 0; i < 2; i++ {
        for j := 0; j < 3; j++ {
            ans = (ans + dp[n][i][j]) % mod
        }
    }
    return ans
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。