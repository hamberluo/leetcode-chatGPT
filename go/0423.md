题目编号：423

题目：从英文中重建数字

难度：中等

考察范围：字符串、哈希表

题干：给定一个非空字符串，其中包含从 0 到 9 的数字，但是某些数字重复了多次。给定这些重复数字的字符串，你的任务是将它们重新排列，使得他们组成的数字最小，但是必须保证输出的数字不含有任何前导零。

解题思路：由于数字的顺序是按照字母顺序排列的，因此我们可以根据每个数字出现的次数来确定数字的顺序。具体来说，我们可以按照下面的顺序确定每个数字的出现次数：

- 0 的个数
- 1 的个数
- 2 的个数
- 3 的个数
- 4 的个数
- 5 的个数
- 6 的个数
- 7 的个数
- 8 的个数
- 9 的个数

然后我们就可以根据每个数字出现的次数来构造最小的数字了。

解决方案：

```go
func originalDigits(s string) string {
    // 统计每个数字出现的次数
    count := make([]int, 10)
    for i := 0; i < len(s); i++ {
        switch s[i] {
        case 'z':
            count[0]++
        case 'w':
            count[2]++
        case 'u':
            count[4]++
        case 'x':
            count[6]++
        case 'g':
            count[8]++
        case 'o':
            count[1]++ // 1 和 0 都包含 o，因此需要先统计 1 的个数
        case 't':
            count[3]++ // 3 和 8 都包含 t，因此需要先统计 3 的个数
        case 'f':
            count[5]++ // 5 和 4 都包含 f，因此需要先统计 5 的个数
        case 's':
            count[7]++ // 7 和 6 都包含 s，因此需要先统计 7 的个数
        case 'i':
            count[9]++ // 9、8 和 5 都包含 i，因此需要先统计 9 的个数
        }
    }
    // 构造最小的数字
    res := ""
    for i := 0; i < 10; i++ {
        for j := 0; j < count[i]; j++ {
            res += strconv.Itoa(i)
        }
    }
    return res
}
```

算法复杂度：时间复杂度为 O(n)，其中 n 是字符串 s 的长度。空间复杂度为 O(1)，因为 count 数组的长度是固定的。