题目编号：903

题目：DI 序列的有效排列

难度：困难

考察范围：动态规划

题干：

我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）

有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：

如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；
如果 S[i] == 'I'，那么 P[i] < P[i+1]。
如同答案一样，P 数组由 [0, 1, ..., n] 中的每个整数出现恰好一次。


给定一个有效字符串 S，考虑其所有可能的有效排列。

如果存在有效排列，则返回任何一个。

示例 1:

输入："DID"
输出：[2,1,3]
解释：
输出的数组表示为 [2,1,3]，是因为该排列可以构造为字典序最小的有效排列。
 

提示：

1 <= S.length <= 200
S 仅由集合 {'D', 'I'} 中的字符组成。

解题思路：

这道题可以使用动态规划来解决。

我们可以定义一个二维数组 dp，其中 dp[i][j] 表示在已经确定了前 i 个数的情况下，最后一个数为 j 的方案数。

对于每个位置 i，如果 S[i] == 'D'，那么我们需要找到一个比 j 小的数 k，使得 dp[i][j] += dp[i-1][k]。

如果 S[i] == 'I'，那么我们需要找到一个比 j 大的数 k，使得 dp[i][j] += dp[i-1][k]。

最终的答案就是 dp[n][0] + dp[n][1] + ... + dp[n][n]。

解决方案：

```go
func numPermsDISequence(S string) []int {
    n := len(S)
    mod := int(1e9) + 7

    // dp[i][j] 表示在已经确定了前 i 个数的情况下，最后一个数为 j 的方案数
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    // 初始化
    for j := 0; j <= n; j++ {
        dp[0][j] = 1
    }

    // 动态规划
    for i := 1; i <= n; i++ {
        for j := 0; j <= n-i; j++ {
            if S[i-1] == 'D' {
                for k := j; k < i+j; k++ {
                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % mod
                }
            } else {
                for k := 0; k < j; k++ {
                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % mod
                }
            }
        }
    }

    // 计算答案
    ans := make([]int, n+1)
    for j := 0; j <= n; j++ {
        ans[j] = dp[n][j]
    }
    return ans
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。