题目编号：686

题目：重复叠加字符串匹配

难度：简单

考察范围：字符串、双指针

题干：给定两个字符串 A 和 B，寻找重复叠加字符串 A 的最小次数，使得 B 成为叠加后的字符串的子串，如果不存在则返回 -1。

例如，A = "abcd"，B = "cdabcdab"。

答案为 3，因为 A 重复叠加三遍后为 "abcdabcdabcd"，此时 B 是其子串；A 重复叠加两遍后为 "abcdabcd"，此时 B 并不是其子串。

解题思路：双指针

首先，我们可以将 A 重复叠加，直到长度大于等于 B 的长度，然后再判断 B 是否是 A 的子串。如果是，那么重复叠加的次数就是我们要求的最小次数；如果不是，我们再将 A 重复叠加一次，再判断 B 是否是 A 的子串，以此类推，直到 A 的长度大于等于 2B。

在判断子串时，我们可以使用双指针的方法，即用两个指针 i 和 j 分别指向 A 和 B 的开头，然后依次比较 A[i] 和 B[j] 是否相等，如果相等，i 和 j 同时向后移动一位，否则 i 回到上一次匹配的位置的下一位，j 回到 B 的开头。

解决方案：

```go
func repeatedStringMatch(A string, B string) int {
    n, m := len(A), len(B)
    maxLen := n * 2 + m // A 的最大长度
    for i := n; i <= maxLen; i += n {
        if strings.Contains(A, B) {
            return (i + n - 1) / n // 向上取整
        }
        A += A[:n] // A 重复叠加
    }
    return -1
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)，其中 n 为 A 的长度。