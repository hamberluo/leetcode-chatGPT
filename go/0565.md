题目编号：565

题目：数组嵌套

难度：中等

考察范围：数组、贪心算法

题干：一个长度为 n 的数组 nums，其中有一个元素被替换成了另一个元素，导致原数组中存在一个重复元素和一个缺失元素。给定 nums 数组和重复的元素值，找出缺失的元素的值。

解题思路：本题可以使用贪心算法来解决。我们可以将数组看成一个有向图，其中每个元素 nums[i] 指向 nums[nums[i]]。由于有一个元素被替换成了另一个元素，导致原数组中存在一个重复元素和一个缺失元素，因此这个有向图中一定存在一个环。我们可以通过找到这个环来找到缺失的元素。

具体来说，我们可以从任意一个节点开始，沿着有向边走到下一个节点，直到走到一个已经访问过的节点为止。这个过程可以使用快慢指针来实现，即使用两个指针，一个每次走一步，一个每次走两步，直到它们相遇为止。此时，它们相遇的节点一定在环中。接下来，我们可以从相遇的节点开始，再次沿着有向边走到下一个节点，直到回到相遇的节点为止。这个过程中经过的所有节点都在环中。我们可以统计环中节点的个数，然后从任意一个节点开始，沿着有向边走 k 步，就可以回到这个节点，其中 k 是环中节点的个数。接下来，我们从起点开始，同时从上一步到达的节点开始，沿着有向边走，直到两个指针相遇为止。这个相遇的节点就是缺失的元素。

解决方案：

```go
func arrayNesting(nums []int) int {
    n := len(nums)
    visited := make([]bool, n)
    ans := 0
    for i := 0; i < n; i++ {
        if !visited[i] {
            j := i
            cnt := 0
            for !visited[j] {
                visited[j] = true
                j = nums[j]
                cnt++
            }
            ans = max(ans, cnt)
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。其中 n 是数组的长度。