题目编号：823

题目：带因子的二叉树

难度：中等

考察范围：动态规划、树

题干：给出一个含有不重复整数元素的数组，每个整数均大于 1。我们用这些整数来构建二叉树，每个整数可以使用任意次数。

其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

如果值之间的乘积不为整数，我们将使用它的一个近似整数 d 代替，其中 d 的误差应当尽可能小。

例如，数组 [2,3,4] 可以表示为如下二叉树：

```
      24
     /  \
    12   4
   /  \
  6    2
```

给定数组的最大值和最小值之间的数字个数不会超过 1000。

解题思路：动态规划

对于每个节点，我们需要知道它的值以及它的左右子树的所有因子。我们可以使用动态规划来解决这个问题。

我们首先将数组排序，然后对于每个数字，我们找到它的所有因子。对于每个数字 i，我们可以将其分解为两个因子 j 和 i/j，其中 j <= i/j。我们将这些因子存储在一个哈希表中，以便我们可以在之后的节点中使用。

对于每个节点，我们可以使用动态规划来计算它的值和它的所有因子。我们可以使用一个二维数组 dp，其中 dp[i][j] 表示以 i 为根节点，它的值为 j 的所有子树的数量。我们可以使用以下递推式来计算 dp：

dp[i][j] = sum(dp[left][j/x] * dp[right][x])，其中 x 是 j 的因子，left 和 right 分别是 i 的左右子树。

最终答案是所有 dp[i][j] 的和。

解决方案：

```go
func numFactoredBinaryTrees(arr []int) int {
    mod := int(1e9 + 7)
    n := len(arr)
    sort.Ints(arr)
    dp := make(map[int]int)
    for i := 0; i < n; i++ {
        dp[arr[i]] = 1
        for j := 0; j < i; j++ {
            if arr[i]%arr[j] == 0 {
                dp[arr[i]] = (dp[arr[i]] + dp[arr[j]]*dp[arr[i]/arr[j]]) % mod
            }
        }
    }
    ans := 0
    for _, v := range dp {
        ans = (ans + v) % mod
    }
    return ans
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。