题目编号：869

题目：重新排序得到 2 的幂

难度：中等

考察范围：数学、字符串

题干：

给定正整数，我们将其重复写一遍构成一个字符串。例如，给定正整数 1234，我们可以构造它的字符串 "12341234"。

如果某个字符串 s 可以通过将一个正整数重复写两次得到，我们将这个字符串称作可重复。注意，正整数 n 可以表示为一个可重复字符串的形式，当且仅当它满足以下两个条件：

正整数 n 的十进制表示中不存在 0 数字。
存在正整数 x，使得重复写出字符串 x 并将其连接成字符串 s 后，得到的字符串是 n 的表示法。
例如，正整数 120 无法表示成可重复字符串的形式。

给定两个正整数 x 和 y，如果这两个数本身是可重复的，那么请你找出从 x 开始的、第一个可重复字符串表示形式为 y 的正整数。换句话说，如果 x 和 y 的字符串形式相同，那么需要找到最小的满足条件的正整数 n，它可以写成 x^i 的形式（其中 i >= 2 ）且同时也可以写成一个可重复字符串的形式。

如果没有这样的正整数，就请返回 0。

解题思路：

首先，我们可以将 x 和 y 转化为字符串，然后判断它们是否相等。如果相等，我们需要找到最小的满足条件的正整数 n，它可以写成 x^i 的形式（其中 i >= 2 ）且同时也可以写成一个可重复字符串的形式。

我们可以枚举 i，然后计算 x^i 的值，判断它是否可以写成一个可重复字符串的形式。如果可以，就返回这个值。如果枚举完 i 后仍然没有找到符合条件的值，就返回 0。

判断一个字符串是否可以写成一个可重复字符串的形式，可以使用一个哈希表来记录每个字符出现的次数。如果一个字符串可以写成一个可重复字符串的形式，那么它的长度一定是偶数，且每个字符出现的次数都是偶数。

解决方案：

```go
func reorderedPowerOf2(x int) int {
    // 将 x 转化为字符串
    strX := strconv.Itoa(x)
    // 将字符串转化为字符数组
    arrX := []byte(strX)
    // 对字符数组进行排序
    sort.Slice(arrX, func(i, j int) bool {
        return arrX[i] < arrX[j]
    })
    // 枚举 i，计算 x^i 的值，判断它是否可以写成一个可重复字符串的形式
    for i := 0; i < 31; i++ {
        // 计算 x^i 的值
        powerOf2 := 1 << i
        // 将 x^i 转化为字符串
        strPowerOf2 := strconv.Itoa(powerOf2)
        // 如果 x^i 的字符串长度小于 x 的字符串长度，就继续枚举 i
        if len(strPowerOf2) < len(strX) {
            continue
        }
        // 如果 x^i 的字符串长度大于 x 的字符串长度，就退出循环
        if len(strPowerOf2) > len(strX) {
            break
        }
        // 将 x^i 的字符串转化为字符数组
        arrPowerOf2 := []byte(strPowerOf2)
        // 对字符数组进行排序
        sort.Slice(arrPowerOf2, func(i, j int) bool {
            return arrPowerOf2[i] < arrPowerOf2[j]
        })
        // 判断 x^i 的字符串是否可以写成一个可重复字符串的形式
        if bytes.Equal(arrX, arrPowerOf2) {
            return powerOf2
        }
    }
    return 0
}
```

算法复杂度：时间复杂度为 O(log n)，空间复杂度为 O(log n)。其中，n 是 x 的值。