题目编号：351

题目：安卓系统手势解锁

难度：中等

考察范围：回溯算法

题干：

Android 设备中有一个很好玩的应用叫做「手势解锁」，用于解锁设备。

以下是该应用的简介：

```
你现在可以使用一些连接点将这些点连接起来，以解锁屏幕。

每个图案必须至少连接点数目为 4 个，而且连接点不能重复。

给你一个`m x n`的屏幕，其中有一些位置可以通过连接点进行连接，请你计算出有多少种不同的解锁手势。

具体来说，有多少种不同的连接方式，使得连接点的数量至少为`m`，至多为`n`？

答案在对`10^9 + 7`取余的情况下返回。

```

解题思路：

回溯算法

回溯算法是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，而在前面的一些步骤做出一些修改，并重新尝试找到新的候选解。

对于本题，我们可以使用回溯算法来穷举所有可能的解锁手势。具体来说，我们从数字`1`到数字`9`枚举每一个数字是否被使用过，如果一个数字没有被使用过，我们就尝试着将其加入到当前的解锁手势中，并递归地考虑下一个数字是否可以被加入。如果当前的解锁手势长度在规定范围内，我们就将其加入答案中。

需要注意的是，我们需要记录当前数字是否被使用过，以及当前数字和上一个数字之间是否有中间数字，这可以使用一个布尔数组来实现。

解决方案：

```go
func numberOfPatterns(m int, n int) int {
    // 记录数字是否被使用过
    used := make([]bool, 9)
    // 记录中间数字是否被使用过
    mid := make([][]int, 10)
    mid[1] = []int{3}
    mid[2] = []int{6}
    mid[3] = []int{1, 7}
    mid[4] = []int{9}
    mid[5] = []int{}
    mid[6] = []int{2, 8}
    mid[7] = []int{3}
    mid[8] = []int{6}
    mid[9] = []int{4}
    // 记录答案
    res := 0
    // 回溯算法
    var dfs func(int, int)
    dfs = func(cur, count int) {
        if count >= m && count <= n {
            res++
        }
        if count == n {
            return
        }
        for i := 0; i < 9; i++ {
            if !used[i] {
                // 判断中间数字是否被使用过
                if len(mid[cur]) == 0 || used[mid[cur][i/2]] {
                    used[i] = true
                    dfs(i, count+1)
                    used[i] = false
                }
            }
        }
    }
    // 枚举起点
    for i := 0; i < 9; i++ {
        used[i] = true
        dfs(i, 1)
        used[i] = false
    }
    return res
}
```

算法复杂度：时间复杂度为O(9!)，空间复杂度为O(1)。