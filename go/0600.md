题目编号：600

题目：不含连续1的非负整数

难度：简单

考察范围：位运算、动态规划

题干：

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含连续的 1 的个数。

例如，1、3、5 都是小于或等于 5 的非负整数，且它们的二进制表示都不包含连续的 1。

给定 n 的范围为 [0, 10^9]。

解题思路：

本题可以使用动态规划的思想来解决。

我们可以定义两个状态数组：f[i] 表示 i 位二进制数中不包含连续 1 的个数，g[i] 表示 i 位二进制数中包含连续 1 的个数。

对于 f[i]，我们可以分为两种情况来考虑：

- 第 i 位为 0，那么 f[i] = f[i-1] + g[i-1]，因为第 i 位为 0，所以前面一位可以是 0 或 1，所以前面一位的不包含连续 1 的个数为 f[i-1]，前面一位包含连续 1 的个数为 g[i-1]，所以 f[i] = f[i-1] + g[i-1]。
- 第 i 位为 1，那么 f[i] = f[i-1]，因为第 i 位为 1，所以前面一位只能是 0，所以前面一位的不包含连续 1 的个数为 f[i-1]，所以 f[i] = f[i-1]。

对于 g[i]，我们也可以分为两种情况来考虑：

- 第 i 位为 0，那么 g[i] = f[i-1]，因为第 i 位为 0，所以前面一位可以是 0 或 1，所以前面一位的不包含连续 1 的个数为 f[i-1]，所以 g[i] = f[i-1]。
- 第 i 位为 1，那么 g[i] = g[i-1] + 1，因为第 i 位为 1，所以前面一位只能是 0，所以前面一位包含连续 1 的个数为 g[i-1]，所以 g[i] = g[i-1] + 1。

最终的答案为 f[n] + g[n]。

解决方案：

```go
func findIntegers(n int) int {
    f := make([]int, 32)
    g := make([]int, 32)
    f[0], f[1] = 1, 2
    g[0], g[1] = 1, 1
    for i := 2; i < 32; i++ {
        f[i] = f[i-1] + g[i-1]
        g[i] = f[i-1]
    }
    pre := 0
    res := 0
    for i := 31; i >= 0; i-- {
        if (n & (1 << uint(i))) != 0 {
            res += f[i]
            if pre == 1 {
                break
            }
            pre = 1
        } else {
            pre = 0
        }
        if i == 0 {
            res++
        }
    }
    return res
}
```

算法复杂度：时间复杂度为 O(log n)，空间复杂度为 O(log n)。