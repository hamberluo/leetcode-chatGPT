题目编号：636

题目：函数的独占时间

难度：中等

考察范围：栈、字符串处理

题干：

给出一个非抢占单线程 CPU 的 n 个函数运行日志，找到函数的独占时间。

每个函数都有一个唯一的 Id，从 0 到 n-1。函数可能会递归调用或者被其他函数调用。

日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如："0:start:0" 表示函数 0 从 0 时刻开始运行。"0:end:0" 表示函数 0 在 0 时刻结束。

函数的独占时间定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。

示例 1:

输入:
n = 2
logs = [
"0:start:0",
"1:start:2",
"1:end:5",
"0:end:6"
]
输出:[3, 4]
说明：
函数 0 在时刻 0 开始，在执行了  6个时间单位结束于时刻 6。 
函数 1 在时刻 2 开始，在执行了  3个时间单位结束于时刻 5。 
函数 0 花费了 6 - 0 = 6个时间单位，其中函数 1 花费了 5 - 2 = 3个时间单位。
示例 2:

输入:
n = 1
logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
输出:[8]
说明：
函数 0 在时刻 0 开始，在执行了 5 - 0 = 5个时间单位结束于时刻 5。 
在时刻 2 开始的第二次执行，它在执行了 6 - 2 = 4个时间单位后把控制权交给了另一个线程，在它自己的线程中再次开始运行时，经过 6 - 6 = 0个时间单位结束于时刻 6。 
在时刻 6 开始的第三次执行，它在执行了 7 - 6 = 1个时间单位后结束于时刻 7。 
这个函数的独占时间为 5 + 4 + 1 = 10个时间单位。
注意：

输入的日志会根据时间戳排序，而不是根据日志Id排序。
你的输出需要根据函数Id排序，而不是根据调用时间排序。
函数调用可能会递归调用，会产生多层嵌套调用关系。

解题思路：

使用栈来模拟函数调用的过程，遇到 start 就将函数入栈，遇到 end 就将函数出栈，并计算该函数的独占时间。

解决方案：

```go
func exclusiveTime(n int, logs []string) []int {
    res := make([]int, n)
    stack := make([]int, 0)
    preTime := 0
    for _, log := range logs {
        s := strings.Split(log, ":")
        id, _ := strconv.Atoi(s[0])
        isStart := s[1] == "start"
        time, _ := strconv.Atoi(s[2])
        if len(stack) > 0 {
            res[stack[len(stack)-1]] += time - preTime
        }
        preTime = time
        if isStart {
            stack = append(stack, id)
        } else {
            res[stack[len(stack)-1]]++
            preTime++
            stack = stack[:len(stack)-1]
        }
    }
    return res
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。