题目编号：60

题目：第k个排列

难度：中等

考察范围：数学、递归、回溯

题干：
给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。

解题思路：
本题可以使用递归或回溯的思路来解决，但是这里介绍一种数学方法。

我们可以先求出每一位上应该填写哪个数字，然后依次填写即可。

假设 n=4，k=14，我们可以先求出第一位上应该填写哪个数字，因为每个数字开头的排列数都是一样的，所以可以通过 k/3! 来确定第一位上的数字，即第 14 个排列的第一位应该填写 1。

然后我们需要更新 k 的值，因为已经确定了第一位上的数字，所以我们只需要在剩下的数字中找到第 k%3! 个排列即可，这里的 3! 表示剩下的三个数字的排列数。

以此类推，我们可以依次求出每一位上应该填写哪个数字，最终得到第 k 个排列。

解决方案：

```go
func getPermutation(n int, k int) string {
    nums := make([]int, n)
    for i := 0; i < n; i++ {
        nums[i] = i + 1
    }
    factorials := make([]int, n)
    factorials[0] = 1
    for i := 1; i < n; i++ {
        factorials[i] = factorials[i-1] * i
    }
    k--
    res := ""
    for i := n - 1; i >= 0; i-- {
        index := k / factorials[i]
        k %= factorials[i]
        res += strconv.Itoa(nums[index])
        nums = append(nums[:index], nums[index+1:]...)
    }
    return res
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。