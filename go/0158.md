题目编号：158

题目：用 Read4 读取 N 个字符

难度：困难

考察范围：字符串、IO

题干：

给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法来读取 n 个字符。

read4 方法：

API read4 可以从文件中读取 4 个连续的字符，并且将它们写入缓存数组 buf 中。

返回值为实际读取的字符个数。

注意 read4() 自身拥有文件指针，很类似于 C 语言中的 FILE *fp 。

read4 的定义：

func read4(buf []byte) int

注意：

buf 的长度为 4，你无法修改 read4 的调用方式。

你可以认为 buf 内部不存在需要读取的字符。

你可以认为调用 read4 的次数总是有效的。

解题思路：

这道题目需要我们实现一个 read 方法，该方法可以从文件中读取 n 个字符。但是我们只能使用 read4 方法，该方法每次只能读取 4 个字符。因此我们需要多次调用 read4 方法，直到读取到 n 个字符为止。

我们可以使用一个缓存数组 buf4 来存储每次调用 read4 方法读取到的字符。同时，我们需要使用一个指针 p 来记录当前已经读取到的字符个数。每次调用 read 方法时，我们先判断缓存数组 buf4 中是否还有剩余的字符，如果有，则将剩余的字符拷贝到 buf 中。如果缓存数组 buf4 中没有剩余的字符，则调用 read4 方法读取新的字符，并将其存储到缓存数组 buf4 中。

解决方案：

```go
func read(buf []byte, n int) int {
    buf4 := make([]byte, 4)
    p := 0
    for p < n {
        if len(buf4) == 0 {
            break
        }
        k := read4(buf4)
        if k == 0 {
            break
        }
        for i := 0; i < k && p < n; i++ {
            buf[p] = buf4[i]
            p++
        }
        if k < 4 {
            break
        }
    }
    return p
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。