题目编号：801

题目：使序列递增的最小交换次数

难度：中等

考察范围：贪心算法、动态规划

题干：

给定一个长度为 n 的整数序列，你需要找到一个最小的交换次数，使得交换任意两个元素后，序列变得递增。

序列中的元素各不相同。

解题思路：

本题可以使用贪心算法来解决。

首先，我们需要明确一点，即对于一个递增的序列，我们可以通过交换任意两个元素来得到另一个递增的序列。因此，我们可以将原序列看作是一个递增的序列，然后通过交换元素来使其变得更加递增。

接下来，我们考虑如何进行交换。假设当前我们已经处理了前 i 个元素，且这些元素已经排好序了。我们需要将第 i+1 个元素插入到前 i 个元素中的某个位置，使得序列仍然是递增的。为了使交换次数最小，我们应该将第 i+1 个元素插入到它应该在的位置，即第 i+1 个元素应该插入到前 i 个元素中第一个大于它的元素的位置。

如果第 i+1 个元素已经在它应该在的位置上，那么我们不需要进行任何操作。否则，我们需要将第 i+1 个元素与它应该在的位置上的元素进行交换，然后继续处理下一个元素。

解决方案：

下面是使用贪心算法的 go 代码实现：

func minSwap(nums []int) int {
    n := len(nums)
    // dp[i][0] 表示第 i 个元素不交换的最小交换次数
    // dp[i][1] 表示第 i 个元素交换的最小交换次数
    dp := make([][2]int, n)
    dp[0][1] = 1
    for i := 1; i < n; i++ {
        dp[i][0] = math.MaxInt32
        dp[i][1] = math.MaxInt32
        if nums[i] > nums[i-1] {
            dp[i][0] = dp[i-1][0]
            dp[i][1] = dp[i-1][1] + 1
        }
        if nums[i] > nums[i-2] && nums[i-1] > nums[i-2] {
            dp[i][1] = min(dp[i][1], dp[i-2][0]+1)
            dp[i][0] = min(dp[i][0], dp[i-2][1])
        }
    }
    return min(dp[n-1][0], dp[n-1][1])
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。