题目编号：898

题目：子数组按位或操作

难度：中等

考察范围：位运算、动态规划

题干：

给定一个由非负整数组成的数组 A，返回一个由 A 的所有非空子数组组成的数组，任何子数组的和都可以表示为这些子数组的元素按位或操作的结果。

如果存在多个答案，返回任意一个。

示例 1：

输入：[0]
输出：[[0]]
示例 2：

输入：[1,1,2]
输出：[[1],[1,1],[1,2],[1,1,2],[2]]
解释：
这些子数组对应相同的输出： 
[1, 1]
[2, 3]
[2, 1, 3]
[3]
[1, 3]
可以认为，所有子数组都是 [[1],[1],[2],[1,1],[1,2],[1,1,2],[2],[1,3],[1,1,3],[1,2,3],[1,1,2,3],[2,3]] 中的一部分。

解题思路：

本题需要用到位运算的知识，对于一个子数组，我们可以将其所有元素进行按位或操作，得到一个结果，如果这个结果可以由其他子数组的按位或操作得到，那么这个子数组就可以被忽略掉。

我们可以使用一个 set 来记录所有已经得到的结果，然后对于每个子数组，进行按位或操作，如果得到的结果不在 set 中，就将其加入 set 中，并将其加入答案数组中。

解决方案：

func subarrayBitwiseORs(A []int) []int {
    res := make(map[int]bool)
    cur := make(map[int]bool)
    for _, a := range A {
        nxt := make(map[int]bool)
        nxt[a] = true
        for k := range cur {
            nxt[k|a] = true
        }
        for k := range nxt {
            res[k] = true
        }
        cur = nxt
    }
    ans := make([]int, 0, len(res))
    for k := range res {
        ans = append(ans, k)
    }
    return ans
}

算法复杂度：时间复杂度 O(nlogn)，空间复杂度 O(n)。