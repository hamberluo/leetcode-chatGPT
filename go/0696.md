题目编号：696

题目：计数二进制子串

难度：简单

考察范围：字符串、计数

题干：

给定一个字符串 s，计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。

例如，字符串 "00110011" 中有 6 个这样的子字符串："0011"、"01"、"1100"、"10"、"0011" 和 "01"。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，子串中不能出现其他字符，如 "001122"、"01" 和 "1100" 不是有效的子串。

解题思路：

我们可以将字符串 s 按照 0 和 1 的连续段分组，例如 s = "00111011"，可以得到这样的分组 [2, 3, 1, 2]。

对于任意相邻的两个分组，它们可以组成一个符合条件的子串，子串的长度为它们两个分组长度的较小值。

例如上面的分组可以组成的子串为 "0011"、"01"、"1100" 和 "10"。

因此，我们只需要遍历一遍分组，对于相邻的两个分组，计算它们可以组成的符合条件的子串数量，然后将这些数量累加起来即可。

解决方案：

func countBinarySubstrings(s string) int {
    groups := make([]int, 0, len(s))

    // 将字符串按照 0 和 1 的连续段分组
    for i, j := 0, 0; i < len(s); i = j {
        for j < len(s) && s[j] == s[i] {
            j++
        }
        groups = append(groups, j-i)
    }

    ans := 0
    for i := 1; i < len(groups); i++ {
        ans += min(groups[i], groups[i-1])
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

算法复杂度：时间复杂度为 O(n)，其中 n 是字符串 s 的长度。空间复杂度为 O(n)。