题目编号：768

题目：最多能完成排序的块 II

难度：中等

考察范围：数组、排序

题干：

给定一个数组arr，其中有不同的数字，但可能存在相等的整数。我们将这个数组分成几个“块”，并将这些块分别进行排序。

排序后，再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例 1:

输入: arr = [5,4,3,2,1]
输出: 1
解释:
将整个数组分成一个块，排序后连接即可。

示例 2:

输入: arr = [2,1,3,4,4]
输出: 4
解释:
我们可以把它分成两个块，例如 [2, 1], [3, 4, 4]。
然后这些块在排序后连接起来就是 [1, 2, 3, 4, 4]，这是原数组的升序排序后的结果。

示例 3:

输入: arr = [1,2,3,4]
输出: 4
解释:
我们可以把它分成四个块，例如 [1], [2], [3], [4]。
然后这些块在排序后连接起来就是 [1, 2, 3, 4]，这是原数组的升序排序后的结果。

注意:

arr的长度在[1, 2000]之间。
arr[i]的大小在[0, 10^8]之间。

解题思路：

题目要求我们将数组分成多个块，使得每个块内的元素排序后，整个数组就是有序的。我们可以考虑使用贪心算法来解决这个问题。

我们可以从左到右遍历数组，同时维护一个变量 max，表示当前块内的最大值。当遍历到位置 i 时，如果当前位置的值大于 max，说明当前位置的值应该属于下一个块，我们就可以将前面的所有元素分成一个块，然后从当前位置开始继续遍历。

具体实现时，我们可以使用一个栈来维护当前块内的元素。遍历数组时，如果当前位置的值大于栈顶元素，说明当前位置的值应该属于下一个块，我们就可以将栈中的元素全部弹出，将它们分成一个块，然后从当前位置开始继续遍历。如果当前位置的值小于等于栈顶元素，说明当前位置的值应该属于当前块，我们就可以将当前位置的值压入栈中。

解决方案：

```go
func maxChunksToSorted(arr []int) int {
    stack := make([]int, 0)
    for _, num := range arr {
        if len(stack) == 0 || num >= stack[len(stack)-1] {
            stack = append(stack, num)
        } else {
            top := stack[len(stack)-1]
            for len(stack) > 0 && num < stack[len(stack)-1] {
                stack = stack[:len(stack)-1]
            }
            stack = append(stack, top)
        }
    }
    return len(stack)
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。