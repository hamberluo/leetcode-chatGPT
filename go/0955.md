题目编号：955

题目：删列造序 II

难度：中等

考察范围：贪心算法、字符串处理

题干：

给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。

选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。

比如，有 A = ["abcdef", "uvwxyz"]，删除索引序列 {0, 2, 3}，删除后 A 为["bef", "vyz"]。

假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组需要满足以下条件：

对于每个字符串 S，都存在一个非空字符串 T，满足 S = T + T + ... + T 和 T 的长度为删除操作之前的 S.length。

比方说，如果删除操作之前，A[0] = "abcdef"，那么在执行完以 D 为索引删除操作之后，A[0]（删除操作之后）就是 "def"。

假设我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组满足以下条件：

对于每个字符串 S[i]，都存在一个等于 S[i] 的字符串 T，我们可以将 T 分成两个部分 U 和 V，满足 U 序列中的每个元素都小于 V 序列中的每个元素。

比如，若有字符串 "abcdef" 和 "uvwxyz"，其中删除索引 D = {0, 2, 3}，那么在执行删除操作之后，得到 A = ["bef", "vyz"]，满足条件，因为对于 S[0] = "bef"，存在一个 T = "bef"，可以将 T 分成两部分 U = "b" 和 V = "ef"，满足 U 中的每个元素都小于 V 中的每个元素，对于 S[1] = "vyz"，存在一个 T = "vyz"，可以将 T 分成两部分 U = "v" 和 V = "yz"，满足 U 中的每个元素都小于 V 中的每个元素。

你可以按任意顺序返回 A 中满足条件的删除索引 D。

解题思路：

对于每个字符串 S[i]，都存在一个等于 S[i] 的字符串 T，我们可以将 T 分成两个部分 U 和 V，满足 U 序列中的每个元素都小于 V 序列中的每个元素。

这个条件可以转化为：对于任意两个字符串 S[i] 和 S[j]，如果 S[i][k] > S[j][k]，那么 S[i][k+1:] 必须大于 S[j][k+1:]。

因此，我们可以先将所有不满足条件的删除索引放入一个集合中，然后遍历集合中的每个删除索引，判断是否满足条件，如果满足条件，则将该删除索引从集合中删除。

解决方案：

```go
func minDeletionSize(A []string) []int {
    n := len(A)
    m := len(A[0])
    res := make([]int, 0)
    delSet := make(map[int]bool)
    for i := 0; i < m; i++ {
        for j := 1; j < n; j++ {
            if !delSet[i] && A[j][i] < A[j-1][i] {
                res = append(res, i)
                delSet[i] = true
                break
            }
        }
    }
    return res
}
```

算法复杂度：时间复杂度为 O(nm)，空间复杂度为 O(m)。