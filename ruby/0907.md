题目编号：907

题目：子数组的最小值之和

难度：中等

考察范围：单调栈、动态规划

题干：给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。由于答案可能很大，因此返回答案模 10^9 + 7。

解题思路：本题可以使用单调栈或者动态规划来解决。这里介绍单调栈的解法。

我们可以先考虑一个子问题：对于一个以 A[i] 为结尾的子数组，它的最小值是多少？这个问题可以使用单调栈来解决。具体地，我们枚举以 i 结尾的所有子数组，对于每个子数组，我们找出它左边最近的小于 A[i] 的数和右边最近的小于 A[i] 的数，那么以 A[i] 为最小值的子数组的数量就是这两个数之间的距离。例如，对于数组 [3, 1, 2, 4, 5]，以 2 结尾的子数组中，以 2 为最小值的子数组有 [1, 2] 和 [2]，它们的数量分别为 2 和 1。

有了这个子问题的解法，我们就可以考虑如何求出所有子数组的最小值之和。我们可以枚举每个数 A[i]，以它为结尾的子数组的最小值之和就是以 A[i] 为最小值的子数组的数量乘以 A[i]。而以 A[i] 为最小值的子数组的数量可以使用单调栈来求解，具体地，我们维护一个单调递增的栈，每次将 A[i] 入栈，如果栈顶元素大于 A[i]，那么就将栈顶元素出栈，并计算以栈顶元素为最小值的子数组的数量，然后将这个数量乘以栈顶元素加入答案中。最后，我们将 A[i] 入栈即可。

解决方案：

```ruby
# @param {Integer[]} a
# @return {Integer}
def sum_subarray_mins(a)
    n = a.size
    mod = 10**9 + 7
    left = Array.new(n, -1)
    right = Array.new(n, n)
    stack = []
    (0...n).each do |i|
        while !stack.empty? && a[stack[-1]] > a[i]
            right[stack[-1]] = i
            stack.pop
        end
        left[i] = stack[-1] if !stack.empty?
        stack << i
    end
    ans = 0
    (0...n).each do |i|
        ans += a[i] * (i - left[i]) * (right[i] - i)
        ans %= mod
    end
    ans
end
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。