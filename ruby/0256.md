题目编号：256

题目：粉刷房子

难度：中等

考察范围：动态规划

题干：你有一排房子，每个房子可以被粉刷成红色、蓝色或绿色中的任意一种颜色。你必须将所有房子都粉刷成同一种颜色，且相邻的房子不能粉刷成相同的颜色。费用是一个 n x 3 的矩阵，其中费用[i][0] 是将第 i 个房子粉刷成红色的费用，费用[i][1] 是将第 i 个房子粉刷成蓝色的费用，费用[i][2] 是将第 i 个房子粉刷成绿色的费用。你必须按照以下规定进行粉刷：

- 每个房子的粉刷成本不同。
- 相邻的房子不能粉刷成相同的颜色。

编写一个函数，计算所有房子被粉刷成同一种颜色所需的最小成本。

解题思路：动态规划

- 定义状态：dp[i][j] 表示将第 i 个房子粉刷成颜色 j 的最小成本。
- 状态转移方程：dp[i][j] = cost[i][j] + min(dp[i-1][(j+1)%3], dp[i-1][(j+2)%3])，即将第 i 个房子粉刷成颜色 j 的最小成本等于将第 i 个房子粉刷成颜色 j 的成本加上前一个房子不是颜色 j 的最小成本。
- 最终答案：min(dp[n-1][0], dp[n-1][1], dp[n-1][2])，即将最后一个房子粉刷成红色、蓝色或绿色的最小成本中的最小值。

解决方案：

```ruby
def min_cost(costs)
  n = costs.size
  dp = Array.new(n) { Array.new(3, 0) }
  dp[0] = costs[0]

  (1...n).each do |i|
    dp[i][0] = costs[i][0] + [dp[i-1][1], dp[i-1][2]].min
    dp[i][1] = costs[i][1] + [dp[i-1][0], dp[i-1][2]].min
    dp[i][2] = costs[i][2] + [dp[i-1][0], dp[i-1][1]].min
  end

  dp[n-1].min
end
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(n)。