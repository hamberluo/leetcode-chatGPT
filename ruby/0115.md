题目编号：115

题目：不同的子序列

难度：困难

考察范围：动态规划

题干：给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

解题思路：动态规划

我们可以使用动态规划来解决这个问题。我们定义 dp[i][j] 表示 T 的前 i 个字符在 S 的前 j 个字符中出现的次数。那么我们可以得到状态转移方程：

当 S[j] != T[i] 时，dp[i][j] = dp[i][j-1]，即当前字符不匹配，那么当前的状态就等于前一个状态。

当 S[j] == T[i] 时，dp[i][j] = dp[i][j-1] + dp[i-1][j-1]，即当前字符匹配，那么当前的状态就等于前一个状态加上 T 的前 i-1 个字符在 S 的前 j-1 个字符中出现的次数。

最终的答案就是 dp[T.length][S.length]。

解决方案：

```ruby
def num_distinct(s, t)
  m, n = t.length, s.length
  dp = Array.new(m+1) { Array.new(n+1, 0) }
  (0..n).each { |i| dp[0][i] = 1 }
  (1..m).each do |i|
    (1..n).each do |j|
      dp[i][j] = dp[i][j-1]
      dp[i][j] += dp[i-1][j-1] if t[i-1] == s[j-1]
    end
  end
  dp[m][n]
end
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。