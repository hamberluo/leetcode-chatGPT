题目编号：741

题目：摘花生

难度：中等

考察范围：动态规划

题干：给定一个 m x n 的网格和一个整数 k，你需要将这个网格中的花生按照下面的规则进行摘取：

每次可以从网格中选取一行或一列，并且必须选取 k 个花生。
在选取之后，该行或该列中剩余的花生会自动向下或向右移动，直到该行或该列的末尾。
最终，你需要将所有选取的花生数量相加，得到最大的总花生数量。

请你返回该网格中最大的总花生数量。

解题思路：动态规划

首先，我们可以将题目转化为一个二维数组的最大子序和问题。我们可以将每一行看作一个序列，每一列看作一个序列，然后对每一行和每一列分别求出最大的 k 个数的和，然后将这些和相加，就是最终的答案。

具体来说，我们可以使用动态规划来解决这个问题。我们定义一个二维数组 dp，其中 dp[i][j] 表示在第 i 行和第 j 列时，已经选取了 k 个花生时的最大总花生数量。那么，我们可以得到如下的状态转移方程：

dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] - (k == 1 ? 0 : grid[i][j])

其中，grid[i][j] 表示网格中第 i 行第 j 列的花生数量，k 表示每次选取的花生数量。如果 k 等于 1，那么我们就不需要减去 grid[i][j]，因为此时我们只需要选取一个花生。

最终的答案就是 dp[m][n]，其中 m 和 n 分别表示网格的行数和列数。

解决方案：

```ruby
def max_harvest(grid, k)
  m, n = grid.size, grid[0].size
  dp = Array.new(m+1) { Array.new(n+1, 0) }
  for i in 1..m
    for j in 1..n
      dp[i][j] = [dp[i-1][j], dp[i][j-1]].max + grid[i-1][j-1] - (k == 1 ? 0 : grid[i-1][j-1])
    end
  end
  dp[m][n]
end
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。