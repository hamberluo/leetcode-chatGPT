题目编号：787

题目：K 站中转内最便宜的航班

难度：中等

考察范围：图论、最短路径算法

题干：

有 n 个城市，按从 0 到 n-1 编号。给定航班列表 flights，其中每个航班都包含了出发城市、目的地城市、以及该航班的价格。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。

解题思路：

本题是一道典型的最短路径问题，但是与普通的最短路径问题不同的是，本题中的路径长度是指经过的边数，而不是边权之和。因此，我们需要使用一些特殊的算法来解决这个问题。

一种常见的解决方法是使用动态规划。我们可以定义一个二维数组 dp，其中 dp[i][j] 表示经过 i 次中转到达城市 j 的最小花费。初始时，dp[0][src] = 0，其余元素均为正无穷大。然后，我们可以使用以下递推式来更新 dp 数组：

dp[i][j] = min(dp[i][j], dp[i-1][k] + cost[k][j])

其中 cost[k][j] 表示从城市 k 到城市 j 的航班价格。这个递推式的意义是，我们可以从经过 i-1 次中转到达城市 k，然后再从城市 k 到城市 j，这样就可以经过 i 次中转到达城市 j。我们需要遍历所有的航班，找到所有从城市 k 出发，到达城市 j 的航班，并计算它们的总花费，取其中的最小值作为 dp[i][j] 的值。

最终的答案就是 dp[k][dst]，即经过 k 次中转到达目的地城市的最小花费。如果 dp[k][dst] 为正无穷大，则说明不存在这样的路径，返回 -1。

解决方案：

```ruby
def find_cheapest_price(n, flights, src, dst, k)
  # 初始化 dp 数组
  dp = Array.new(k+2) { Array.new(n, Float::INFINITY) }
  dp[0][src] = 0

  # 递推更新 dp 数组
  (1..k+1).each do |i|
    (0...n).each do |j|
      (0...n).each do |k|
        if flights[k][1] == j
          dp[i][j] = [dp[i][j], dp[i-1][flights[k][0]] + flights[k][2]].min
        end
      end
    end
  end

  # 返回结果
  dp[k+1][dst] == Float::INFINITY ? -1 : dp[k+1][dst]
end
```

算法复杂度：

时间复杂度：O(k * n^2 * m)，其中 n 是城市数量，m 是航班数量。我们需要遍历 k 次 dp 数组，每次遍历需要遍历 n^2 个元素，并且每个元素需要遍历 m 条航班。因此，总时间复杂度为 O(k * n^2 * m)。

空间复杂度：O(k * n)，我们需要使用一个二维数组 dp 来存储中转次数和城市编号，因此空间复杂度为 O(k * n)。