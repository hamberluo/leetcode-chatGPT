题目编号：314

题目：二叉树的垂直遍历

难度：中等

考察范围：二叉树、哈希表、遍历

题干：给定一个二叉树，返回其结点按垂直方向从上到下的遍历。如果两个结点在同一行和同一列，那么先出现在前的结点应该在前面。

解题思路：首先需要明确题目中的“垂直遍历”是什么意思。我们可以将二叉树想象成一个平面直角坐标系，根节点为原点，每个节点的坐标为其父节点坐标加上一个偏移量。偏移量可以分为左偏移和右偏移，左偏移为父节点的横坐标减一，右偏移为父节点的横坐标加一。这样，我们就可以将每个节点按照其横坐标进行分类，将同一列的节点放在一起。

接下来，我们需要对每一列的节点进行排序。按照题目要求，如果两个节点在同一行和同一列，那么先出现在前的节点应该在前面。因此，我们可以对每一列的节点按照纵坐标进行排序，然后将排序后的节点加入到结果数组中。

最后，我们需要对整个结果数组按照横坐标进行排序，然后返回结果即可。

解决方案：

```ruby
def vertical_order(root)
  return [] if root.nil?

  # 建立哈希表，key 为横坐标，value 为该横坐标上的节点数组
  hash = Hash.new { |h, k| h[k] = [] }

  # BFS 遍历二叉树，同时记录每个节点的横坐标和纵坐标
  queue = [[root, 0, 0]]
  while !queue.empty?
    node, x, y = queue.shift
    hash[x] << [node.val, y]
    queue << [node.left, x - 1, y + 1] if node.left
    queue << [node.right, x + 1, y + 1] if node.right
  end

  # 对每个横坐标上的节点数组按照纵坐标排序
  hash.each { |k, v| hash[k] = v.sort_by { |a| a[1] } }

  # 对哈希表按照横坐标进行排序，然后将每个横坐标上的节点数组加入到结果数组中
  hash.sort.map { |k, v| v.map { |a| a[0] } }
end
```

算法复杂度：时间复杂度为 O(nlogn)，其中 n 为二叉树的节点数。需要进行 BFS 遍历，时间复杂度为 O(n)，同时需要对每个横坐标上的节点数组进行排序，时间复杂度为 O(nlogn)。空间复杂度为 O(n)，需要使用哈希表存储每个节点的横坐标和纵坐标。