题目编号：694

题目：不同岛屿的数量

难度：中等

考察范围：深度优先搜索、广度优先搜索

题干：给定一个由 0 和 1 组成的非空二维数组 grid ，用来表示海洋岛屿地图。岛屿被水包围，通过水平方向或竖直方向上相邻的陆地连接而成。我们定义一个岛屿为由一些相邻的 1 (代表土地) 构成的组合，每个“相邻”的土地必须在同一行或者同一列上。你可以假设 grid 的四个边缘都被水包围着。

计算这个海洋中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接而成。

解题思路：本题可以使用深度优先搜索或广度优先搜索来解决。具体思路是，遍历整个二维数组，当遇到值为 1 的格子时，就从该格子开始进行深度优先搜索或广度优先搜索，将与该格子相邻的所有值为 1 的格子都标记为已访问，并将它们加入到同一个岛屿中。最终，岛屿的数量就是搜索的次数。

解决方案：

```ruby
def num_islands(grid)
  return 0 if grid.empty?

  m, n = grid.size, grid[0].size
  count = 0

  (0...m).each do |i|
    (0...n).each do |j|
      if grid[i][j] == "1"
        count += 1
        dfs(grid, i, j)
      end
    end
  end

  count
end

def dfs(grid, i, j)
  return if i < 0 || i >= grid.size || j < 0 || j >= grid[0].size || grid[i][j] == "0"

  grid[i][j] = "0"
  dfs(grid, i - 1, j)
  dfs(grid, i + 1, j)
  dfs(grid, i, j - 1)
  dfs(grid, i, j + 1)
end
```

算法复杂度：时间复杂度为 O(mn)，其中 m 和 n 分别为二维数组的行数和列数。空间复杂度为 O(mn)，即最坏情况下整个二维数组都为岛屿。