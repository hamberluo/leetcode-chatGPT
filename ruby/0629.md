题目编号：629

题目：K个逆序对数组

难度：困难

考察范围：动态规划、数学

题干：给定两个整数 n 和 k，找到所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的数量。逆序对是指在数组中的两个数字，前面的数字大于后面的数字。

解题思路：动态规划

我们可以使用动态规划来解决这个问题。我们定义 dp[i][j] 表示由数字 1 到 i 组成的恰好有 j 个逆序对的不同的数组的数量。那么我们可以考虑在 dp[i-1][j] 的基础上，如何得到 dp[i][j]。

我们可以将数字 i 插入到由数字 1 到 i-1 组成的数组中，那么插入的位置可以是 1 到 i，这样就可以得到 i 种不同的数组。对于插入位置为 k 的情况，我们需要考虑数字 i 插入到 k 之前会增加多少个逆序对。由于插入位置为 k 的数组中，数字 1 到 k-1 的逆序对数量已经确定，所以数字 i 插入到 k 之前会增加 k-1 个逆序对。因此，我们可以得到状态转移方程：

dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i+1]

其中，dp[i-1][j-k] 表示由数字 1 到 i-1 组成的恰好有 j-k 个逆序对的不同的数组的数量，数字 i 插入到这些数组中的任意一个位置都会增加 k 个逆序对。

解决方案：

```ruby
def k_inverse_pairs(n, k)
  mod = 10**9 + 7
  dp = Array.new(n+1) { Array.new(k+1, 0) }
  dp[1][0] = 1
  (2..n).each do |i|
    dp[i][0] = 1
    (1..k).each do |j|
      dp[i][j] = (dp[i][j-1] + dp[i-1][j] - (j-i >= 0 ? dp[i-1][j-i] : 0)) % mod
    end
  end
  dp[n][k]
end
```

算法复杂度：时间复杂度为 O(n*k)，空间复杂度为 O(n*k)。