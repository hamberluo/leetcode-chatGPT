题目编号：354

题目：俄罗斯套娃信封问题

难度：困难

考察范围：二分查找、动态规划

题干：给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

解题思路：本题可以转化为求最长上升子序列的长度，因为如果一个信封可以放到另一个信封里面，那么这个信封的宽和高都要比另一个信封的宽和高小，也就是说，我们需要找到一个最长的信封序列，使得每个信封的宽和高都比前面的信封小。

解决方案：我们可以先将所有信封按照宽度从小到大排序，如果宽度相同，则按照高度从大到小排序。然后我们可以使用动态规划来解决这个问题。我们定义一个数组 dp，其中 dp[i] 表示以第 i 个信封为结尾的最长上升子序列的长度。对于每个 i，我们需要找到一个 j，使得 j<i 且 envelopes[j] 可以放到 envelopes[i] 里面，同时 dp[j] 最大。然后我们就可以得到状态转移方程：

dp[i] = max(dp[j]+1)，其中 0<=j<i 且 envelopes[j] 可以放到 envelopes[i] 里面。

最终的答案就是 dp 数组中的最大值。

代码如下：

```ruby
def max_envelopes(envelopes)
  n = envelopes.size
  return 0 if n == 0

  # 按照宽度从小到大排序，如果宽度相同，则按照高度从大到小排序
  envelopes.sort! { |a, b| a[0] == b[0] ? b[1] <=> a[1] : a[0] <=> b[0] }

  # 初始化 dp 数组
  dp = Array.new(n, 1)

  # 动态规划
  (1...n).each do |i|
    (0...i).each do |j|
      if envelopes[j][1] < envelopes[i][1]
        dp[i] = [dp[i], dp[j]+1].max
      end
    end
  end

  # 返回最大值
  dp.max
end
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。