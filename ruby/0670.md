题目编号：670

题目：最大交换

难度：中等

考察范围：贪心算法

题干：给定一个非负整数，你可以交换两个数位至多一次来获得最大的合法的数。返回最大的合法的你能够获得的数。

解题思路：贪心算法

我们可以从高位到低位遍历这个数字，如果当前位的数字小于后面的数字，那么我们就应该交换这两个数字，以此来让当前位的数字尽可能大。

但是我们不能贸然交换，因为我们只能交换一次，所以我们应该交换最高位的小数字和最低位的大数字，这样可以让交换后的数字最大。

解决方案：

```ruby
def maximum_swap(num)
  # 将数字转换为数组
  nums = num.to_s.chars.map(&:to_i)
  # 记录每个数字最后出现的位置
  last = {}
  nums.each_with_index { |n, i| last[n] = i }
  # 从高位到低位遍历数字
  nums.each_with_index do |n, i|
    # 从9到当前数字+1的范围内查找最大的数字
    (9).downto(n + 1) do |m|
      # 如果找到了比当前数字大的数字
      if last[m] && last[m] > i
        # 交换两个数字
        nums[i], nums[last[m]] = nums[last[m]], nums[i]
        # 将数组转换为数字并返回
        return nums.join.to_i
      end
    end
  end
  # 如果没有交换，直接返回原数字
  num
end
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。