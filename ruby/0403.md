题目编号：403

题目：青蛙过河

难度：中等

考察范围：动态规划、二分查找

题干：一只青蛙想要过河。 假定河流被等分为 x 个单位长度，并且在每一个单位长度内可能有石头（即可能有或者没有）。青蛙可以跳到石头上，但是不可以跳进水里。给定一个石头的位置列表（用单元格表示，从 0 到 x-1），请判定青蛙是否可以穿过河流。

初始时，青蛙默认在第一个石头上，并可以假定青蛙第一步只能跳跃一个单位长度（即只能从单元格 0 跳到单元格 1）。

如果青蛙上一步跳跃了 k 个单位长度，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位长度。另请注意，青蛙只能向前方（终点的方向）跳跃。

解题思路：动态规划

我们可以用一个二维数组 dp 来表示青蛙能否跳到当前石头上，其中 dp[i][j] 表示青蛙能否跳到第 i 个石头上，并且上一步跳了 j 个单位长度。如果能跳到当前石头上，那么 dp[i][j] 的值为 true，否则为 false。

对于第 i 个石头，我们可以从前面的石头跳过来，也可以从后面的石头跳过来。因此，我们需要遍历前面的所有石头，看看能否跳到当前石头上。具体来说，对于第 i 个石头，我们遍历前面的所有石头 j，如果青蛙能够从第 j 个石头跳到第 i 个石头上，那么我们就更新 dp[i][i-j]、dp[i][i-j+1] 和 dp[i][i-j-1] 的值为 true。

最终，我们只需要检查最后一个石头上的 dp 值是否为 true 即可。

解决方案：

```ruby
# @param {Integer[]} stones
# @return {Boolean}
def can_cross(stones)
    n = stones.size
    dp = Array.new(n) { Array.new(n, false) }
    dp[0][0] = true
    (1...n).each do |i|
        (0...i).each do |j|
            k = stones[i] - stones[j]
            if k < 0 || k > i - j || !dp[j][k]
                next
            end
            dp[i][k] = true
            if k > 0
                dp[i][k-1] = true
            end
            if k < i - j
                dp[i][k+1] = true
            end
            if i == n - 1 && (dp[i][k-1] || dp[i][k] || dp[i][k+1])
                return true
            end
        end
    end
    return false
end
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。