题目编号：756

题目：金字塔转换矩阵

难度：简单

考察范围：字符串、递归、回溯

题干：现在，我们用一个二维数组表示一个金字塔。给定一个金字塔，找出从顶部到底部的所有路径中，数字总和最小的那条路径。每一步可以走到下面一行相邻的数字上。

例如，下面的金字塔：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

从顶到底部的所有路径中，数字总和最小的路径为 2 -> 3 -> 5 -> 1，总和为 11。

解题思路：使用递归回溯的方法，从顶部开始，每次向下走一层，分别计算左右两个子节点的最小路径和，然后取较小值加上当前节点的值，最终得到从顶部到当前节点的最小路径和。递归结束条件为到达底部。

解决方案：

```ruby
def minimum_total(triangle)
  dfs(triangle, 0, 0, {})
end

def dfs(triangle, i, j, memo)
  return 0 if i == triangle.size # 到达底部，返回0
  return memo[[i, j]] if memo[[i, j]] # 如果已经计算过，直接返回结果

  left = dfs(triangle, i+1, j, memo) # 左子节点的最小路径和
  right = dfs(triangle, i+1, j+1, memo) # 右子节点的最小路径和
  memo[[i, j]] = [left, right].min + triangle[i][j] # 取较小值加上当前节点的值，存入缓存
end
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)，其中 n 为金字塔的高度。因为每个节点只会被计算一次，所以时间复杂度为 O(n^2)。使用缓存可以避免重复计算，所以空间复杂度为 O(n^2)。