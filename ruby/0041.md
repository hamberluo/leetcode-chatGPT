题目编号：41

题目：缺失的第一个正数

难度：困难

考察范围：数组、哈希表

题干：给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

解题思路：由于要找到最小的正整数，所以我们可以先将数组中的负数和0都变成一个比数组长度大的数，因为这些数肯定不是我们要找的最小正整数。然后我们可以遍历数组，将每个数对应的下标上的数变成负数，表示这个数出现过。最后再遍历一遍数组，找到第一个正数对应的下标，即为缺失的最小正整数。

解决方案：

```ruby
def first_missing_positive(nums)
  n = nums.size
  # 将负数和0都变成一个比数组长度大的数
  nums.map! { |num| num <= 0 ? n + 1 : num }
  # 将每个数对应的下标上的数变成负数，表示这个数出现过
  nums.each do |num|
    num = num.abs
    nums[num - 1] = -nums[num - 1] if num <= n
  end
  # 找到第一个正数对应的下标，即为缺失的最小正整数
  nums.each_with_index do |num, i|
    return i + 1 if num > 0
  end
  n + 1
end
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。