题目编号：550

题目：给定一棵二叉树，统计其中的等差数列的个数。等差数列的定义是至少有三个结点，且任意两个相邻结点之差相同。

难度：中等

考察范围：二叉树、递归、动态规划

题干：

给定一棵二叉树，统计其中的等差数列的个数。等差数列的定义是至少有三个结点，且任意两个相邻结点之差相同。

例如，以下二叉树中有 5 个等差数列：1, 2, 3; 2, 3, 4; 2, 4, 6; 3, 4, 5; 4, 5, 6。

```ruby
    2
   / \
  4   6
 / \   \
1   3   5
```

解题思路：

对于每个节点，我们需要记录以该节点为结尾的等差数列的个数。我们可以使用一个哈希表来记录，键为节点值，值为以该节点为结尾的等差数列的个数。

对于每个节点，我们需要遍历其左右子树，计算以该节点为结尾的等差数列的个数。具体地，我们可以先递归遍历左右子树，得到以左右子节点为结尾的等差数列的个数，然后根据等差数列的定义，判断该节点是否可以加入等差数列中。如果可以，我们就将以该节点为结尾的等差数列的个数加上左右子节点的个数。

最后，我们将以该节点为结尾的等差数列的个数加入哈希表中，并返回以该节点为结尾的等差数列的个数。

解决方案：

```ruby
def number_of_arithmetic_slices(root)
  @count = 0
  dfs(root)
  @count
end

def dfs(node)
  return {} if node.nil?

  left = dfs(node.left)
  right = dfs(node.right)

  # 将左右子节点的哈希表合并
  hash = left.merge(right) { |k, v1, v2| v1 + v2 }

  # 判断该节点是否可以加入等差数列中
  hash[node.val] ||= 0
  if left[node.val] && right[node.val]
    hash[node.val] += left[node.val] + right[node.val]
    @count += left[node.val] + right[node.val]
  end

  # 将以该节点为结尾的等差数列的个数加入哈希表中
  hash[node.val] ||= 0
  hash[node.val] += 1

  hash
end
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)，其中 n 是二叉树的节点数。