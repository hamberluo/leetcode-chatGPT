题目编号：639

题目：解码方法 II

难度：困难

考察范围：动态规划

题干：

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'，可以表示从 1 到 9 的任意数字（不包括 0）。例如，字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18"、"19"。

给定一串数字解码消息（一个字符串），计算解码方法的总数。

注意：答案可能非常大，你需要将结果模 109 + 7 后返回。

示例 1：

输入: "*"
输出: 9
解释: 加密的信息可以表示为： "1", "2", "3", "4", "5", "6", "7", "8", "9"。

解题思路：

这道题是一道动态规划的题目，我们可以用 dp[i] 表示前 i 个字符的解码方法总数，那么我们需要考虑以下几种情况：

- 当前字符为数字 1-9，那么它可以单独解码，也可以和前一个数字组合解码，即 dp[i] = dp[i-1] + dp[i-2]。
- 当前字符为 *，那么它可以单独解码为 1-9 中的任意一个数字，也可以和前一个数字组合解码为 10-26 中的任意一个数字，即 dp[i] = 9 * dp[i-1] + 15 * dp[i-2]。
- 当前字符为 0，那么它只能和前一个数字组合解码为 10 或 20，即 dp[i] = dp[i-2]。
- 当前字符为其他字符，无法解码，直接返回 0。

需要注意的是，由于答案可能非常大，我们需要将结果模 10^9+7 后返回。

解决方案：

```ruby
MOD = 10**9 + 7

# @param {String} s
# @return {Integer}
def num_decodings(s)
    n = s.size
    dp = Array.new(n+1, 0)
    dp[0] = 1
    dp[1] = s[0] == '*' ? 9 : (s[0] == '0' ? 0 : 1)
    (2..n).each do |i|
        if s[i-1] >= '1' && s[i-1] <= '9'
            dp[i] += dp[i-1]
            dp[i] %= MOD
        end
        if s[i-2] == '1' || (s[i-2] == '2' && s[i-1] >= '0' && s[i-1] <= '6')
            dp[i] += dp[i-2]
            dp[i] %= MOD
        end
        if s[i-2] == '*'
            if s[i-1] >= '0' && s[i-1] <= '6'
                dp[i] += 2 * dp[i-2]
                dp[i] %= MOD
            else
                dp[i] += dp[i-2]
                dp[i] %= MOD
            end
        end
        if s[i-1] == '*'
            dp[i] += 9 * dp[i-1]
            dp[i] %= MOD
            if s[i-2] == '1'
                dp[i] += 9 * dp[i-2]
                dp[i] %= MOD
            elsif s[i-2] == '2'
                dp[i] += 6 * dp[i-2]
                dp[i] %= MOD
            elsif s[i-2] == '*'
                dp[i] += 15 * dp[i-2]
                dp[i] %= MOD
            end
        end
    end
    dp[n]
end
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。