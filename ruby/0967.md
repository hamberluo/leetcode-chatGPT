题目编号：967

题目：连续差相同的数字

难度：中等

考察范围：数学、递归、回溯

题干：给定一个整数 N 和一个整数 K，找出所有大于等于 0 小于等于 N 的整数，它们与其反转数之间的差等于 K。

例如，如果输入 N = 10，K = 1，输出为：[1,2,3,4,5,6,7,8,9,10]。

如果输入 N = 10，K = 3，输出为：[2,4,6,8]。

解题思路：这道题可以用递归或回溯的方法来解决。我们可以从最高位开始，枚举当前位的数字，然后递归到下一位。如果当前位是最后一位，那么我们就可以判断当前数和它的反转数之间的差是否等于 K，如果是，就将当前数加入结果中。

解决方案：

```ruby
def nums_same_consec_diff(n, k)
  res = []
  # 从 1-9 枚举第一位数字
  (1..9).each do |i|
    dfs(i, n, k, res)
  end
  # 如果 n 是 1，还需要加入 0
  res << 0 if n == 1
  res
end

def dfs(num, n, k, res)
  # 如果当前数字的位数等于 n，就判断它和它的反转数之间的差是否等于 k
  if num.to_s.size == n
    res << num if k == 0
    return
  end
  # 获取当前数字的最后一位
  last_digit = num % 10
  # 枚举下一位数字
  if last_digit + k < 10
    dfs(num * 10 + last_digit + k, n, k, res)
  end
  if k != 0 && last_digit - k >= 0
    dfs(num * 10 + last_digit - k, n, k, res)
  end
end
```

算法复杂度：时间复杂度为 O(2^N)，空间复杂度为 O(2^N)。其中 N 是数字的位数。因为每个数字最多只有两个子节点，所以时间复杂度和空间复杂度都是指数级别的。