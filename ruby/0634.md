题目编号：634

题目：寻找数组的错位排列

难度：中等

考察范围：数组、排列、数学

题干：给定一个从 1 到 n 排序的整数列表。你需要将其重新排列成它们任意的错位排列，也就是说相邻的元素不能是相邻的。你需要返回任意一个这样的排列。

解题思路：错位排列的定义是相邻的元素不能是相邻的，因此我们可以考虑将原数组中的奇数和偶数分别排列在两个数组中，然后将这两个数组合并成一个错位排列的数组。具体来说，我们可以将原数组中的奇数和偶数分别提取出来，然后将奇数和偶数分别排列在两个数组中，最后将这两个数组合并成一个错位排列的数组。由于奇数和偶数的个数相等，因此这个错位排列的数组的长度一定是偶数，我们可以从第一个位置开始，依次将奇数和偶数插入到这个数组中，直到数组被填满为止。

解决方案：

```ruby
def find_derangement(n)
  return [] if n == 1
  odd = (1..n).select(&:odd?)
  even = (1..n).select(&:even?)
  ans = Array.new(n)
  i = 0
  while !odd.empty? && !even.empty?
    ans[i] = odd.shift
    i += 1
    ans[i] = even.shift
    i += 1
  end
  ans[i..-1] = odd + even
  ans
end
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。