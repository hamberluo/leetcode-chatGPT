题目编号：935

题目：骑士拨号器

难度：中等

考察范围：递归、动态规划

题干：国际象棋中的骑士可以按下图所示进行移动：

![image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/11/03/knight.png)

这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，所以输出答案模 10^9 + 7。

解题思路：这道题可以用递归或者动态规划来解决。递归的思路比较简单，就是从每个数字键开始，向8个方向递归，直到步数为0，然后返回1。动态规划的思路也比较简单，就是用一个二维数组dp[i][j]表示从数字i开始跳j步可以得到的不同号码数，然后根据骑士的移动规则，更新dp数组即可。

解决方案：动态规划

```ruby
def knight_dialer(n)
  mod = 10**9 + 7
  dp = Array.new(10) { Array.new(n, 0) }
  moves = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]
  (0..9).each { |i| dp[i][0] = 1 }
  (1...n).each do |j|
    (0..9).each do |i|
      moves[i].each { |k| dp[i][j] = (dp[i][j] + dp[k][j - 1]) % mod }
    end
  end
  dp.flatten.reduce(:+) % mod
end
```

算法复杂度：时间复杂度O(n)，空间复杂度O(n)。