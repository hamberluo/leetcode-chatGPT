题目编号：524

题目：通过删除字母匹配到字典里最长单词

难度：中等

考察范围：字符串、排序、双指针

题干：

给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果没有，则返回空字符串。

示例 1:

输入:
s = "abpclefk"
d = ["ale","apple","monkey","plea"]

输出: 
"apple"

示例 2:

输入:
s = "abpclefk"
d = ["a","b","c"]

输出: 
"a"

解题思路：

首先，我们需要对字典进行排序，按照长度从大到小排序，如果长度相同，则按照字典序从小到大排序。

然后，我们遍历字典中的每个单词，判断该单词是否可以通过删除给定字符串的某些字符得到。我们可以使用双指针的方法，分别从给定字符串和字典中的单词的开头开始遍历，如果两个字符相同，则两个指针都向后移动一位，否则只移动给定字符串的指针。如果字典中的单词的指针移动到了末尾，则说明该单词可以通过删除给定字符串的某些字符得到。

最后，我们返回长度最长且字典顺序最小的字符串。

解决方案：

```ruby
def find_longest_word(s, d)
  # 对字典进行排序
  d.sort! do |a, b|
    if a.length != b.length
      b.length <=> a.length
    else
      a <=> b
    end
  end

  # 遍历字典中的每个单词
  d.each do |word|
    i = 0
    j = 0
    # 使用双指针的方法判断该单词是否可以通过删除给定字符串的某些字符得到
    while i < s.length && j < word.length
      if s[i] == word[j]
        j += 1
      end
      i += 1
    end
    # 如果字典中的单词的指针移动到了末尾，则说明该单词可以通过删除给定字符串的某些字符得到
    if j == word.length
      return word
    end
  end

  # 如果没有符合条件的单词，则返回空字符串
  return ""
end
```

算法复杂度：时间复杂度为 O(nlogn)，其中 n 为字典中单词的个数，主要是排序的时间复杂度；空间复杂度为 O(1)，只需要常数级别的额外空间。