题目编号：438

题目：找到字符串中所有字母异位词

难度：中等

考察范围：字符串、哈希表、滑动窗口

题干：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。

示例 1:

输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。

示例 2:

输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。

解题思路：使用滑动窗口和哈希表

我们可以使用滑动窗口和哈希表来解决这个问题。

首先，我们需要用哈希表记录字符串 p 中每个字符出现的次数。然后，我们可以使用滑动窗口来遍历字符串 s，每次移动窗口时，我们需要将窗口中的字符出现次数与哈希表中的字符出现次数进行比较，如果相同，则说明窗口中的子串是 p 的字母异位词，我们可以将其起始索引加入结果数组中。

具体实现时，我们可以使用两个哈希表，一个记录窗口中的字符出现次数，另一个记录字符串 p 中的字符出现次数。每次移动窗口时，我们需要将窗口左侧的字符出现次数减一，右侧的字符出现次数加一，然后比较两个哈希表是否相同。

解决方案：

```ruby
def find_anagrams(s, p)
  res = []
  return res if s.nil? || s.empty? || p.nil? || p.empty?

  # 初始化哈希表
  p_hash = {}
  s_hash = {}
  p.each_char { |c| p_hash[c] = p_hash[c].to_i + 1 }

  # 滑动窗口
  left = 0
  right = 0
  while right < s.length
    # 右侧字符出现次数加一
    s_hash[s[right]] = s_hash[s[right]].to_i + 1

    # 左侧字符出现次数减一
    if right - left + 1 > p.length
      s_hash[s[left]] = s_hash[s[left]].to_i - 1
      left += 1
    end

    # 判断窗口中的子串是否是 p 的字母异位词
    if right - left + 1 == p.length && s_hash == p_hash
      res << left
    end

    right += 1
  end

  res
end
```

算法复杂度：时间复杂度为 O(n)，其中 n 是字符串 s 的长度。空间复杂度为 O(1)，因为哈希表的大小是固定的，不随输入而变化。