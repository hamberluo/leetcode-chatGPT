题目编号：696

题目：计数二进制子串

难度：简单

考察范围：字符串、正则表达式

题干：给定一个字符串 s，计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。

解题思路：我们可以通过正则表达式来匹配符合条件的子串，然后统计数量即可。具体来说，我们可以先将字符串 s 中连续的 0 或 1 合并成一个字符，比如将 "000111" 合并成 "03" 和 "02"，然后再通过正则表达式匹配符合条件的子串，具体正则表达式为 /(0+1+|1+0+)/g，其中 (0+1+|1+0+) 表示匹配连续的 0 或 1，g 表示全局匹配。最后统计匹配到的子串数量即可。

解决方案：

```ruby
def count_binary_substrings(s)
  # 将连续的 0 或 1 合并成一个字符
  s = s.gsub(/0+/, '0').gsub(/1+/, '1')
  # 匹配符合条件的子串
  matches = s.scan(/(0+1+|1+0+)/)
  # 统计匹配到的子串数量
  matches.reduce(0) { |sum, match| sum + [match[0].size, match[1].size].min }
end
```

算法复杂度：时间复杂度为 O(n)，其中 n 为字符串 s 的长度，主要是正则表达式匹配的时间复杂度。空间复杂度为 O(n)，主要是存储合并后的字符串和匹配到的子串。