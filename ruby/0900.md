题目编号：900

题目：RLE 迭代器

难度：中等

考察范围：数组、迭代器

题干：编写一个迭代器，通过给定的 RLE（run-length encoded）压缩字符串来迭代出原始数据。

迭代器由 RLEIterator(int[] A) 初始化，其中 A 是某个序列的 RLE 编码。更具体地，对于所有偶数 i，A[i] 告诉我们在原始序列中重复非负整数值 A[i + 1] 的次数。

迭代器支持一个函数：next(int n)，它用 n 步操作将指针移动到序列的下一个元素并返回该元素。如果剩余元素不足 n 个，则返回 -1 并将指针重置为初始位置。

例如，A = [3,8,0,9,2,5] 表示序列 [8,8,8,5,5]。迭代器初始化为 RLEIterator(A) 并在调用 next(2) 之后，返回 8，因为序列中还剩下两个元素。接下来调用 next(1) 返回 8，因为序列中还剩下一个元素。最后调用 next(1) 返回 5，并且指针重置为初始位置。

解题思路：使用一个指针记录当前位置，每次调用 next 函数时，从当前位置开始遍历数组，找到第一个大于等于 n 的偶数位置 i，然后将 A[i] 减去 n，如果 A[i] 小于 n，则将 n 减去 A[i]，继续找下一个偶数位置，直到找到最后一个偶数位置或者 n 为 0。如果找到最后一个偶数位置，但是 n 还有剩余，则返回 -1。

解决方案：

```ruby
class RLEIterator
    def initialize(a)
        @a = a
        @p = 0
    end

    def next(n)
        while @p < @a.size && n > @a[@p]
            n -= @a[@p]
            @p += 2
        end
        if @p >= @a.size
            return -1
        else
            @a[@p] -= n
            return @a[@p+1]
        end
    end
end
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是数组的长度。