题目编号：276

题目：栅栏涂色

难度：中等

考察范围：动态规划

题干：有一个栅栏，它有 n 个柱子，现在你需要给柱子涂上 k 种颜色中的一种或多种，相邻的柱子不能涂相同的颜色。你需要计算出涂色方案总数。

解题思路：动态规划

我们可以用 dp[i][0] 表示前 i 个柱子，最后两个柱子颜色不同的涂色方案数，用 dp[i][1] 表示前 i 个柱子，最后两个柱子颜色相同的涂色方案数。

对于 dp[i][0]，我们有两种情况：

1. 第 i 个柱子和第 i-1 个柱子颜色不同，那么第 i 个柱子可以涂 k-1 种颜色，dp[i][0] = dp[i-1][0] * (k-1) + dp[i-1][1] * (k-1)。

2. 第 i 个柱子和第 i-1 个柱子颜色相同，那么第 i 个柱子只能涂一种颜色，dp[i][0] = dp[i-1][0] * 1。

对于 dp[i][1]，我们也有两种情况：

1. 第 i 个柱子和第 i-1 个柱子颜色不同，那么第 i 个柱子只能涂一种颜色，dp[i][1] = dp[i-1][0] * 1。

2. 第 i 个柱子和第 i-1 个柱子颜色相同，那么第 i 个柱子只能涂和第 i-2 个柱子不同的颜色，dp[i][1] = dp[i-1][0] * (k-2)。

最终的答案就是 dp[n][0] + dp[n][1]。

解决方案：

```ruby
# @param {Integer} n
# @param {Integer} k
# @return {Integer}
def num_ways(n, k)
    return 0 if n == 0
    return k if n == 1
    dp = Array.new(n+1) { Array.new(2, 0) }
    dp[1][0] = k
    dp[1][1] = 0
    dp[2][0] = k * (k-1)
    dp[2][1] = k
    for i in 3..n
        dp[i][0] = dp[i-1][0] * (k-1) + dp[i-1][1] * (k-1)
        dp[i][1] = dp[i-1][0]
    end
    return dp[n][0] + dp[n][1]
end
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(n)。