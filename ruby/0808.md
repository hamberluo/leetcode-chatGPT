题目编号：808

题目：分汤

难度：中等

考察范围：递归、动态规划

题干：有 A 和 B 两个汤，初始时，A 和 B 均有 N 毫升汤。有四种操作：

1. 提供 100ml 的汤A 和 0ml 的汤B。
2. 提供 75ml 的汤A 和 25ml 的汤B。
3. 提供 50ml 的汤A 和 50ml 的汤B。
4. 提供 25ml 的汤A 和 75ml 的汤B。

当我们把两种汤分别喝掉一些时，剩下的汤就会组合在一起。如果我们倾倒任何一种汤，剩下的汤将被扔掉。

我们希望结束时，恰好剩下一半的汤A 和一半的汤B。

注意，我们不能在汤中倒入任何东西。只能从中取出一些东西。

解题思路：这是一道典型的递归问题。我们可以用递归函数 `dfs(a, b, c, d)` 表示当前 A 汤有 a 毫升，B 汤有 b 毫升，我们需要倾倒 c 毫升 A 汤和 d 毫升 B 汤，使得最终 A 汤和 B 汤都剩下 N/2 毫升。我们可以用一个二维数组 `memo` 记录已经计算过的状态，避免重复计算。

解决方案：

```ruby
def soup_servings(n)
  return 1.0 if n >= 4800 # 特判，当 n 大于等于 4800 时，返回 1.0
  memo = Array.new(n+1) { Array.new(n+1, 0.0) } # 初始化 memo 数组
  dfs(n, n, memo) # 调用递归函数
end

def dfs(a, b, memo)
  return memo[a][b] if memo[a][b] > 0 # 如果 memo 数组中已经有了当前状态的值，直接返回
  return 0.5 if a <= 0 && b <= 0 # 如果 A 汤和 B 汤都已经为空，返回 0.5
  return 1.0 if a <= 0 # 如果 A 汤已经为空，返回 1.0
  return 0.0 if b <= 0 # 如果 B 汤已经为空，返回 0.0
  memo[a][b] = 0.25 * (dfs(a-100, b, memo) + dfs(a-75, b-25, memo) + dfs(a-50, b-50, memo) + dfs(a-25, b-75, memo)) # 计算当前状态的值
end
```

算法复杂度：时间复杂度为 O(N^2)，空间复杂度为 O(N^2)。其中 N 为汤的初始容量。