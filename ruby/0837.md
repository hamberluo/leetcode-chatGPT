题目编号：837

题目：新21点

难度：中等

考察范围：动态规划

题干：爱丽丝参与一个大致基于纸牌游戏 “21 点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从牌顶抽取一张牌，使得她的分数增加牌面的点数。 例如，如果她从牌顶抽到的牌面是 3，她的分数将变为 3。

爱丽丝没有任何自己的牌；每次她获得的牌都来自于牌堆中剩下的牌。 

求爱丽丝获胜的概率，假设牌堆无限大。

解题思路：动态规划

我们可以用 dp[x] 表示从得分为 x 的情况开始游戏并且获胜的概率，目标是求 dp[0] 的值。

根据规则，当分数达到或超过 K 时游戏结束，结束时如果分数不超过 N 你会获胜，否则你会输。因此当 K≤x≤min(N,K+W−1) 时有 dp[x]=1.0，因为在这些情况下你只需要不抽取牌就能获胜。

当 x>min(N,K+W−1) 时有 dp[x]=0.0，因为你已经输了。

对于其余的 x，你可以抽取任意一张牌 j∈[1,W]。这会导致你的分数变为 x+j，同时有一定概率 p=1/W 获胜，这样状态转移方程如下：

dp[x]=(dp[x+1]+dp[x+2]+⋯+dp[x+W]) / W

这是因为你有等概率的 W 种不同的结果，这些结果的分数分别为 x+1,x+2,…,x+W，并且这些结果的概率相加为 1。

最终的答案即为 dp[0]。

解决方案：

```ruby
# @param {Integer} n
# @param {Integer} k
# @param {Integer} max_points
# @return {Float}
def new21_game(n, k, max_points)
  return 1.0 if k == 0
  dp = Array.new(k + max_points) { 0.0 }
  (k..n).each { |i| dp[i] = 1.0 }
  sum = (n - k + 1).to_f
  (k - 1).downto(0) do |i|
    dp[i] = sum / max_points
    sum += dp[i] - dp[i + max_points]
  end
  dp[0]
end
```

算法复杂度：时间复杂度 O(N+W)，空间复杂度 O(N+W)。