题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许重复歌曲）。请你为她按如下规则创建一个播放列表：

每首歌至少播放一次。
一首歌只有在其他 K 首歌播放完之后才能再次播放。
返回可以创建的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

解题思路：动态规划

设 dp[i][j] 表示在播放列表中放置 i 首歌，其中有 j 首不同的歌的方案数。考虑 dp[i][j] 与 dp[i-1][j-1] 和 dp[i-1][j] 之间的关系。

当我们有 dp[i-1][j-1] 首不同的歌时，我们可以在最后一首歌后面加入一首新的歌，此时有 j 首不同的歌。

当我们有 dp[i-1][j] 首不同的歌时，我们可以在最后一首歌后面加入一首已经出现过的歌，此时有 j 首不同的歌；或者我们可以在最后一首歌后面加入一首新的歌，此时有 j+1 首不同的歌。

因此，我们有以下转移方程：

dp[i][j] = dp[i-1][j-1] * (N-j+1) + dp[i-1][j] * max(j-K, 0)

其中，第一项表示在最后一首歌后面加入一首新的歌，第二项表示在最后一首歌后面加入一首已经出现过的歌或者一首新的歌。

最终的答案即为 dp[L][N]。

解决方案：

```ruby
def num_music_playlists(n, l, k)
  mod = 10**9 + 7
  dp = Array.new(l+1) { Array.new(n+1, 0) }
  dp[0][0] = 1
  (1..l).each do |i|
    (1..n).each do |j|
      dp[i][j] = (dp[i-1][j-1] * (n-j+1) + dp[i-1][j] * [j-k, 0].max) % mod
    end
  end
  dp[l][n]
end
```

算法复杂度：时间复杂度 O(LN)，空间复杂度 O(LN)。