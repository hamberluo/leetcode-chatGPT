题目编号：740

题目：删除与获得点数

难度：中等

考察范围：动态规划

题干：

给定一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1:

输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。

示例 2:

输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 获得 3 个点数，接着要删除两个 2 和一个 4。
之后，删除 3 获得 3 个点数，再删除一个 3 获得 3 个点数。总共获得 9 个点数。

注意:

nums的长度最大为20000。
每个整数nums[i]的大小都在[1, 10000]范围内。

解题思路：

本题可以使用动态规划来解决。

首先，我们需要统计每个数字出现的次数，然后对于每个数字，我们可以选择删除它或者不删除它。

如果我们选择删除它，那么我们可以获得该数字出现次数乘以该数字的点数，同时需要删除所有等于该数字加减1的数字。

如果我们选择不删除它，那么我们需要跳过该数字，同时需要考虑前面已经删除的数字对后面的影响。

因此，我们可以定义一个数组dp，其中dp[i]表示前i个数字能够获得的最大点数。对于第i个数字，我们可以选择删除它或者不删除它，因此有以下两种情况：

1. 删除第i个数字，此时我们需要删除所有等于nums[i]+1和nums[i]-1的数字，因此可以获得nums[i]*count[i]个点数，其中count[i]表示数字i出现的次数。此时，我们需要考虑前i-2个数字能够获得的最大点数，因此dp[i]=dp[i-2]+nums[i]*count[i]。

2. 不删除第i个数字，此时我们需要跳过该数字，同时需要考虑前i-1个数字能够获得的最大点数，因此dp[i]=dp[i-1]。

综上所述，我们可以得到状态转移方程：

dp[i]=max(dp[i-2]+nums[i]*count[i], dp[i-1])

最终的答案即为dp[n]，其中n为数组的长度。

解决方案：

```ruby
def delete_and_earn(nums)
    n = nums.length
    return 0 if n == 0
    max_val = nums.max
    sum = Array.new(max_val+1, 0)
    dp = Array.new(max_val+1, 0)
    nums.each do |num|
        sum[num] += num
    end
    dp[1] = sum[1]
    dp[2] = [dp[1], sum[2]].max
    (3..max_val).each do |i|
        dp[i] = [dp[i-2]+sum[i], dp[i-1]].max
    end
    return dp[max_val]
end
```

算法复杂度：

时间复杂度：O(n)，其中n为数组的长度。

空间复杂度：O(max_val)，其中max_val为数组中的最大值。