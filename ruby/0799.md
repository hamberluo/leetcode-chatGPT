题目编号：799

题目：香槟塔

难度：中等

考察范围：动态规划

题干：我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，例如，第一层的玻璃杯满了，溢出了一半的香槟到第二层的左右两边的玻璃杯中，如图所示：

现在当顶层的杯子第一次满的时候，找到最下面一层满足条件的玻璃杯，假设该层位于第m行，那么就在第m行的正中间输出“m.x”，其中m是行数，x是该行中间的玻璃杯序号，按照从上往下，从左往右的顺序标号。然后，将额外的香槟全部倾倒在这个玻璃杯中，直到这个玻璃杯溢出或所有的香槟都倒完为止。

例如，在倾倒一杯香槟后，最下面一层填充满了香槟，所以输出“3.1”（第三行的中间的玻璃杯），然后，我们将剩余的香槟倾倒在这个玻璃杯中，直到它溢出。注意，每个玻璃杯最多只能盛放一杯香槟，其中超过一杯的香槟会立刻溢出。

解题思路：动态规划

我们可以用一个二维数组dp[i][j]表示第i行第j个杯子中的香槟量，初始化为0。然后从第一个杯子开始倒香槟，每次倒入的香槟量为1，如果当前杯子中的香槟量超过1，那么就会溢出，溢出的香槟平分到左右两个杯子中。具体实现可以参考下面的代码。

解决方案：

```ruby
def champagne_tower(poured, query_row, query_glass)
  dp = Array.new(101) { Array.new(101, 0) }
  dp[0][0] = poured
  (0..query_row).each do |i|
    (0..i).each do |j|
      if dp[i][j] > 1
        dp[i+1][j] += (dp[i][j] - 1) / 2.0
        dp[i+1][j+1] += (dp[i][j] - 1) / 2.0
        dp[i][j] = 1
      end
    end
  end
  dp[query_row][query_glass].clamp(0, 1)
end
```

算法复杂度：时间复杂度为O(n^2)，空间复杂度为O(n^2)。其中n为金字塔的高度。