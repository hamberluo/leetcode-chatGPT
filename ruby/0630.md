题目编号：630

题目：课程表 III

难度：中等

考察范围：贪心算法、堆

题干：

这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时才能完成，你将会从第 1 天开始。

给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。

示例：

输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 200 天关闭课程。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 且第 1250 天是关闭课程时间。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天时关闭它。

注意:

整数 1 <= d, t, n <= 10,000 。
你可以按任意顺序完成课程，输入数组没有顺序要求。

解题思路：

首先，我们可以将所有课程按照关闭时间从小到大排序，这样我们可以保证在某个时间点之前的课程都可以修完。

接着，我们可以使用一个变量 time 来记录当前时间，从第 1 天开始，我们依次遍历每个课程，如果当前时间加上该课程的持续时间小于等于该课程的关闭时间，那么我们就可以修这门课程，否则我们就需要从已经修的课程中找到持续时间最长的一门课程，将其替换成当前课程。

我们可以使用一个最大堆来维护已经修的课程，每次需要替换时，我们就将持续时间最长的课程弹出堆，然后将当前课程加入堆中。

最后，堆的大小就是我们最多可以修的课程数。

解决方案：

```ruby
def schedule_course(courses)
  courses.sort_by!(&:last)
  heap = []
  time = 0
  courses.each do |t, d|
    if time + t <= d
      heap << t
      time += t
    elsif !heap.empty? && heap.max > t
      time += t - heap.max
      heap.pop
      heap << t
    end
  end
  heap.size
end
```

算法复杂度：O(nlogn)