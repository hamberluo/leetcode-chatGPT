题目编号：730

题目：统计不同回文子序列

难度：困难

考察范围：动态规划、字符串处理

题干：

给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并返回该数字与 10^9 + 7 的模。

通过从 S 中删除 0 个或多个字符来获得子序列。

如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。

如果对于某个 i，A_i != B_i，那么 A_1, A_2, ... 和 B_1, B_2, ... 这两个字符序列是不同的。

示例：

输入：
S = 'bccb'
输出：
6
解释：
6 个不同的非空回文子序列为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。

解题思路：

本题可以使用动态规划来解决。我们可以定义 dp[i][j] 表示 S[i..j] 中不同的非空回文子序列个数。其中，i 和 j 分别表示字符串 S 的起始和结束位置。

当 S[i] == S[j] 时，我们可以找到一个新的回文子序列 S[i..j]，它的长度为 j-i+1。此外，对于 S[i+1..j-1] 中的每个回文子序列，我们都可以将 S[i] 和 S[j] 附加到两端，从而得到一个新的回文子序列。因此，我们可以得到如下的状态转移方程：

dp[i][j] = dp[i+1][j-1] * 2 + 2

当 S[i] != S[j] 时，S[i] 和 S[j] 不可能同时出现在同一个回文子序列中。因此，我们需要分别计算 S[i+1..j] 和 S[i..j-1] 中的回文子序列个数，然后将它们相加。具体地，我们可以得到如下的状态转移方程：

dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]

需要注意的是，当 S[i] == S[j] 时，我们计算的 dp[i+1][j-1] 可能包含空回文子序列。因此，我们需要将其减去 1，即：

dp[i][j] = dp[i+1][j-1] * 2 + 2 - (S[i] == S[j] ? 1 : 0)

最终的答案即为 dp[0][n-1]，其中 n 是字符串 S 的长度。

解决方案：

```ruby
MOD = 10**9 + 7

def count_palindromic_subsequences(s)
  n = s.size
  dp = Array.new(n) { Array.new(n, 0) }
  (0...n).each { |i| dp[i][i] = 1 }

  (n-2).downto(0) do |i|
    (i+1...n).each do |j|
      if s[i] == s[j]
        l, r = i+1, j-1
        while l <= r && s[l] != s[i] do l += 1 end
        while l <= r && s[r] != s[i] do r -= 1 end
        if l > r
          dp[i][j] = dp[i+1][j-1] * 2 + 2
        elsif l == r
          dp[i][j] = dp[i+1][j-1] * 2 + 1
        else
          dp[i][j] = dp[i+1][j-1] * 2 - dp[l+1][r-1]
        end
      else
        dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]
      end
      dp[i][j] %= MOD
      dp[i][j] += MOD if dp[i][j] < 0
    end
  end

  dp[0][n-1]
end
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。