题目编号：375

题目：猜数字大小 II

难度：中等

考察范围：动态规划

题干：我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，才算游戏结束。

给定一个代表游戏规则的正整数 n，你需要给出一个能够保证能赢的最小金额 x。

解题思路：动态规划

这道题可以用动态规划来解决。我们定义 dp[i][j] 表示在区间 [i,j] 中猜数字所需的最小金额。那么最终的答案就是 dp[1][n]。

对于 dp[i][j]，我们可以枚举猜的数字 x，那么有两种情况：

1. 猜的数字 x 正好是答案，那么不需要再猜了，所以需要支付的金额为 0，即 dp[i][j] = 0。

2. 猜的数字 x 不是答案，那么需要支付 x 的金额，然后根据猜的结果，我们需要在区间 [i,x-1] 或者 [x+1,j] 中继续猜。因为我们希望最坏情况下需要支付的金额最小，所以我们选择两种情况中的较大值，即 dp[i][j] = \min_{x=i}^{j} \{x + \max(dp[i][x-1], dp[x+1][j])\}。

最终的答案就是 dp[1][n]。

解决方案：

```ruby
def get_money_amount(n)
  dp = Array.new(n+1) { Array.new(n+1, 0) }
  (2..n).each do |len|
    (1..n-len+1).each do |start|
      min_res = Float::INFINITY
      (start..start+len-1).each do |x|
        res = x + [dp[start][x-1], dp[x+1][start+len-1]].max
        min_res = [min_res, res].min
      end
      dp[start][start+len-1] = min_res
    end
  end
  dp[1][n]
end
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。