题目编号：391

题目：给定一个二维的网格图，每个格子可能是以下三种之一：

1. 0 表示空单元格
2. 1 表示墙壁，不可经过
3. 2 表示起点
4. 3 表示终点

你的任务是找到从起点到终点的最短路径，只能经过空单元格。你可以向上、下、左、右四个方向移动。

难度：困难

考察范围：图论、广度优先搜索

题干：给定一个二维的网格图，每个格子可能是以下三种之一：

1. 0 表示空单元格
2. 1 表示墙壁，不可经过
3. 2 表示起点
4. 3 表示终点

你的任务是找到从起点到终点的最短路径，只能经过空单元格。你可以向上、下、左、右四个方向移动。

解题思路：这是一道典型的图论问题，可以使用广度优先搜索来解决。我们可以将起点加入队列中，然后不断从队列中取出元素进行扩展，直到找到终点为止。

在扩展一个节点时，我们可以将其上下左右四个方向的节点加入队列中，但需要注意以下几点：

1. 如果该节点已经被访问过，或者是墙壁，则不需要加入队列中。
2. 如果该节点是终点，则直接返回当前步数。
3. 如果该节点是空单元格，则将其标记为已访问，并加入队列中。

解决方案：

```ruby
def shortest_path(grid)
  # 定义上下左右四个方向
  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  # 定义队列和访问数组
  queue = []
  visited = Array.new(grid.size) { Array.new(grid[0].size, false) }
  # 将起点加入队列中
  queue << [0, 0, 0]
  visited[0][0] = true
  # 开始广度优先搜索
  while !queue.empty?
    # 取出队列中的第一个元素
    x, y, steps = queue.shift
    # 扩展上下左右四个方向的节点
    directions.each do |dx, dy|
      nx, ny = x + dx, y + dy
      # 如果该节点已经被访问过，或者是墙壁，则不需要加入队列中
      next if nx < 0 || nx >= grid.size || ny < 0 || ny >= grid[0].size || visited[nx][ny] || grid[nx][ny] == 1
      # 如果该节点是终点，则直接返回当前步数
      return steps + 1 if grid[nx][ny] == 3
      # 如果该节点是空单元格，则将其标记为已访问，并加入队列中
      visited[nx][ny] = true
      queue << [nx, ny, steps + 1]
    end
  end
  # 如果没有找到终点，则返回 -1
  -1
end
```

算法复杂度：时间复杂度为 O(mn)，其中 m 和 n 分别为网格图的行数和列数。空间复杂度为 O(mn)，需要使用 visited 数组来记录每个节点是否被访问过。