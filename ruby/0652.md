题目编号：652

题目：寻找重复的子树

难度：中等

考察范围：二叉树、哈希表

题干：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

解题思路：我们可以使用哈希表来记录每个子树出现的次数，具体步骤如下：

1. 定义一个哈希表，用于记录每个子树出现的次数。
2. 定义一个数组，用于存储所有重复的子树的根结点。
3. 定义一个递归函数，用于遍历二叉树的每个子树，并将子树的结构转换成字符串作为哈希表的键。
4. 在递归函数中，如果当前子树的字符串在哈希表中出现过，则将该子树的根结点加入到数组中。
5. 最后返回数组即可。

解决方案：

```ruby
def find_duplicate_subtrees(root)
  # 定义哈希表和结果数组
  hash = {}
  res = []

  # 定义递归函数
  def traverse(node, hash, res)
    # 如果当前节点为空，则返回空字符串
    return "" if node.nil?

    # 将左右子树的字符串和当前节点的值拼接成一个字符串
    str = node.val.to_s + traverse(node.left, hash, res) + traverse(node.right, hash, res)

    # 如果该字符串在哈希表中出现过，则将该子树的根结点加入到结果数组中
    if hash[str]
      hash[str] += 1
      res << node if hash[str] == 2
    else
      hash[str] = 1
    end

    # 返回当前子树的字符串
    str
  end

  # 调用递归函数
  traverse(root, hash, res)

  # 返回结果数组
  res
end
```

算法复杂度：时间复杂度为 O(n)，其中 n 是二叉树中的节点数。在递归函数中，每个节点都会被访问一次，并且哈希表的插入和查询操作的时间复杂度均为 O(1)。空间复杂度为 O(n)，其中 n 是二叉树中的节点数。哈希表中最多存储 n 个节点的字符串，递归栈的深度也不会超过 n。