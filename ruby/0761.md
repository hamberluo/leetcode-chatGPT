题目编号：761

题目：特殊的二进制序列

难度：困难

考察范围：字符串、递归

题干：

特殊的二进制序列是具有以下两个性质的二进制序列：

0 的数量与 1 的数量相等。
二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。
给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)

在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？

解题思路：

题目中要求交换两个连续的特殊子串，使得字典序最大。因此，我们需要先将特殊子串进行排序，然后再进行交换。

对于一个特殊的二进制序列，我们可以将其分解为若干个特殊子串。对于一个特殊子串，它的形式只有以下三种：

1. 1
2. 0 + 特殊子串 + 1
3. 若干个特殊子串组成的序列

对于第一种情况，显然不需要进行排序。对于第二种情况，我们只需要将特殊子串进行排序即可。对于第三种情况，我们需要将每个特殊子串进行排序，然后将它们按照字典序从大到小进行拼接。

最后，我们将所有特殊子串按照字典序从大到小进行拼接即可。

解决方案：

```ruby
def makeLargestSpecial(s)
    return s if s.size < 2
    cnt, i, res = 0, 0, []
    s.each_char.with_index do |c, j|
        cnt += (c == '1') ? 1 : -1
        if cnt == 0
            res << '1' + makeLargestSpecial(s[i+1...j]) + '0'
            i = j + 1
        end
    end
    res.sort!.reverse.join
end
```

算法复杂度：O(nlogn)，其中 n 是字符串 s 的长度。排序的时间复杂度为 O(nlogn)，递归的时间复杂度为 O(n)。