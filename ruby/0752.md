题目编号：752

题目：打开转盘锁

难度：中等

考察范围：搜索、广度优先搜索

题干：你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字：'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'。每个拨轮可以自由旋转：例如把'9'变为'0'，'0'变为'9'。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为'0000'，一个代表四个拨轮的数字的字符串。

列表deadends包含了一些死亡数字，即无法解锁的数字。

请你计算并返回从初始数字'0000'到锁的目标数字的最少旋转次数，如果无论如何不能达到锁的目标数字，则返回-1。

解题思路：本题可以使用广度优先搜索来解决。从初始状态'0000'开始，每次将当前状态的每个拨轮向上或向下旋转一位，得到8个新的状态。如果新状态不在deadends中且没有被访问过，则将其加入队列中，并标记为已访问。重复上述步骤，直到队列为空或者找到目标状态。

解决方案：

```ruby
def open_lock(deadends, target)
    # 将死亡数字转换为哈希表，方便查找
    dead = {}
    deadends.each { |d| dead[d] = true }
    # 如果初始状态就是死亡数字，则无法解锁
    return -1 if dead['0000']
    # 初始化队列和已访问哈希表
    queue = ['0000']
    visited = { '0000' => true }
    # 初始化步数
    step = 0
    # 广度优先搜索
    while !queue.empty?
        size = queue.size
        # 遍历当前层的所有状态
        size.times do
            cur = queue.shift
            # 如果找到目标状态，则返回步数
            return step if cur == target
            # 将当前状态的每个拨轮向上或向下旋转一位，得到8个新的状态
            8.times do |i|
                c = cur[i]
                # 向上旋转一位
                nxt1 = cur[0...i] + ((c == '9') ? '0' : (c.to_i + 1).to_s) + cur[(i+1)..-1]
                # 向下旋转一位
                nxt2 = cur[0...i] + ((c == '0') ? '9' : (c.to_i - 1).to_s) + cur[(i+1)..-1]
                # 如果新状态不在deadends中且没有被访问过，则将其加入队列中，并标记为已访问
                if !dead[nxt1] && !visited[nxt1]
                    queue << nxt1
                    visited[nxt1] = true
                end
                if !dead[nxt2] && !visited[nxt2]
                    queue << nxt2
                    visited[nxt2] = true
                end
            end
        end
        # 搜索完一层，步数加1
        step += 1
    end
    # 如果队列为空，则无法解锁
    return -1
end
```

算法复杂度：时间复杂度为O(10000 * 8)，空间复杂度为O(10000)。其中10000是状态的总数，8是每个状态的拨轮数。