题目编号：816

题目：模糊坐标

难度：中等

考察范围：字符串、组合数学

题干：

给定一个字符串 S，我们可以将它表示成一个二维数组的形式，其中每个字符为 '0' 表示该位置是空白，字符 '1' 表示该位置是障碍物，字符 'S' 表示起点，字符 'T' 表示终点。

你需要找到从起点到终点的最短路径，并返回路径上的所有坐标点。

以下是一个例子：

输入：
S = "S000
0000
0000
000T"

输出：[(0,0),(0,1),(0,2),(0,3),(1,3),(2,3),(3,3)]

解题思路：

题目要求我们找到从起点到终点的最短路径，并返回路径上的所有坐标点。我们可以使用广度优先搜索（BFS）来解决这个问题。

首先，我们需要将字符串 S 转换成一个二维数组，方便我们进行搜索。然后，我们从起点开始进行 BFS，每次将当前位置的上下左右四个方向进行扩展，直到找到终点为止。在搜索过程中，我们需要记录每个位置的前驱节点，以便最后回溯路径。

最后，我们可以通过回溯前驱节点，得到从起点到终点的最短路径，并返回路径上的所有坐标点。

解决方案：

```ruby
def ambiguous_coordinates(s)
  # 去掉字符串首尾的引号
  s = s[1..-2]
  n = s.size

  # 枚举分割点
  (1..n-1).map do |i|
    left = s[0...i]
    right = s[i..-1]

    # 枚举左右两个子串的所有合法表示
    lefts = get_valid_numbers(left)
    rights = get_valid_numbers(right)

    # 生成所有可能的坐标
    lefts.product(rights).map { |x, y| "(#{x}, #{y})" }
  end.flatten
end

# 获取一个字符串的所有合法表示
def get_valid_numbers(s)
  n = s.size
  return [] if n == 0

  # 如果只有一个字符，那么它一定是合法的
  return [s] if n == 1

  # 如果第一个字符是 0，那么只有一种合法表示：0.xxx
  if s[0] == '0'
    return ["0.#{s[1..-1]}"] if s[1..-1] != '0'
    return ['0']
  end

  # 如果最后一个字符是 0，那么只有一种合法表示：xxx.0
  if s[-1] == '0'
    return [s]
  end

  # 否则，有两种合法表示：xxx.xxx 和 xxxxx.xx
  [s] + (1..n-1).map { |i| "#{s[0...i]}.#{s[i..-1]}" }
end
```

算法复杂度：时间复杂度为 O(n^3)，其中 n 是字符串的长度。空间复杂度为 O(n^2)。