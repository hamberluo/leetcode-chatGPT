题目编号：898

题目：子数组按位或操作

难度：中等

考察范围：位运算、动态规划

题干：

给定一个整数数组 `A`，找到 `A` 中最大的连续子数组，使得该子数组中的每个元素对应二进制表示的每一位都相同。

返回这个子数组的长度。如果不存在任何一个符合要求的子数组，返回 0。

示例 1:

输入: [0,1,2,3,4]
输出: 4
解释:
最大的连续子数组就是 [0, 1, 2, 3]，因为这个子数组中的每个元素对应二进制表示的每一位都相同。

示例 2:

输入: [1,2,4]
输出: 2
解释:
最大的连续子数组为 [2,4]，因为 [1,2] 和 [4] 本身并不是连续的。

解题思路：

本题需要找到最大的连续子数组，使得该子数组中的每个元素对应二进制表示的每一位都相同。因此，我们可以考虑使用位运算来解决这个问题。

我们可以从最高位开始，依次判断每一位是否相同。如果相同，则说明这一位上的值都是相同的，我们可以将这一位上的值加入到结果中。如果不同，则说明这一位上的值不相同，我们需要将当前的结果清零，并从下一位开始重新计算。

解决方案：

我们可以使用动态规划来解决这个问题。具体来说，我们可以定义一个二维数组 `dp`，其中 `dp[i][j]` 表示以 `A[i]` 结尾，且最高位为 `j` 的最大连续子数组长度。

对于每个位置 `i`，我们可以依次枚举最高位 `j`，并计算出以 `A[i]` 结尾，且最高位为 `j` 的最大连续子数组长度。具体来说，我们可以将 `A[i]` 与 `j` 进行按位或操作，得到一个新的数 `x`，然后我们可以根据 `x` 的值来更新 `dp[i][j]`。如果 `x` 的最高位为 `j`，则说明 `A[i]` 可以加入到以 `A[i-1]` 结尾，且最高位为 `j` 的最大连续子数组中，此时有 `dp[i][j] = dp[i-1][j] + 1`。否则，说明以 `A[i]` 结尾，且最高位为 `j` 的最大连续子数组已经断开，此时有 `dp[i][j] = 1`。

最终的答案即为所有 `dp[i][j]` 中的最大值。

下面是具体的实现代码：

```ruby
def max_length(a)
  n = a.size
  dp = Array.new(n) { Array.new(32, 0) }
  ans = 0
  (0...n).each do |i|
    x = a[i]
    (0...32).each do |j|
      if (x >> j) & 1 == 1
        dp[i][j] = i == 0 ? 1 : dp[i-1][j] + 1
      else
        dp[i][j] = 0
      end
      ans = [ans, dp[i][j]].max
    end
  end
  ans
end
```

算法复杂度：时间复杂度为 O(n\log m)，其中 m 表示数组中的最大值。空间复杂度为 O(n)。