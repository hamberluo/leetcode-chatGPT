题目编号：10

题目：正则表达式匹配

难度：困难

考察范围：动态规划、字符串匹配

题干：给定一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符
- '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。

说明:

- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 可以匹配任意数量的 a。

示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以匹配零个 'a'，'*' 可以匹配两个 'a'。

示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

解题思路：动态规划

首先，我们需要定义状态，设 dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配。

接下来，我们需要考虑状态转移方程。我们可以分为以下几种情况：

- 当 p[j-1] 是一个普通字符时，即 p[j-1] != '*' 时，我们需要判断 s[i-1] 是否等于 p[j-1]，如果相等，则 dp[i][j] = dp[i-1][j-1]，否则 dp[i][j] = false。
- 当 p[j-1] 是 '*' 时，我们需要分为两种情况：

- '*' 匹配零个前面的那一个元素，即 dp[i][j] = dp[i][j-2]。
- '*' 匹配一个或多个前面的那一个元素，即 dp[i][j] = dp[i-1][j]，当且仅当 s[i-1] 等于 p[j-2] 或 p[j-2] 等于 '.' 时。

最后，我们需要考虑初始状态，即当 s 和 p 都为空时，dp[0][0] = true，当 s 为空，p 不为空时，dp[0][j] 可能为 true，当 p 为空，s 不为空时，dp[i][0] 必定为 false。

解决方案：

```ruby
# @param {String} s
# @param {String} p
# @return {Boolean}
def is_match(s, p)
  m, n = s.size, p.size
  dp = Array.new(m+1) { Array.new(n+1, false) }
  dp[0][0] = true
  (0..m).each do |i|
    (1..n).each do |j|
      if p[j-1] == '*'
        dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j])
      else
        dp[i][j] = i > 0 && (s[i-1] == p[j-1] || p[j-1] == '.') && dp[i-1][j-1]
      end
    end
  end
  dp[m][n]
end
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。