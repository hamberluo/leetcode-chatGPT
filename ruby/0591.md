题目编号：591

题目：标签验证器

难度：困难

考察范围：字符串处理、正则表达式

题干：给定一个字符串表示一个 XML 文档，编写一个函数 `isValid(code)` 来验证这个文档是否合法。

解题思路：本题可以使用正则表达式来解决。首先，我们需要了解 XML 文档的基本结构和规则。XML 文档由标签和文本组成，标签分为开始标签和结束标签，开始标签和结束标签之间可以包含属性，属性由属性名和属性值组成，属性值可以用单引号或双引号括起来。XML 文档的根节点只能有一个，标签名必须符合命名规则，即只能包含字母、数字和下划线，且不能以数字开头。

根据上述规则，我们可以写出以下正则表达式：

```ruby
TAG_PATTERN = /<([A-Za-z][A-Za-z0-9]*)\b(?:\s+[A-Za-z][A-Za-z0-9]*=(?:"[^"]*"|'[^']*'))*\s*(\/?)>/
```

该正则表达式可以匹配开始标签和结束标签，其中：

- `<` 表示标签的开始；
- `([A-Za-z][A-Za-z0-9]*)` 表示标签名，必须以字母开头，后面可以跟字母、数字或下划线；
- `\b` 表示单词边界，用于避免标签名的一部分被误认为是标签的属性；
- `(?:\s+[A-Za-z][A-Za-z0-9]*=(?:"[^"]*"|'[^']*'))*` 表示标签的属性，其中 `(?:...)` 表示非捕获分组，`\s+` 表示至少一个空格，`[A-Za-z][A-Za-z0-9]*` 表示属性名，必须以字母开头，后面可以跟字母、数字或下划线，`=(?:"[^"]*"|'[^']*')` 表示属性值，可以用双引号或单引号括起来，中间的内容可以是任意字符，但不能包含引号；
- `\s*` 表示标签的属性和标签名之间可以有任意数量的空格；
- `(\/?)` 表示标签是否是自闭合标签，`\/?` 表示可选的斜杠。

接下来，我们需要检查 XML 文档的根节点是否符合规则。根节点必须是一个开始标签，且标签名必须符合命名规则。我们可以使用以下正则表达式来检查根节点：

```ruby
ROOT_PATTERN = /\A<([A-Za-z][A-Za-z0-9]*)\b(?:\s+[A-Za-z][A-Za-z0-9]*=(?:"[^"]*"|'[^']*'))*\s*(\/?)>\z/
```

该正则表达式与 TAG_PATTERN 的区别在于：

- `\A` 表示字符串的开始；
- `\z` 表示字符串的结束；
- `([A-Za-z][A-Za-z0-9]*)` 表示标签名，必须以字母开头，后面可以跟字母、数字或下划线；
- `(\/?)` 表示标签必须是开始标签，不能是结束标签。

最后，我们需要检查 XML 文档的开始标签和结束标签是否匹配。我们可以使用栈来实现。遍历 XML 文档，如果遇到开始标签，则将标签名入栈；如果遇到结束标签，则将栈顶元素出栈，并检查标签名是否匹配。如果栈为空或者标签名不匹配，则说明 XML 文档不合法。

解决方案：

```ruby
TAG_PATTERN = /<([A-Za-z][A-Za-z0-9]*)\b(?:\s+[A-Za-z][A-Za-z0-9]*=(?:"[^"]*"|'[^']*'))*\s*(\/?)>/
ROOT_PATTERN = /\A<([A-Za-z][A-Za-z0-9]*)\b(?:\s+[A-Za-z][A-Za-z0-9]*=(?:"[^"]*"|'[^']*'))*\s*(\/?)>\z/

def is_valid(code)
  stack = []
  code.scan(TAG_PATTERN) do |tag_name, is_self_closing|
    if is_self_closing.empty?
      stack.push(tag_name)
    else
      if stack.empty? || stack.pop != tag_name
        return false
      end
    end
  end
  stack.empty? && code =~ ROOT_PATTERN
end
```

算法复杂度：时间复杂度为 O(n)，其中 n 是字符串的长度。空间复杂度为 O(n)，其中 n 是字符串的长度，主要用于存储栈。