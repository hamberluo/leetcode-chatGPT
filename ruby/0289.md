题目编号：289

题目：生命游戏

难度：中等

考察范围：数组、模拟

题干：

根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个由 0 和 1 组成的二维网格，其中 0 表示死亡，1 表示生存。每个单元格都与其八个相邻位置（水平，垂直，对角线）中的单元格形成关系。按照以下规则更新网格：

- 任何活着的单元格，如果周围八个位置中有两个或三个单元格为活着的，则下一个状态为活着的，否则下一个状态为死亡。
- 任何死亡的单元格，如果周围八个位置中恰好有三个单元格为活着的，则下一个状态为活着的，否则下一个状态为死亡。

要求实现函数 `game_of_life(board)`，函数参数为一个二维数组 `board`，表示当前状态。函数需要将当前状态更新为下一个状态。

解题思路：

遍历整个二维数组，对于每个位置，统计其周围八个位置中活着的细胞数量，根据题目规则更新该位置的状态。由于需要同时更新所有位置，因此需要使用一个额外的数组来存储下一个状态。

解决方案：

```ruby
def game_of_life(board)
  m, n = board.length, board[0].length
  next_board = Array.new(m) { Array.new(n, 0) } # 存储下一个状态的数组

  # 遍历整个二维数组
  (0...m).each do |i|
    (0...n).each do |j|
      count = 0 # 统计周围活着的细胞数量
      (-1..1).each do |x|
        (-1..1).each do |y|
          next if x == 0 && y == 0 # 排除当前位置
          row, col = i + x, j + y
          count += 1 if row >= 0 && row < m && col >= 0 && col < n && board[row][col] == 1
        end
      end

      # 根据规则更新下一个状态
      if board[i][j] == 1
        next_board[i][j] = (count == 2 || count == 3) ? 1 : 0
      else
        next_board[i][j] = (count == 3) ? 1 : 0
      end
    end
  end

  # 将下一个状态复制回原数组
  (0...m).each do |i|
    (0...n).each do |j|
      board[i][j] = next_board[i][j]
    end
  end
end
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。其中 m 和 n 分别为二维数组的行数和列数。