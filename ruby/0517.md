题目编号：517

题目：超级洗衣机

难度：困难

考察范围：贪心算法

题干：假设有 n 台超级洗衣机放在同一排上。开始时，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n）台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物数量相等的最少的操作步数。如果不能使每台洗衣机中衣物的数量相等，则返回 -1。

解题思路：贪心算法

首先，我们需要计算出所有洗衣机中衣服的总数，如果不能被洗衣机的数量整除，那么就无法使每台洗衣机中衣物的数量相等，返回 -1。

然后，我们需要找到一个洗衣机，使得它的衣服数量最终能够达到平均值。我们可以从左到右遍历每个洗衣机，计算出当前洗衣机左边的衣服数量和右边的衣服数量，然后将这个洗衣机的衣服数量调整到平均值。这个调整的过程可以看作是将左边的衣服移动到右边或者将右边的衣服移动到左边，因此我们需要计算出左边和右边需要移动的衣服数量，然后取两者的最大值即可。

最后，我们需要将所有洗衣机的衣服数量调整到平均值，因此需要再次遍历每个洗衣机，计算出当前洗衣机左边的衣服数量和右边的衣服数量，然后将这个洗衣机的衣服数量调整到平均值。这个调整的过程同样可以看作是将左边的衣服移动到右边或者将右边的衣服移动到左边，因此我们需要计算出左边和右边需要移动的衣服数量，然后取两者的最大值即可。

解决方案：

```ruby
def find_min_moves(machines)
  sum = machines.sum
  return -1 if sum % machines.size != 0

  avg = sum / machines.size
  ans = 0
  cnt = 0

  machines.each do |num|
    cnt += num - avg
    ans = [ans, [cnt.abs, num - avg].max].max
  end

  ans
end
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。