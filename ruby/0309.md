题目编号：309

题目：最佳买卖股票时机含冷冻期

难度：中等

考察范围：动态规划

题干：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你必须在卖出股票之前持有该股票。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

解题思路：动态规划

- 状态定义：dp[i][0/1/2] 表示第 i 天结束后的「累计最大收益」。其中：

- 0 表示持有股票；
- 1 表示不持有股票，且处于冷冻期；
- 2 表示不持有股票，且不处于冷冻期。

- 状态转移：

- dp[i][0] 可以从 dp[i-1][0] 或者 dp[i-1][2] 转移而来，即前一天持有股票，或者前一天不持有股票且不处于冷冻期，今天买入股票。
- dp[i][1] 只能从 dp[i-1][0] 转移而来，即前一天持有股票，今天卖出股票并进入冷冻期。
- dp[i][2] 可以从 dp[i-1][1] 或者 dp[i-1][2] 转移而来，即前一天不持有股票且处于冷冻期，或者前一天不持有股票且不处于冷冻期。

- 初始状态：

- dp[0][0] = -prices[0]，即第一天买入股票；
- dp[0][1] = 0，第一天不可能处于冷冻期；
- dp[0][2] = 0，第一天不持有股票且不处于冷冻期。

- 最终结果：dp[n-1][1] 和 dp[n-1][2] 中的较大值，即最后一天不持有股票的最大收益。

解决方案：

```ruby
def max_profit(prices)
  n = prices.size
  return 0 if n < 2

  dp = Array.new(n) { Array.new(3, 0) }
  dp[0][0] = -prices[0]

  (1...n).each do |i|
    dp[i][0] = [dp[i-1][0], dp[i-1][2] - prices[i]].max
    dp[i][1] = dp[i-1][0] + prices[i]
    dp[i][2] = [dp[i-1][1], dp[i-1][2]].max
  end

  [dp[n-1][1], dp[n-1][2]].max
end
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(n)。