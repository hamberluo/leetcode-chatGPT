题目编号：903

题目：DI 序列

难度：困难

考察范围：动态规划

题干：

我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）

有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：

如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；
如果 S[i] == 'I'，那么 P[i] < P[i+1]。
如同答案一样，P 数组仅由整数 0, 1, ..., n 组成，且元素不重复。

给定一个有效排列 P，如果存在将其变为一个DI排列的方法，请你返回这个方法所需的 最少 操作次数。如果无法执行变化，请返回 -1。

解题思路：

这道题可以使用动态规划来解决。我们可以定义状态 dp[i][j] 表示前 i 个数中，最后一个数为 j 的最小操作次数。其中 j 的取值范围为 [0, n]。

对于 S[i] == 'D' 的情况，我们需要找到前 i 个数中最后一个比 j 小的数 k，然后将 k 到 j 的所有数加 1，这样才能满足 S[i] == 'D' 的要求。因此，我们可以枚举 k 的取值，然后转移方程为：

dp[i][j] = min(dp[i][j], dp[i-1][k] + (j-k))

对于 S[i] == 'I' 的情况，同理，我们需要找到前 i 个数中最后一个比 j 大的数 k，然后将 j 到 k 的所有数加 1，这样才能满足 S[i] == 'I' 的要求。因此，我们可以枚举 k 的取值，然后转移方程为：

dp[i][j] = min(dp[i][j], dp[i-1][k] + (j-k))

最终的答案即为 dp[n][0]，表示前 n 个数中最后一个数为 0 的最小操作次数。

解决方案：

```ruby
def min_operations(s)
  n = s.size
  dp = Array.new(n+1) { Array.new(n+1, Float::INFINITY) }
  dp[0][0] = 0

  (1..n).each do |i|
    (0..i).each do |j|
      if s[i-1] == 'D'
        (0...j).each do |k|
          dp[i][j] = [dp[i][j], dp[i-1][k] + (j-k)].min
        end
      else
        (j...i).each do |k|
          dp[i][j] = [dp[i][j], dp[i-1][k] + (k-j)].min
        end
      end
    end
  end

  dp[n].min == Float::INFINITY ? -1 : dp[n].min
end
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。