题目编号：823

题目：带因子的二叉树

难度：中等

考察范围：动态规划、树

题干：给出一个含有不重复整数元素的数组，每个整数均大于 1。

我们用这些整数来构建二叉树，每个整数可以使用任意次数。

其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？返回的结果应对 10^9 + 7 取余。

解题思路：动态规划

对于每个数，我们可以将其作为根节点，然后将其左右子树分别构建出来，最后将左右子树合并即可。

对于一个数 i，我们可以枚举其左右子树的根节点 j 和 k，如果 j 和 k 都在数组中出现过，那么我们就可以将以 i 为根节点的子树的方案数加上以 j 为根节点的子树的方案数乘以以 k 为根节点的子树的方案数。

具体来说，我们可以用一个哈希表来存储数组中的每个数出现的次数，然后对于每个数 i，我们枚举其左右子树的根节点 j 和 k，如果 j 和 k 都在哈希表中出现过，那么我们就可以将以 i 为根节点的子树的方案数加上以 j 为根节点的子树的方案数乘以以 k 为根节点的子树的方案数。

最终的答案即为所有以每个数为根节点的子树的方案数之和。

解决方案：

```ruby
MOD = 10**9 + 7

def num_factored_binary_trees(arr)
  n = arr.size
  arr.sort!
  dp = Hash.new(0)
  arr.each { |x| dp[x] = 1 }
  (1...n).each do |i|
    (0...i).each do |j|
      if arr[i] % arr[j] == 0
        k = arr[i] / arr[j]
        dp[arr[i]] += dp[arr[j]] * dp[k] % MOD if dp.key?(k)
      end
    end
  end
  dp.values.sum % MOD
end
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。