题目编号：440

题目：字典序的第K小数字

难度：困难

考察范围：数学、字符串

题干：给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

解题思路：首先我们需要了解什么是字典序。字典序就是按照字典顺序进行排序，例如 1, 10, 100, 2, 20, 200 的字典序排序为 1, 10, 100, 2, 20, 200。我们可以发现，字典序排序的规律是先按照第一位进行排序，如果第一位相同，则按照第二位进行排序，以此类推。

对于本题，我们可以将 1 到 n 的所有数字按照字典序排序，然后返回第 k 个数字即可。但是这种方法的时间复杂度为 O(nlogn)，无法通过本题。

我们可以换一种思路，从 1 开始，依次遍历每个数字，计算它的子树中有多少个数字。例如，对于数字 1，它的子树中有 10 个数字，分别为 1, 10, 100, 101, 102, 103, 104, 105, 106, 107。如果 k 小于等于 10，则说明第 k 个数字在数字 1 的子树中，我们可以继续遍历数字 1 的子树；否则，说明第 k 个数字不在数字 1 的子树中，我们需要遍历数字 2 的子树。

具体来说，我们可以先计算出以数字 i 为前缀的数字有多少个，记为 count。如果 k 小于等于 count，则说明第 k 个数字在以数字 i 为前缀的数字中，我们可以继续遍历以数字 i 为前缀的数字；否则，说明第 k 个数字不在以数字 i 为前缀的数字中，我们需要遍历以数字 i+1 为前缀的数字。

解决方案：

```java
class Solution {
    public int findKthNumber(int n, int k) {
        int cur = 1;
        k--;
        while (k > 0) {
            long count = getCount(n, cur, cur + 1);
            if (count <= k) {
                cur++;
                k -= count;
            } else {
                cur *= 10;
                k--;
            }
        }
        return cur;
    }

    private long getCount(int n, long start, long end) {
        long count = 0;
        while (start <= n) {
            count += Math.min(n + 1, end) - start;
            start *= 10;
            end *= 10;
        }
        return count;
    }
}
```

算法复杂度：时间复杂度为 O(logn)，空间复杂度为 O(1)。