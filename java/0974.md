题目编号：974

题目：和可被 K 整除的子数组

难度：中等

考察范围：前缀和、哈希表

题干：给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

解题思路：使用前缀和和哈希表来解决该问题。

首先，我们需要知道什么是前缀和。前缀和是指从数组的第一个元素开始，到当前位置的所有元素的和。例如，对于数组 [1, 2, 3, 4, 5]，它的前缀和数组为 [1, 3, 6, 10, 15]。

接下来，我们可以使用前缀和来计算子数组的和。对于数组 A，我们可以计算出它的前缀和数组 P，其中 P[i] 表示 A[0] 到 A[i-1] 的和。那么，对于任意的子数组 A[i:j]，它的和可以表示为 P[j+1] - P[i]。

接着，我们需要知道什么是同余定理。同余定理是指，如果两个数除以一个数的余数相同，那么这两个数对这个数的余数也相同。例如，对于数 7，它除以 3 的余数为 1，那么对于任意的整数 x 和 y，如果 x 和 y 除以 3 的余数相同，那么 x 和 y 对 3 取余的结果也相同。

有了前缀和和同余定理的基础知识，我们就可以开始解决这个问题了。我们可以遍历数组 A，计算出它的前缀和数组 P。然后，对于任意的子数组 A[i:j]，我们可以计算出它的和 S = P[j+1] - P[i]。如果 S 能够被 K 整除，那么就说明 A[i:j] 是符合要求的子数组。

但是，我们不能直接遍历所有的子数组，因为这样的时间复杂度是 O(n^2)，会超时。因此，我们需要使用哈希表来优化算法。我们可以遍历数组 A，计算出它的前缀和数组 P，并将 P[i] 对 K 取余的结果作为键，出现次数作为值，存储到哈希表中。然后，对于任意的子数组 A[i:j]，我们可以计算出它的和 S = P[j+1] - P[i]，并将 S 对 K 取余的结果作为键，在哈希表中查找出现次数，将结果累加到答案中。

解决方案：

```java
class Solution {
    public int subarraysDivByK(int[] A, int K) {
        int[] count = new int[K];
        count[0] = 1;
        int sum = 0;
        int ans = 0;
        for (int i = 0; i < A.length; i++) {
            sum = (sum + A[i]) % K;
            if (sum < 0) {
                sum += K;
            }
            ans += count[sum];
            count[sum]++;
        }
        return ans;
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(K)。