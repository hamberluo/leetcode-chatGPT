题目编号：135

题目：分发糖果

难度：困难

考察范围：贪心算法

题干：假设你是一个老师，班上有 n 名学生。每个学生从 0 到 n - 1 编号，每个学生的评分都不相同。你的任务是给这些学生朝着右边的方向发糖果。你需要按照以下的要求，给这些学生分糖果：

每个学生至少分配到 1 个糖果。
相邻的学生中，评分高的学生必须获得更多的糖果。
那么这样最少需要分配多少个糖果呢？

解题思路：贪心算法

首先，每个学生至少分配到 1 个糖果，所以我们可以先将每个学生的糖果数量都初始化为 1。

然后，我们从左到右遍历一遍学生，如果当前学生的评分比前一个学生高，那么当前学生的糖果数量就比前一个学生多 1。

接着，我们从右到左再遍历一遍学生，如果当前学生的评分比后一个学生高，并且当前学生的糖果数量不大于后一个学生的糖果数量，那么当前学生的糖果数量就要更新为后一个学生的糖果数量加 1。

最后，我们将所有学生的糖果数量加起来，就是最少需要分配的糖果数量。

解决方案：

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] candies = new int[n];
        Arrays.fill(candies, 1); // 初始化每个学生的糖果数量为 1

        // 从左到右遍历一遍学生，如果当前学生的评分比前一个学生高，那么当前学生的糖果数量就比前一个学生多 1
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }

        // 从右到左遍历一遍学生，如果当前学生的评分比后一个学生高，并且当前学生的糖果数量不大于后一个学生的糖果数量，那么当前学生的糖果数量就要更新为后一个学生的糖果数量加 1
        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {
                candies[i] = candies[i + 1] + 1;
            }
        }

        // 将所有学生的糖果数量加起来，就是最少需要分配的糖果数量
        int sum = 0;
        for (int candy : candies) {
            sum += candy;
        }
        return sum;
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。