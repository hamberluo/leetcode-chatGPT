题目编号：233

题目：数字 1 的个数

难度：困难

考察范围：数学、递归、位运算

题干：给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

示例:

输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13。

解题思路：本题可以使用数学方法或递归方法解决。这里介绍数学方法。

我们可以将数字 1 出现的个数分为两类：个位数为 1 和其他位数为 1。

对于个位数为 1 的情况，我们可以将 n 拆分为两部分，高位部分和低位部分，分别记为 a 和 b。例如当 n=3141592 时，a=314159，b=2。此时个位数为 1 的情况有两种情况：一种是 a*10+1，另一种是 a*10+1+b。其中 a*10+1 表示在 a 的基础上，个位数为 1，十位数为 0，其他位数不变；a*10+1+b 表示在 a 的基础上，个位数为 b，其他位数不变。需要注意的是，当 b=0 时，只有一种情况，即 a*10+1。

对于其他位数为 1 的情况，我们同样可以将 n 拆分为两部分，高位部分和低位部分，分别记为 a 和 b。例如当 n=3141592 时，a=31415，b=92。此时其他位数为 1 的情况有两种情况：一种是 (a+1)*1e1，另一种是 a*1e1+1e0*(b+1)。其中 (a+1)*1e1 表示在 a 的基础上，十位数为 1，其他位数不变；a*1e1+1e0*(b+1) 表示在 a 的基础上，个位数为 1，其他位数不变，同时需要将 b+1 乘以 1e0，即加上 1。

最终，我们将个位数为 1 和其他位数为 1 的情况的个数相加即可得到答案。

解决方案：

```java
class Solution {
    public int countDigitOne(int n) {
        int count = 0;
        for (long i = 1; i <= n; i *= 10) {
            long a = n / i, b = n % i;
            count += (a + 8) / 10 * i + (a % 10 == 1 ? b + 1 : 0);
        }
        return count;
    }
}
```

算法复杂度：时间复杂度为 O(logn)，空间复杂度为 O(1)。