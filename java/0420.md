题目编号：420

题目：强密码检验器

难度：困难

考察范围：字符串、动态规划

题干：

一个强密码应满足以下所有条件：

由至少6个，至多20个字符组成。
至少包含一个小写字母，一个大写字母，和一个数字。
同一字符不能连续出现三次 (比如 "...aaa..." 是不允许的, 但是 "...aa...a..." 是可以的)。
编写函数 strongPasswordChecker(s)，s 代表输入字符串，如果 s 已经符合强密码条件，则返回0；否则返回要将 s 修改为满足强密码条件的字符串所需要进行修改的最小步数。

插入、删除、替换任一字符都算作一次修改。

解题思路：

本题可以使用动态规划来解决。首先，我们需要确定状态。我们可以使用三个变量来表示当前状态：

- dp[i][j][k] 表示考虑前 i 个字符，已经插入 j 个字符，最后一个字符是 k 的最小修改次数。

其中，k 取值为 0、1、2，分别表示最后一个字符是小写字母、大写字母、数字。

接下来，我们需要考虑状态转移。对于当前状态 dp[i][j][k]，我们可以考虑以下三种情况：

- 如果当前字符可以不修改，即 s[i] 可以和前面的字符不同，那么我们可以直接转移，即 dp[i][j][k] = dp[i-1][j][k]。
- 如果当前字符必须修改，即 s[i] 必须和前面的字符不同，那么我们可以考虑插入、删除、替换三种操作。具体来说，我们可以枚举前一个字符的最后一个字符是什么，然后转移即可。具体来说，我们可以考虑以下三种情况：

- 如果前一个字符的最后一个字符和当前字符不同，那么我们可以考虑插入、删除、替换三种操作。具体来说，我们可以枚举当前字符的最后一个字符是什么，然后转移即可。具体来说，我们可以考虑以下三种情况：

- 如果当前字符的最后一个字符和前一个字符的最后一个字符不同，那么我们可以直接插入当前字符，即 dp[i][j+1][k] = dp[i][j+1][k]。
- 如果当前字符的最后一个字符和前一个字符的最后一个字符相同，那么我们可以考虑删除前一个字符，然后插入当前字符。具体来说，我们可以枚举前一个字符的最后一个字符是什么，然后转移即可。具体来说，我们可以考虑以下三种情况：

- 如果前一个字符的最后一个字符是小写字母，那么我们可以删除前一个字符，然后插入一个大写字母或数字，即 dp[i][j+1][1] = dp[i-1][j][0] + 1 或 dp[i][j+1][2] = dp[i-1][j][0] + 1。
- 如果前一个字符的最后一个字符是大写字母，那么我们可以删除前一个字符，然后插入一个小写字母或数字，即 dp[i][j+1][0] = dp[i-1][j][1] + 1 或 dp[i][j+1][2] = dp[i-1][j][1] + 1。
- 如果前一个字符的最后一个字符是数字，那么我们可以删除前一个字符，然后插入一个小写字母或大写字母，即 dp[i][j+1][0] = dp[i-1][j][2] + 1 或 dp[i][j+1][1] = dp[i-1][j][2] + 1。

- 如果前一个字符的最后一个字符和当前字符相同，那么我们可以考虑替换前一个字符，然后插入当前字符。具体来说，我们可以枚举前一个字符的最后一个字符是什么，然后转移即可。具体来说，我们可以考虑以下三种情况：

- 如果前一个字符的最后一个字符是小写字母，那么我们可以替换前一个字符为大写字母或数字，然后插入当前字符，即 dp[i][j+1][1] = dp[i-1][j][0] + 1 或 dp[i][j+1][2] = dp[i-1][j][0] + 1。
- 如果前一个字符的最后一个字符是大写字母，那么我们可以替换前一个字符为小写字母或数字，然后插入当前字符，即 dp[i][j+1][0] = dp[i-1][j][1] + 1 或 dp[i][j+1][2] = dp[i-1][j][1] + 1。
- 如果前一个字符的最后一个字符是数字，那么我们可以替换前一个字符为小写字母或大写字母，然后插入当前字符，即 dp[i][j+1][0] = dp[i-1][j][2] + 1 或 dp[i][j+1][1] = dp[i-1][j][2] + 1。

- 如果当前字符是第一个字符，那么我们可以直接插入当前字符，即 dp[i][j+1][k] = 1。

最终的答案即为 dp[n][j][k] 中的最小值，其中 n 是字符串的长度。

解决方案：

```java
class Solution {
    public int strongPasswordChecker(String s) {
        int n = s.length();
        int[][][] dp = new int[n+1][n+1][3];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                Arrays.fill(dp[i][j], Integer.MAX_VALUE / 2);
            }
        }
        dp[0][0][0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= i; j++) {
                for (int k = 0; k < 3; k++) {
                    char c = s.charAt(i-1);
                    if (c >= 'a' && c <= 'z') {
                        if (k == 0) {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j][k]);
                        } else {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j][k] + 1);
                        }
                        if (j > 0) {
                            if (k == 1) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][0] + 1);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][0] + 2);
                            }
                            if (k == 2) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][1] + 1);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][1] + 2);
                            }
                        }
                        if (j > 1) {
                            if (k == 2) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][0] + 2);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][0] + 3);
                            }
                            if (k == 1) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][2] + 2);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][2] + 3);
                            }
                        }
                    } else if (c >= 'A' && c <= 'Z') {
                        if (k == 1) {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j][k]);
                        } else {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j][k] + 1);
                        }
                        if (j > 0) {
                            if (k == 0) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][1] + 1);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][1] + 2);
                            }
                            if (k == 2) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][0] + 1);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][0] + 2);
                            }
                        }
                        if (j > 1) {
                            if (k == 2) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][1] + 2);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][1] + 3);
                            }
                            if (k == 0) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][2] + 2);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][2] + 3);
                            }
                        }
                    } else if (c >= '0' && c <= '9') {
                        if (k == 2) {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j][k]);
                        } else {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j][k] + 1);
                        }
                        if (j > 0) {
                            if (k == 0) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][2] + 1);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][2] + 2);
                            }
                            if (k == 1) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][0] + 1);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-1][0] + 2);
                            }
                        }
                        if (j > 1) {
                            if (k == 0) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][1] + 2);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][1] + 3);
                            }
                            if (k == 1) {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][2] + 2);
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i-1][j-2][2] + 3);
                            }
                        }
                    }
                }
            }
        }
        int ans = Integer.MAX_VALUE / 2;
        for (int j = 0; j <= n; j++) {
            for (int k = 0; k < 3; k++) {
                if (j >= 6 && j <= 20 && dp[n][j][k] < ans) {
                    ans = dp[n][j][k];
                }
            }
        }
        return ans;
    }
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^3)。