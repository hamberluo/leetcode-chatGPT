题目编号：903

题目：DI 序列的有效排列

难度：困难

考察范围：动态规划

题干：

我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）

有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：

如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；
如果 S[i] == 'I'，那么 P[i] < P[i+1]。
如同答案一样，P 数组由 [0, 1, ..., n] 中的每个整数出现恰好一次。


给定一个有效字符串 S，考虑其所有可能的有效排列。

如果存在有效排列，则返回任意一种。

如果不存在有效排列，返回一个空数组。

解题思路：

这道题可以使用动态规划来解决。

我们可以定义 dp[i][j] 表示使用前 i 个数，最后一个数为 j 的方案数。

对于 S[i] == 'D'，我们需要找到最后一个数比 j 小的数 k，那么 dp[i][j] 就等于 dp[i-1][k] 到 dp[i-1][j-1] 的和。

对于 S[i] == 'I'，我们需要找到最后一个数比 j 大的数 k，那么 dp[i][j] 就等于 dp[i-1][0] 到 dp[i-1][k-1] 的和。

最终的答案就是 dp[n][0] 到 dp[n][n] 的和。

解决方案：

```java
class Solution {
    public int[] diStringMatch(String S) {
        int n = S.length();
        int[] res = new int[n+1];
        int max = n, min = 0;
        for (int i = 0; i < n; i++) {
            if (S.charAt(i) == 'D') {
                res[i] = max--;
            } else {
                res[i] = min++;
            }
        }
        res[n] = max;
        return res;
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。