题目编号：799

题目：香槟塔

难度：中等

考察范围：动态规划

题干：

我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，依此类推。（如果最底层的玻璃杯满了，就会将多余的香槟流出去）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放了一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯：顶层的一个和第二层的两个，但第二层的两个玻璃杯平分了一杯香槟。在倒第四杯香槟后，第二层的香槟又满了，第三层的一个玻璃杯盛放了一半的香槟，如下图所示。

现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。

解题思路：

这道题可以使用动态规划来解决。我们可以用dp[i][j]表示第i行第j个杯子中香槟的比例，然后根据题目中的倾倒规则，我们可以得到状态转移方程：

dp[i][j] = (dp[i-1][j-1]-1)/2.0 + (dp[i-1][j]-1)/2.0

其中，dp[i-1][j-1]和dp[i-1][j]表示上一层左右两个杯子中香槟的比例，-1是因为上一层的杯子可能没有满，所以需要减去多余的香槟。然后再除以2.0，是因为溢出的香槟会平分到左右两个杯子中。

需要注意的是，当dp[i-1][j-1]或dp[i-1][j]小于等于0时，它们的值应该为0，因为香槟的比例不能为负数。

最后，我们需要在最后一行中找到第j个杯子中香槟的比例，返回即可。

解决方案：

```java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        double[][] dp = new double[101][101];
        dp[0][0] = poured;
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j <= i; j++) {
                if (dp[i][j] > 1) {
                    dp[i+1][j] += (dp[i][j]-1)/2.0;
                    dp[i+1][j+1] += (dp[i][j]-1)/2.0;
                    dp[i][j] = 1;
                }
            }
        }
        return dp[query_row][query_glass];
    }
}
```

算法复杂度：时间复杂度为O(n^2)，空间复杂度为O(n^2)。其中n为金字塔的高度。