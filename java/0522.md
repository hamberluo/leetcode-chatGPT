题目编号：522

题目：最长特殊序列 II

难度：中等

考察范围：字符串、哈希表

题干：给定一个字符串数组，你需要找到其中最长的特殊序列。特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。子序列可以通过删去原字符串中的某些字符得到，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。输入将是字符串列表，输出需要是它们中的最长特殊序列。如果最长特殊序列不存在，则返回 -1。

解题思路：首先，我们需要知道什么是子序列。子序列是指从原序列中删除一些元素后，剩余元素保持原有顺序不变所组成的新序列。例如，字符串 "ace" 是字符串 "abcde" 的子序列，但字符串 "aec" 不是字符串 "abcde" 的子序列。

接着，我们需要知道什么是特殊序列。特殊序列是指某字符串独有的最长子序列，即不能是其他字符串的子序列。例如，对于字符串数组 ["aba", "cdc", "eae"]，其中最长特殊序列为 "aba"、"cdc" 或 "eae"，因为它们都是独有的最长子序列。

那么，如何判断一个字符串是不是另一个字符串的子序列呢？我们可以使用双指针的方法，分别从两个字符串的开头开始遍历，如果两个字符相等，则两个指针都向后移动一位；否则，只移动第二个字符串的指针。如果第二个字符串的指针移动到了末尾，说明第一个字符串是第二个字符串的子序列。

最后，我们可以遍历字符串数组，对于每个字符串，判断它是否是其他字符串的子序列。如果不是，则说明它是一个特殊序列，我们可以计算它的长度并更新最长特殊序列的长度。如果所有字符串都是其他字符串的子序列，则最长特殊序列不存在，返回 -1。

解决方案：

```java
class Solution {
    public int findLUSlength(String[] strs) {
        int n = strs.length;
        int ans = -1;
        for (int i = 0; i < n; i++) {
            boolean flag = true;
            for (int j = 0; j < n; j++) {
                if (i == j) continue;
                if (isSubsequence(strs[i], strs[j])) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                ans = Math.max(ans, strs[i].length());
            }
        }
        return ans;
    }

    private boolean isSubsequence(String s, String t) {
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        return i == s.length();
    }
}
```

算法复杂度：时间复杂度为 O(n^2 * m)，其中 n 是字符串数组的长度，m 是字符串的平均长度。对于每个字符串，需要遍历整个字符串数组，判断它是否是其他字符串的子序列，时间复杂度为 O(n * m)。因此，总时间复杂度为 O(n^2 * m)。空间复杂度为 O(1)。