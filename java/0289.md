题目编号：289

题目：生命游戏

难度：中等

考察范围：数组、模拟

题干：

根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个由 0 和 1 组成的二维网格，其中 0 表示死亡，1 表示生存。每个单元格都与其八个相邻位置（水平，垂直，对角线）中的单元格形成关系。按照以下规则更新网格：

- 任何活着的单元格，如果周围八个位置中有两个或三个单元格为活着的，则继续活着。
- 任何活着的单元格，如果周围八个位置中有超过三个单元格为活着的，则死亡。
- 任何死亡的单元格，如果周围八个位置中恰好有三个单元格为活着的，则变成活着的状态。

下面是一个初始状态为 [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] 的示例。

```java
0 1 0
0 0 1
1 1 1
0 0 0
```

下一次迭代后的状态如下：

```java
0 0 0
1 0 1
0 1 1
0 1 0
```

解题思路：

根据题目要求，需要对每个细胞进行判断，判断其下一次迭代后的状态。由于需要同时更新所有细胞的状态，因此需要使用额外的空间来存储下一次迭代后的状态。

具体实现时，可以使用一个二维数组来存储下一次迭代后的状态。对于每个细胞，遍历其周围的八个细胞，统计活着的细胞数量，根据题目要求更新其状态即可。

解决方案：

```java
class Solution {
    public void gameOfLife(int[][] board) {
        int m = board.length;
        int n = board[0].length;
        int[][] nextBoard = new int[m][n]; // 存储下一次迭代后的状态
        int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1}; // 方向数组
        int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int liveCount = 0; // 统计活着的细胞数量
                for (int k = 0; k < 8; k++) {
                    int x = i + dx[k];
                    int y = j + dy[k];
                    if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 1) {
                        liveCount++;
                    }
                }
                if (board[i][j] == 1) { // 当前细胞为活着的状态
                    if (liveCount == 2 || liveCount == 3) {
                        nextBoard[i][j] = 1; // 继续活着
                    }
                } else { // 当前细胞为死亡的状态
                    if (liveCount == 3) {
                        nextBoard[i][j] = 1; // 变成活着的状态
                    }
                }
            }
        }
        // 更新原数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i][j] = nextBoard[i][j];
            }
        }
    }
}
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。其中 m 和 n 分别为二维数组的行数和列数。