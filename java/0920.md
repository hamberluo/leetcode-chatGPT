题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：

你的音乐播放器里有 n 首不同的歌，在旅途中，你的旅伴想要听这些歌，但是你的音乐播放器有一个限制，每首歌至少播放一次，而且相邻的两首歌必须间隔至少 k 首歌（包括重复播放的歌曲）。请你计算你可以生成的最长的播放列表长度。返回你可以构建的最大长度的方案数 modulo 10^9 + 7。

解题思路：

本题可以使用动态规划来解决。我们可以定义一个二维数组 dp[i][j] 表示已经选了 i 首歌，最后一首歌是 j 的方案数。那么我们可以得到状态转移方程：

dp[i][j] = dp[i-1][j-1] * (n-(i-1)) + dp[i-k][j-1] * (i-k>=1)

其中，第一项表示在已经选了 i-1 首歌的情况下，最后一首歌是 j-1，那么我们可以从剩下的 n-(i-1) 首歌中任选一首作为最后一首歌。第二项表示在已经选了 i-k 首歌的情况下，最后一首歌是 j-1，那么我们可以从前 i-k 首歌中任选一首作为倒数第 k+1 首歌，然后从剩下的 n-(i-1) 首歌中任选一首作为最后一首歌。

最终的答案就是 dp[n][n]。

解决方案：

```java
class Solution {
    public int numMusicPlaylists(int n, int k, int m) {
        int mod = 1000000007;
        long[][] dp = new long[n+1][n+1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i][j] = dp[i-1][j-1] * (n-(j-1)) % mod;
                if (i > k) {
                    dp[i][j] = (dp[i][j] + dp[i-1][j] * (i-k) % mod) % mod;
                }
            }
        }
        return (int)dp[n][m];
    }
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。