题目编号：837

题目：新21点

难度：中等

考察范围：动态规划

题干：爱丽丝参加一个可以用整数数组表示的游戏。她从数组中选择一个数字 N，然后玩家按顺序执行以下操作：

1.选出任意一个满足 0 <= x <= N 且 N-x <= 10 的数字 M。
2.将 N - x + M 的结果赋值给 N 。
3.当玩家无法执行这些操作时，即 N <= 0 时，游戏结束。

爱丽丝想要获得一个分数大于等于 K 的分数。如果她以最优方式玩游戏，请你返回她能够获得的最大分数，得分会被记入数组 dp 中。

解题思路：动态规划

我们可以用 dp[x] 表示从得分为 x 的情况开始游戏并且获胜的概率，目标是求 dp[0] 的值。那么 dp[x] 怎么求呢？

根据题目中的规则，当分数为 x 时，下一步可能的得分为 x+1, x+2, x+3, ..., x+W，所以有如下转移方程：

dp[x] = (dp[x+1] + dp[x+2] + ... + dp[x+W]) / W

这是一个标准的动态规划转移方程，可以用类似背包问题的思路求解。具体来说，从后往前递推，先算出 dp[N], dp[N-1], ..., dp[K] 的值，然后根据上述转移方程计算 dp[K-1], dp[K-2], ..., dp[0] 的值。注意到当分数大于等于 K 时就停止递推，因为题目要求的是分数大于等于 K 的情况。

解决方案：

```java
class Solution {
    public double new21Game(int N, int K, int W) {
        double[] dp = new double[N+W+1];
        for (int i = K; i <= N; i++) {
            dp[i] = 1.0;
        }
        double sum = Math.min(N-K+1, W);
        for (int i = K-1; i >= 0; i--) {
            dp[i] = sum / W;
            sum += dp[i] - dp[i+W];
        }
        return dp[0];
    }
}
```

算法复杂度：时间复杂度为 O(N+W)，空间复杂度为 O(N+W)。