题目编号：957

题目：N 天后的牢房

难度：中等

考察范围：模拟、数组

题干：8 个牢房排成一排，每间牢房不是有人住就是空着。

每天，无论牢房是被占用或空置，都会根据以下规则更改状态：

如果前一天牢房为空，而且（相邻的）后一天牢房被占用，则该牢房变成占用。
如果前一天牢房被占用，而且（相邻的）后一天牢房为空，则该牢房变成占用。
其余情况下，该牢房不改变。

我们用以下符号来表示牢房的状态：

空房间： '.'
占用的房间： '#'

给定一个整数 N，表示牢房的数量和一些初始占用的牢房。每天执行 N 次更改状态的规则，返回牢房的最终状态。

解题思路：模拟

题目要求我们模拟每天的牢房状态变化，因此我们可以使用一个数组来表示当前的牢房状态，然后模拟每天的变化，最后返回最终的状态。

具体来说，我们可以使用一个循环来模拟每天的变化，每次循环中，我们先记录当前的牢房状态，然后根据题目要求更新牢房状态，最后将更新后的状态保存到数组中。需要注意的是，由于每天的变化只与前一天的状态有关，因此我们可以使用两个变量来记录前一天和当前的状态，避免使用额外的数组。

解决方案：

```java
class Solution {
    public int[] prisonAfterNDays(int[] cells, int N) {
        // 牢房状态变化的周期为 14，因此我们只需要模拟前 14 天的变化即可
        N = (N - 1) % 14 + 1;
        int[] prev = new int[8]; // 前一天的状态
        int[] curr = new int[8]; // 当前的状态
        for (int i = 0; i < 8; i++) {
            prev[i] = cells[i];
        }
        for (int i = 1; i <= N; i++) {
            for (int j = 0; j < 8; j++) {
                if (j == 0 || j == 7) {
                    curr[j] = 0; // 首尾牢房一定为空
                } else if (prev[j - 1] == prev[j + 1]) {
                    curr[j] = 1; // 前后牢房状态相同，当前牢房被占用
                } else {
                    curr[j] = 0; // 前后牢房状态不同，当前牢房为空
                }
            }
            // 更新前一天的状态
            for (int j = 0; j < 8; j++) {
                prev[j] = curr[j];
            }
        }
        return curr;
    }
}
```

算法复杂度：时间复杂度为 O(1)，空间复杂度为 O(1)。