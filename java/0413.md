题目编号：413

题目：等差数列划分

难度：中等

考察范围：动态规划

题干：如果一个数列至少有三个元素，且任意两个相邻元素之差相同，则称该数列为等差数列。例如，以下数列为等差数列:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
以下数列不是等差数列。

1, 1, 2, 5, 7

数组 A 包含 N 个数，且索引从0开始。数组中任意三个下标 (P, Q, R) 满足 0 <= P < Q < R < N。

函数要返回数组 A 中所有为等差数组的子数组个数。

解题思路：动态规划

我们可以用 dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。我们可以从前往后依次计算 dp[i] 的值，假设我们已经算出了 dp[0] 到 dp[i-1] 的值，考虑如何计算 dp[i]。

我们可以考虑 A[i] 和 A[i-1] 之间的关系：

如果 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 A[i] 可以加入到以 A[i-1] 为结尾的等差递增子区间中，此时以 A[i] 为结尾的等差递增子区间的个数就是以 A[i-1] 为结尾的等差递增子区间的个数加 1。

如果 A[i] - A[i-1] != A[i-1] - A[i-2]，那么以 A[i-1] 为结尾的等差递增子区间无法继续扩展，此时以 A[i] 为结尾的等差递增子区间的个数就是 0。

因此，我们可以得到状态转移方程：

dp[i] = dp[i-1] + 1, if A[i] - A[i-1] == A[i-1] - A[i-2]
dp[i] = 0, if A[i] - A[i-1] != A[i-1] - A[i-2]

最终的答案就是所有 dp[i] 的和。

解决方案：

```java
class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        int n = A.length;
        if (n < 3) {
            return 0;
        }
        int[] dp = new int[n];
        int sum = 0;
        for (int i = 2; i < n; i++) {
            if (A[i] - A[i-1] == A[i-1] - A[i-2]) {
                dp[i] = dp[i-1] + 1;
                sum += dp[i];
            }
        }
        return sum;
    }
}
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(n)。