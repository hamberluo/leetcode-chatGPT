题目编号：798

题目：得分最高的最小轮调

难度：困难

考察范围：贪心算法、二分查找

题干：

给定一个数组 A，我们可以将它按一个非负整数 K 进行轮调，这样每个索引对应的值就变成了原数组上移动 K 个位置后的新值。

举个例子，如果 A = [1, 2, 3, 4, 5]，那么在 K = 2 的轮调之后，数组变成了 [4, 5, 1, 2, 3]。

我们定义数组 A 的“得分”为所有相邻元素之和的最大值。例如，数组 [4, 5, 1, 2, 3] 的得分为 8，因为 5 + 3 = 8。

给定一个数组 A，求出它的最大得分，同时输出进行轮调的最小非负整数 K。

解题思路：

首先，我们可以发现，对于一个数组 A，如果将其轮调 K 个位置，那么得到的新数组 B 的得分与 A 的得分相等。因此，我们可以不失一般性地假设 K 在 [0, n-1] 的范围内。

接下来，我们考虑如何计算得分。假设当前数组为 A，长度为 n。我们可以将 A 拆分成两个部分：前 k 个元素和后 n-k 个元素。对于这两个部分，它们的得分分别为 S1 和 S2。那么，A 的得分就等于 S1 + S2。

我们可以将 S1 和 S2 分别表示为前缀和数组 P1 和后缀和数组 P2。具体地，P1[i] 表示 A 的前 i 个元素的和，P2[i] 表示 A 的后 n-i 个元素的和。那么，S1 和 S2 就可以表示为 P1[k] 和 P2[k]。

接下来，我们考虑如何计算 S1 和 S2 的最大值。我们可以枚举 k，对于每个 k，计算 P1[k] 和 P2[k]，然后取它们的最大值。这个过程的时间复杂度为 O(n^2)。

但是，我们可以使用贪心算法来优化这个过程。具体地，我们可以先计算出 P1 和 P2，然后对于每个 k，计算 P1[k] 和 P2[k]，并取它们的最大值。这个过程的时间复杂度为 O(n)。

最后，我们可以使用二分查找来找到最小的 K，使得得分最大。具体地，我们可以二分查找得分的最大值，然后对于每个得分的最大值，计算出对应的 K，然后取最小的 K。这个过程的时间复杂度为 O(n log n)。

解决方案：

```java
class Solution {
    public int bestRotation(int[] A) {
        int n = A.length;
        int[] P = new int[n];
        for (int i = 0; i < n; i++) {
            P[(i - A[i] + 1 + n) % n]--;
        }
        for (int i = 1; i < n; i++) {
            P[i] += P[i - 1] + 1;
        }
        int maxScore = 0;
        int bestK = 0;
        for (int k = 0; k < n; k++) {
            int score = P[k] + (n - k - 1);
            if (score > maxScore) {
                maxScore = score;
                bestK = k;
            }
        }
        return bestK;
    }
}
```

算法复杂度：时间复杂度为 O(n log n)，空间复杂度为 O(n)。