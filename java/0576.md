题目编号：576

题目：出界的路径数

难度：中等

考察范围：动态规划

题干：给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 maxMove 次球。找出可以将球移出边界的路径数量。答案可能非常大，返回 对 109 + 7 取余 后的结果。

解题思路：动态规划

我们可以使用动态规划来解决这个问题。我们可以定义一个三维数组 dp，其中 dp[i][j][k] 表示从位置 (i,j) 出发，移动 k 次后移出边界的路径数量。我们可以根据题目中的要求，将 dp 数组的边界初始化为 1，即 dp[i][j][0] = 1，表示从位置 (i,j) 出发，不移动，不管怎么样都不会移出边界。

然后我们可以考虑如何转移。我们可以从上下左右四个方向移动，也可以不移动。因此，我们可以将 dp[i][j][k] 的值分成五个部分：

1. 从上方移动一步到达 (i-1,j)。
2. 从下方移动一步到达 (i+1,j)。
3. 从左方移动一步到达 (i,j-1)。
4. 从右方移动一步到达 (i,j+1)。
5. 不移动，仍然停留在 (i,j)。

对于第一部分，我们需要保证 (i-1,j) 在网格内部，否则这一步就会移出边界。因此，我们可以将 dp[i][j][k] 的值加上 dp[i-1][j][k-1]，表示从 (i-1,j) 移动一步到达 (i,j)。

对于第二部分、第三部分和第四部分，我们同样需要保证移动后的位置在网格内部。因此，我们可以将 dp[i][j][k] 的值加上 dp[i+1][j][k-1]、dp[i][j-1][k-1] 和 dp[i][j+1][k-1]，分别表示从 (i+1,j)、(i,j-1) 和 (i,j+1) 移动一步到达 (i,j)。

对于第五部分，我们不需要移动，因此 dp[i][j][k] 的值不变，仍然等于 dp[i][j][k-1]。

最终的答案就是所有 dp[i][j][maxMove] 的值之和。

解决方案：

```java
class Solution {
    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        int[][][] dp = new int[m][n][maxMove+1];
        int mod = 1000000007;
        int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
        for(int k=1;k<=maxMove;k++){
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    for(int[] dir:dirs){
                        int x = i+dir[0];
                        int y = j+dir[1];
                        if(x<0 || x>=m || y<0 || y>=n){
                            dp[i][j][k] += 1;
                        }else{
                            dp[i][j][k] = (dp[i][j][k]+dp[x][y][k-1])%mod;
                        }
                    }
                }
            }
        }
        return dp[startRow][startColumn][maxMove];
    }
}
```

算法复杂度：时间复杂度为 O(m*n*maxMove*4)，空间复杂度为 O(m*n*maxMove)。