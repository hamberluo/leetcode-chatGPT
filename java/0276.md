题目编号：276

题目：栅栏涂色

难度：简单

考察范围：动态规划

题干：有一个栅栏，它有 n 个柱子，每个柱子可以被涂成 k 种颜色之一。你需要给所有柱子涂上颜色，且相邻的柱子不能涂成相同的颜色。你需要计算出涂色方案总数。

解题思路：动态规划

对于第 i 个柱子，它可以涂成 k 种颜色之一，那么它的涂色方案数为 k。对于第 i+1 个柱子，它可以涂成 k 种颜色之一，但是要考虑它和第 i 个柱子的颜色是否相同。如果颜色相同，那么涂色方案数为 k-1，因为只有 k-1 种颜色可以选择；如果颜色不同，那么涂色方案数为 k-1，因为第 i+1 个柱子可以选择除第 i 个柱子的颜色之外的 k-1 种颜色。

因此，我们可以得到状态转移方程：

dp[i][0] = k
dp[i][1] = (k-1) * dp[i-1][0]
dp[i][2] = (k-1) * (dp[i-1][0] + dp[i-1][1])

其中，dp[i][0] 表示第 i 个柱子涂色方案数，且与前一个柱子颜色不同；dp[i][1] 表示第 i 个柱子涂色方案数，且与前一个柱子颜色相同；dp[i][2] 表示前 i 个柱子的涂色方案数。

最终的答案为 dp[n][2]。

解决方案：

```java
class Solution {
    public int numWays(int n, int k) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return k;
        }
        int[][] dp = new int[n+1][3];
        dp[1][0] = k;
        dp[1][1] = 0;
        dp[1][2] = k;
        for (int i = 2; i <= n; i++) {
            dp[i][0] = dp[i-1][2];
            dp[i][1] = (k-1) * dp[i-1][0];
            dp[i][2] = (k-1) * (dp[i-1][0] + dp[i-1][1]);
        }
        return dp[n][2];
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。