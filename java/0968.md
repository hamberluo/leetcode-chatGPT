题目编号：968

题目：监控二叉树

难度：困难

考察范围：二叉树、贪心算法、递归

题干：

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

示例 1：

输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。

示例 2：

输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。

提示：

给定树的节点数的范围是 [1, 1000]。
每个节点的值都是 0。

解题思路：

本题是一道贪心算法的题目，我们可以从叶子节点开始考虑，因为叶子节点是最容易被监控到的，所以我们可以从叶子节点开始往上考虑。

对于每个节点，我们可以分为三种情况：

1.该节点没有被监控到，那么我们需要在该节点上安装一个摄像头。

2.该节点被监控到了，但是没有安装摄像头。

3.该节点被监控到了，并且安装了摄像头。

对于第一种情况，我们需要在该节点上安装一个摄像头，然后向上返回，告诉父节点该节点已经被监控到了。

对于第二种情况，我们不需要在该节点上安装摄像头，因为该节点的父节点已经被监控到了，所以我们可以直接向上返回。

对于第三种情况，我们也不需要在该节点上安装摄像头，因为该节点的父节点已经被监控到了，并且在该节点上安装了摄像头，所以我们可以直接向上返回。

最后，我们只需要在根节点上判断是否需要在根节点上安装摄像头即可。

解决方案：

```java
class Solution {
    int res = 0;
    public int minCameraCover(TreeNode root) {
        if (dfs(root) == 0) {
            res++;
        }
        return res;
    }

    private int dfs(TreeNode node) {
        if (node == null) {
            return 1;
        }
        int left = dfs(node.left);
        int right = dfs(node.right);
        if (left == 0 || right == 0) {
            res++;
            return 2;
        } else if (left == 2 || right == 2) {
            return 1;
        } else {
            return 0;
        }
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(h)，其中 n 为节点数，h 为树的高度。