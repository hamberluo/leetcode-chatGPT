题目编号：881

题目：救生艇

难度：中等

考察范围：贪心算法、双指针

题干：

第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。

返回载到每一个人所需的最小船数。(保证每个人都能被船载)。

示例 1：

输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)

示例 2：

输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)

示例 3：

输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)

提示：

1 <= people.length <= 50000
1 <= people[i] <= limit <= 30000

解题思路：

本题可以使用贪心算法来解决，具体思路如下：

- 首先将人按照体重从小到大排序，这样可以保证每次选择的人体重最小；
- 然后使用双指针，一个指向最轻的人，一个指向最重的人；
- 如果最轻的人和最重的人的体重之和小于等于 limit，那么这两个人可以一起坐一艘船，双指针分别向中间移动；
- 如果最轻的人和最重的人的体重之和大于 limit，那么最重的人只能单独坐一艘船，最重的人的指针向左移动；
- 直到最轻的人的指针大于等于最重的人的指针时，结束循环。

解决方案：

```java
class Solution {
    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people); // 将人按照体重从小到大排序
        int left = 0, right = people.length - 1; // 双指针
        int count = 0; // 记录船的数量
        while (left <= right) {
            if (people[left] + people[right] <= limit) { // 如果最轻的人和最重的人的体重之和小于等于 limit
                left++; // 最轻的人的指针向右移动
                right--; // 最重的人的指针向左移动
            } else { // 如果最轻的人和最重的人的体重之和大于 limit
                right--; // 最重的人的指针向左移动
            }
            count++; // 船的数量加 1
        }
        return count; // 返回船的数量
    }
}
```

算法复杂度：时间复杂度为 O(nlogn)，其中 n 为人的数量，主要是排序的时间复杂度；空间复杂度为 O(1)，只需要常数级别的额外空间。