题目编号：927

题目：三等分

难度：困难

考察范围：数组、双指针

题干：给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。

如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：

A[0], A[1], ..., A[i] 组成第一部分；
A[i+1], A[i+2], ..., A[j-1] 作为第二部分；
A[j], A[j+1], ..., A[A.length - 1] 是第三部分。
这三个部分所表示的二进制值相等。如果无法做到，就返回 [-1, -1]。

注意，在考虑每个部分所表示的二进制值时，应将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。

解题思路：首先，我们可以先计算出整个数组的二进制值，然后将其除以 3，得到每个部分应该表示的二进制值。接着，我们可以使用双指针，分别从数组的两端开始向中间遍历，找到第一个和第二个部分的结束位置，使得这两个部分所表示的二进制值等于每个部分应该表示的二进制值。最后，我们再判断第三个部分是否也满足条件即可。

解决方案：

```java
class Solution {
    public int[] threeEqualParts(int[] A) {
        int n = A.length;
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            cnt += A[i];
        }
        if (cnt % 3 != 0) {
            return new int[]{-1, -1};
        }
        if (cnt == 0) {
            return new int[]{0, n - 1};
        }
        int k = cnt / 3;
        int i = 0, j = n - 1;
        int cnt1 = 0, cnt2 = 0, cnt3 = 0;
        while (cnt1 < k) {
            cnt1 += A[i++];
        }
        while (cnt2 < k) {
            cnt2 += A[j--];
        }
        while (i < j && A[i] == 0) {
            i++;
        }
        while (i < j && A[j] == 0) {
            j--;
        }
        while (cnt3 < k) {
            cnt3 += A[i++];
        }
        if (cnt1 != cnt3 || i > j) {
            return new int[]{-1, -1};
        }
        while (j < n && A[j] == 0) {
            j++;
        }
        if (j == n) {
            return new int[]{i - 1, j};
        }
        return new int[]{-1, -1};
    }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。