题目编号：822

题目：翻转卡片游戏

难度：中等

考察范围：数组、模拟

题干：在桌子上有一堆牌，每张牌上都写着一个整数。此外，还有一个长度相同的卡牌组。你需要依次从牌堆顶取一张牌，并按照以下规则执行操作，直到牌堆中所有的牌都被取走：

1. 如果当前牌堆顶部的牌已经被翻转过，那么你需要将卡牌组中的前 K 张牌翻转过来，其中 K 是你当前已经翻转过的牌的数目。
2. 如果当前牌堆顶部的牌还没有被翻转过，那么你需要将其翻转，并将卡牌组中的前 1 张牌翻转过来。

最后，你需要返回能够使得牌堆中的所有牌都被翻转的最少操作次数。

解题思路：模拟

我们可以用一个数组来表示卡牌组，数组下标表示卡牌组中的第几张牌，数组的值表示这张牌需要翻转的次数。例如，如果卡牌组的第 2 张牌的值为 3，那么在翻转第 2 张牌时，需要将卡牌组中的前 3 张牌翻转过来。

我们从牌堆顶部开始依次取牌，对于每张牌，我们判断它是否已经被翻转过。如果已经被翻转过，那么我们需要将卡牌组中的前 K 张牌翻转过来，其中 K 是当前已经翻转过的牌的数目。如果还没有被翻转过，那么我们需要将其翻转，并将卡牌组中的前 1 张牌翻转过来。

最后，我们统计翻转的次数即可。

解决方案：

```java
class Solution {
    public int flipgame(int[] fronts, int[] backs) {
        int n = fronts.length;
        int[] flip = new int[n];
        for (int i = 0; i < n; i++) {
            flip[i] = i;
        }
        for (int i = 0; i < n; i++) {
            if (fronts[i] == backs[i]) {
                flip[i] = -1;
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if (flip[i] == -1) {
                continue;
            }
            int cnt = 0;
            for (int j = 0; j < n; j++) {
                if (flip[j] == flip[i]) {
                    cnt++;
                }
            }
            if (cnt < res) {
                res = cnt;
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n)。