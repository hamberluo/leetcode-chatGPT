题目编号：279

题目：完全平方数

难度：中等

考察的知识点：动态规划、数学

题干：

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.

典型解题思路：

1. 动态规划

我们可以使用动态规划来解决这个问题。我们定义一个数组 dp，其中 dp[i] 表示组成数字 i 的最少完全平方数的个数。我们可以从 1 开始遍历到 n，对于每个数字 i，我们将其初始化为最大值 i，因为最坏情况下，我们可以把 i 拆分为 i 个 1 的和，这样就需要 i 个完全平方数。

接下来，对于每个 i，我们需要遍历所有小于 i 的完全平方数 j*j（j*j <= i），并更新 dp[i] 的值，即：

dp[i] = min(dp[i], dp[i - j*j] + 1)

其中 dp[i - j*j] + 1 表示当前数字 i 可以由数字 i - j*j 加上一个完全平方数 j*j 得到，所以 dp[i] 的值应该为 dp[i - j*j] + 1 和 dp[i] 中的较小值。

最终，dp[n] 就是我们要求的答案。

2. 数学

根据四平方和定理，任何一个正整数都可以表示为四个整数的平方和。因此，我们可以先判断 n 是否可以表示为四个整数的平方和，如果可以，那么答案就是 4。

如果不能，我们再判断 n 是否可以表示为三个整数的平方和，如果可以，那么答案就是 3。

如果还不能，我们再判断 n 是否可以表示为两个整数的平方和，如果可以，那么答案就是 2。

如果都不行，那么答案就是 1。

解决方案（用 python 语言）：

1. 动态规划

class Solution:
    def numSquares(self, n: int) -> int:
        dp = [i for i in range(n+1)]
        for i in range(1, n+1):
            j = 1
            while j*j <= i:
                dp[i] = min(dp[i], dp[i-j*j]+1)
                j += 1
        return dp[n]

2. 数学

class Solution:
    def numSquares(self, n: int) -> int:
        while n % 4 == 0:
            n //= 4
        if n % 8 == 7:
            return 4
        for i in range(int(n**0.5)+1):
            j = int((n-i*i)**0.5)
            if i*i + j*j == n:
                return 2 if i > 0 and j > 0 else 1
        return 3

算法复杂度：

1. 动态规划

时间复杂度：O(n*sqrt(n))，其中 n 是给定的正整数。我们需要计算从 1 到 n 的 dp 数组的值，对于每个 i，需要枚举所有小于 i 的完全平方数，时间复杂度为 sqrt(i)，因此总时间复杂度为 O(n*sqrt(n))。

空间复杂度：O(n)，我们需要使用长度为 n+1 的 dp 数组。

2. 数学

时间复杂度：O(sqrt(n))，其中 n 是给定的正整数。我们需要枚举所有小于等于 n 的完全平方数，时间复杂度为 sqrt(n)。

空间复杂度：O(1)，我们只需要常数级别的空间来存储一些变量。