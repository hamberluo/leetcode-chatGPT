题目编号：287

题目：寻找重复数

难度：中等

考察的知识点：数组、双指针、二分查找

题干：

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2

示例 2:

输入: [3,1,3,4,2]
输出: 3

说明：

1.不能更改原数组（假设数组是只读的）。
2.只能使用额外的 O(1) 的空间。
3.时间复杂度小于 O(n^2) 。
4.数组中只有一个重复的数字，但它可能不止重复出现一次。

典型解题思路：

方法一：排序

将数组排序后，重复的数一定出现在相邻位置中。

时间复杂度：O(nlogn)，空间复杂度：O(1)

方法二：哈希表

遍历数组，将每个数存入哈希表中，如果发现重复的数，则返回该数。

时间复杂度：O(n)，空间复杂度：O(n)

方法三：双指针

将数组看成链表，数组中的数值表示下一个节点的索引，因为有重复的数，所以一定存在环。使用快慢指针，快指针每次走两步，慢指针每次走一步，当两个指针相遇时，将快指针重新指向数组开头，然后快慢指针每次都走一步，当两个指针再次相遇时，就是环的入口，也就是重复的数。

时间复杂度：O(n)，空间复杂度：O(1)

方法四：二分查找

将数组分为两部分，一部分的数值小于等于中间数，另一部分的数值大于中间数。如果小于等于中间数的数的个数大于中间数，则说明重复的数在左半部分，否则在右半部分。重复以上步骤，直到找到重复的数。

时间复杂度：O(nlogn)，空间复杂度：O(1)

解决方案（用 python 语言）：

方法三：双指针

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = nums[0]
        fast = nums[0]
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        fast = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。