题目编号：218

题目：天际线问题

难度：困难

考察的知识点：线段树、堆

题干：

给定 N 座大楼，每座大楼的宽度为 1，高度为 h，以 [Li, Ri, Hi] 格式表示，表示第 i 座大楼在 [Li, Ri] 区间内，高度为 Hi。天际线是所有大楼外轮廓线的集合，即所有可见的轮廓线的交集。

请你输出天际线的轮廓线。

每个轮廓线都必须从左边界开始，并在右边界结束。第 i 座大楼的右边界 Ri 可能小于下一座大楼的左边界 Li，因此在这种情况下，你必须输出当前大楼的右边界以及下一座大楼的左边界之间的部分。

注意:

- 任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。
- 输入列表已经按左 x 坐标 Li  进行升序排列。
- 输入列表中的所有建筑物都是独立的，即没有相同的建筑物。
- 输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[..., [7, 5], [11, 5], ...]

典型解题思路：

1. 将每个建筑物的左右边界和高度拆分成两个元素，分别表示左边界和高度，右边界和高度，然后将这些元素按照左边界排序。

2. 创建一个堆，用于存储当前所有建筑物的高度。同时，创建一个字典，用于存储每个高度对应的建筑物数量。

3. 遍历排序后的元素列表，对于每个元素，如果它是左边界，则将其高度加入堆中，并将其高度数量加 1；如果它是右边界，则将其高度从堆中删除，并将其高度数量减 1。

4. 在遍历过程中，如果当前堆的最大高度发生了变化，则将当前位置和新的最大高度加入结果列表中。

5. 遍历结束后，对于结果列表中连续的相同高度，只保留最后一个。

解决方案（用 python 语言）：

```python
import heapq

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        # 将每个建筑物的左右边界和高度拆分成两个元素，分别表示左边界和高度，右边界和高度，然后将这些元素按照左边界排序。
        points = []
        for building in buildings:
            points.append((building[0], -building[2]))
            points.append((building[1], building[2]))
        points.sort()

        # 创建一个堆，用于存储当前所有建筑物的高度。同时，创建一个字典，用于存储每个高度对应的建筑物数量。
        heap = [0]
        heights = {0: 1}

        # 遍历排序后的元素列表，对于每个元素，如果它是左边界，则将其高度加入堆中，并将其高度数量加 1；如果它是右边界，则将其高度从堆中删除，并将其高度数量减 1。
        res = []
        for point in points:
            if point[1] < 0:
                heapq.heappush(heap, point[1])
            else:
                heights[point[1]] -= 1
                if heights[point[1]] == 0:
                    del heights[point[1]]
            # 在遍历过程中，如果当前堆的最大高度发生了变化，则将当前位置和新的最大高度加入结果列表中。
            max_height = -heap[0]
            if res == [] or max_height != res[-1][1]:
                res.append([point[0], max_height])

        # 遍历结束后，对于结果列表中连续的相同高度，只保留最后一个。
        i = 0
        while i < len(res) - 1:
            if res[i][1] == res[i+1][1]:
                res.pop(i)
            else:
                i += 1

        return res
```

算法复杂度：时间复杂度为 O(nlogn)，其中 n 是建筑物的数量。排序的时间复杂度为 O(nlogn)，遍历的时间复杂度为 O(nlogn)，因为每个建筑物最多会进出堆一次。空间复杂度为 O(n)，因为需要存储每个建筑物的左右边界和高度。