题目编号：161

题目：One Edit Distance

难度：中等

考察的知识点：字符串、双指针

题干：

给定两个字符串 s 和 t，判断它们是否只相差一个编辑距离。

编辑距离定义为：将一个字符串转换成另一个字符串所需的最少操作次数，操作包括插入一个字符、删除一个字符、替换一个字符。

示例 1:

输入: s = "ab", t = "acb"
输出: true
解释: 只需将第一个字符串中的 'c' 插入到第二个字符串的 "ab" 中。

示例 2:

输入: s = "cab", t = "ad"
输出: false
解释: 需要操作两次才能将第一个字符串转换成第二个字符串。

注意:

- 两个字符串长度均小于等于 100。
- 如果两个字符串相等，则认为它们也是只相差一个编辑距离。

典型解题思路：

双指针法

我们可以使用双指针法来解决这个问题。我们可以将两个字符串分别用指针 i 和 j 来遍历，如果两个指针所指的字符相同，则两个指针同时向后移动一位；如果不同，则有以下三种情况：

- 替换操作：将 s[i] 替换为 t[j]，然后两个指针同时向后移动一位；
- 插入操作：在 t[j] 前插入一个字符，然后 j 指针向后移动一位；
- 删除操作：删除 s[i]，然后 i 指针向后移动一位。

如果我们进行了一次操作后，两个指针所指的字符仍然不同，则说明两个字符串不只相差一个编辑距离，直接返回 False。

如果我们遍历完两个字符串后，两个指针都指向字符串的末尾，则说明两个字符串只相差一个编辑距离，返回 True。

解决方案（用 python 语言）：

class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        m, n = len(s), len(t)
        if abs(m - n) > 1:
            return False
        i, j, cnt = 0, 0, 0
        while i < m and j < n:
            if s[i] == t[j]:
                i += 1
                j += 1
            else:
                cnt += 1
                if cnt > 1:
                    return False
                if m == n:
                    i += 1
                    j += 1
                elif m > n:
                    i += 1
                else:
                    j += 1
        if cnt == 0 and m != n:
            cnt += 1
        return cnt == 1

算法复杂度：

时间复杂度：O(n)，其中 n 是两个字符串的长度之和。最坏情况下，两个字符串的长度相差为 1，需要遍历完较长的字符串。

空间复杂度：O(1)。只需要常数的额外空间。