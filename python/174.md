题目编号：174

题目：地下城游戏

难度：困难

考察的知识点：动态规划

题干：

给定一个包含非负整数的 m x n 网格 dungeon ，请你计算出从左上角到右下角的最小初始健康点数。

开始时，你的健康点数为一个整数，你的任务是通过消耗一定的健康点数来维持你的生命值。你可以在任意时刻从下方或右方向上穿过网格。

每个格子要么是空的（0），要么是包含一个怪物的房间（负整数），要么是包含一个补给箱的房间（正整数）。

为了保证你能够成功地通过游戏，你至少需要拥有一点健康点数。

例如，如果你只有 1 点健康点数，并且你的要通过一个包含 -5 的房间的网格，你将失去 1 点健康点数，因此你的健康点数变为 0，你将无法通过该房间。

典型解题思路：

1. 定义状态：dp[i][j] 表示从 (i,j) 到终点所需的最小初始健康点数。

2. 状态转移方程：

   dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)

   解释：从 (i,j) 到终点所需的最小初始健康点数，等于从下方或右方到终点所需的最小初始健康点数减去当前格子的值，再取最大值，保证最小初始健康点数为 1。

3. 初始化：

   dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])

   解释：终点的最小初始健康点数为 1 或 1 减去终点格子的值。

4. 边界条件：

   dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])

   dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])

   解释：最后一行和最后一列的格子只能向右或向下走，所以它们的最小初始健康点数只能由相邻格子的最小初始健康点数减去当前格子的值得到。

5. 返回结果：

   dp[0][0] 表示从起点到终点所需的最小初始健康点数。

解决方案（用 python 语言）：

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        dp = [[0] * n for _ in range(m)]
        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])
        for j in range(n-2, -1, -1):
            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])
        for i in range(m-2, -1, -1):
            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])
        for i in range(m-2, -1, -1):
            for j in range(n-2, -1, -1):
                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)
        return dp[0][0]
```

算法复杂度：时间复杂度为 O(mn)，空间复杂度为 O(mn)。