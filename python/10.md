题目编号：10

题目：正则表达式匹配

难度：困难

考察的知识点：动态规划、字符串匹配

题干：给定一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 可以匹配任意字符串。

示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 
因为 '*' 代表可以匹配零个或多个前面的那一个元素，所以可以匹配 "c"、"a"、和 "b"。

示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

典型解题思路：

1. 动态规划

我们可以用 dp[i][j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配。

首先，我们需要考虑的是初始化问题。显然，dp[0][0] = True，即当字符串 s 和模式 p 均为空时，匹配成功。

然后，我们需要考虑模式 p 为空，如何更新 dp 数组。由于题目中规定，当模式 p 为空时，字符串 s 只有为空才能匹配成功，因此我们有：

dp[0][j] = dp[0][j - 2], 其中 j > 1 且 p[j - 1] == '*'

接下来，我们需要考虑的是一般情况下的状态转移。我们可以分为以下两种情况：

当 p[j - 1] 不为 '*' 时，我们需要判断 s[i - 1] 和 p[j - 1] 是否相等，以及 dp[i - 1][j - 1] 是否为 True，即：

dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')

当 p[j - 1] 为 '*' 时，我们需要分别考虑 '*' 的两种不同用法：

当 '*' 用于匹配 0 个字符时，我们有：

dp[i][j] = dp[i][j - 2]

当 '*' 用于匹配 1 个或多个字符时，我们有：

dp[i][j] = dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.')

最终的答案即为 dp[m][n]，其中 m 和 n 分别为字符串 s 和模式 p 的长度。

2. 正则表达式匹配

我们可以使用递归的方法来解决这个问题。具体来说，我们可以分为以下几种情况：

当模式 p 为空时，如果字符串 s 也为空，则匹配成功，否则匹配失败。

当模式 p 的第二个字符不为 '*' 时，如果字符串 s 的第一个字符和模式 p 的第一个字符相匹配，那么我们可以将问题转化为判断字符串 s[1:] 和模式 p[1:] 是否匹配；否则匹配失败。

当模式 p 的第二个字符为 '*' 时，我们可以分为以下两种情况：

'*' 匹配 0 个字符，即忽略模式 p 的前两个字符，判断字符串 s 和模式 p[2:] 是否匹配。

'*' 匹配 1 个或多个字符，即将字符串 s 的第一个字符和模式 p 的第一个字符匹配，然后判断字符串 s[1:] 和模式 p 是否匹配。

解决方案（用 python 语言）：

1. 动态规划

class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        for j in range(2, n + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 2]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if p[j - 1] != '*':
                    dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')
                else:
                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
        return dp[m][n]

算法复杂度：时间复杂度为 O(mn)，其中 m 和 n 分别为字符串 s 和模式 p 的长度；空间复杂度为 O(mn)。