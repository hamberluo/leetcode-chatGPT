题目编号：920

题目：播放列表的数量

难度：中等

考察范围：动态规划

题干：你的音乐播放器里有 n 首不同的歌，在旅途中，你的旅伴想要听 l 首歌（不一定不同，即，允许重复歌曲）。请你为她按如下规则创建一个播放列表：

每首歌至少播放一次。
一首歌只有在其他 k 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

解题思路：动态规划

我们可以使用动态规划来解决这个问题。我们定义 dp[i][j] 表示在播放列表中有 i 首歌，其中有 j 首不同的歌的方案数。我们可以考虑最后一首歌是否是新的歌。

如果最后一首歌是新的歌，那么我们可以从 dp[i-1][j-1] 转移而来，表示我们从 i-1 首歌中选择了 j-1 首不同的歌，然后在最后一首歌上选择一个新的歌。

如果最后一首歌不是新的歌，那么我们可以从 dp[i-1][j] 转移而来，表示我们从 i-1 首歌中选择了 j 首不同的歌，然后在最后一首歌上选择了一首已经播放过的歌。

因此，我们可以得到如下的状态转移方程：

dp[i][j] = dp[i-1][j-1] * (n-j+1) + dp[i-1][j] * max(j-k, 0)

其中，n 表示不同的歌曲数量，k 表示一首歌只有在其他 k 首歌播放完之后才能再次播放。

最终的答案即为 dp[l][n]。

解决方案：

```dart
int numMusicPlaylists(int n, int l, int k) {
  int mod = 1000000007;
  List<List<int>> dp = List.generate(l+1, (_) => List.filled(n+1, 0));
  dp[0][0] = 1;
  for (int i = 1; i <= l; i++) {
    for (int j = 1; j <= n; j++) {
      dp[i][j] = (dp[i-1][j-1] * (n-j+1) + dp[i-1][j] * max(j-k, 0)) % mod;
    }
  }
  return dp[l][n];
}
```

算法复杂度：时间复杂度为 O(nl)，空间复杂度为 O(nl)。