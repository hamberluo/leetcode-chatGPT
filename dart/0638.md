题目编号：638

题目：大礼包

难度：中等

考察范围：动态规划、回溯算法

题干：在LeetCode商店中， 有许多在售的物品。
LeetCode 想要开展一个促销活动，其中，需要使用一些大礼包，把售价总和最大化。
你需要发掘出可能的大礼包，以供销售。

每个大礼包的由一些小礼包组成。为了确保你的售价最大化，每个大礼包中的物品总价值应大于等于大礼包的价格。
你可以通过给定的数据文件来选择你想要的礼包，你需要输出你选择的礼包，以及将其售出后，你的总售价。

每个大礼包的详细情况以及它对应的价格都由二维数组提供，其中，第 i 个大礼包内所包含的每种物品的数量为 `special[i]`，而该大礼包的价格为 `price[i]`。

此外，我们保证每种物品都只在一个大礼包中出现，即每种物品只能用一种特殊价格购买一次。

示例 1:

输入: [2,5], [[3,0,5],[1,2,10]], [3,2]
输出: 14
解释:
有A和B两种物品，价格分别为¥2和¥5。
大礼包1，你可以以¥5的价格购买3A和0B。
大礼包2， 你可以以¥10的价格购买1A和2B。
你需要购买3个A和2个B， 所以你付了¥10购买了1个大礼包2，以及¥4购买了3个A和0个B。
因此，总共付了¥14，而你可以获得3个A和2个B，值得注意的是你也可以只购买大礼包2，那么你需要付价格为¥10的价格。

解题思路：动态规划

首先，我们可以将每个大礼包看作一个状态，然后使用动态规划来解决这个问题。

我们定义 dp[i] 表示购买 i 种物品所需的最小花费，那么我们可以得到状态转移方程：


dp[i] = \min(dp[i], dp[i - s] + price)


其中，s 表示第 i 个大礼包中第 j 种物品的数量，price 表示第 i 个大礼包的价格。

最终，我们只需要返回 dp[n] 即可，其中 n 表示物品的种类数。

解决方案：

```dart
int shoppingOffers(List<int> price, List<List<int>> special, List<int> needs) {
  int n = price.length;
  List<int> dp = List.filled(1 << n, 0x3f3f3f3f);
  dp[0] = 0;
  for (int i = 0; i < (1 << n); i++) {
    for (int j = 0; j < special.length; j++) {
      int s = 0;
      bool canBuy = true;
      for (int k = 0; k < n; k++) {
        int remain = needs[k] - ((i >> k) & 1) * special[j][k];
        if (remain < 0) {
          canBuy = false;
          break;
        }
        s |= remain << (k * 5);
      }
      if (canBuy) {
        dp[i | (1 << n)] = min(dp[i | (1 << n)], dp[i] + special[j][n]);
        dp[i | s] = min(dp[i | s], dp[i] + special[j][n]);
      }
    }
  }
  return dp[(1 << n) - 1];
}
```

算法复杂度：O(3^n \cdot m)，其中 n 表示物品的种类数，m 表示大礼包的数量。