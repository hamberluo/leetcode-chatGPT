题目编号：799

题目：香槟塔

难度：中等

考察范围：动态规划

题干：我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，……，第n层有n个。每个玻璃杯可以装一定的香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等分溢出，依此类推（超过了杯子的容量，香槟会立刻溢出）。

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满了的玻璃杯，其中两个分别位于第二层的左右两端。第四层有一个玻璃杯，它的左右两端分别盛放了一半的香槟，如图所示。

现在当倾倒了非负整数杯香槟后，返回第i行j个玻璃杯所盛放的香槟占玻璃杯容积的比例（i和j都从0开始）。

解题思路：动态规划

首先，我们可以将题目中的金字塔转化为一个二维数组，数组中的每个元素表示对应位置的杯子中香槟的容量。

接下来，我们可以使用动态规划的思想来解决这个问题。我们定义一个二维数组dp，其中dp[i][j]表示第i行第j个杯子中香槟的容量占杯子容积的比例。

对于第0行的杯子，它们的香槟容量都是0，因此dp[0][0] = poured。

对于第i行第j个杯子，它的香槟容量可以由上一行的左右两个杯子流出的香槟容量得到。因此，我们可以得到以下状态转移方程：

dp[i][j] = max((dp[i-1][j-1]-1)/2, 0) + max((dp[i-1][j]-1)/2, 0)

其中，dp[i-1][j-1]表示上一行左边的杯子中香槟的容量，dp[i-1][j]表示上一行右边的杯子中香槟的容量。由于香槟会等分溢出，因此我们需要将上一行左右两个杯子中香槟的容量都减去1，然后再除以2。

需要注意的是，当上一行的杯子中香槟的容量小于1时，它们不会流出香槟，因此我们需要将它们的香槟容量设为0。

最后，我们返回dp[query_row][query_glass]即可。

解决方案：

```dart
double champagneTower(int poured, int query_row, int query_glass) {
  List<List<double>> dp = List.generate(101, (_) => List.filled(101, 0.0));
  dp[0][0] = poured.toDouble();
  for (int i = 1; i <= query_row; i++) {
    for (int j = 0; j <= i; j++) {
      dp[i][j] = max((dp[i-1][j-1]-1)/2, 0) + max((dp[i-1][j]-1)/2, 0);
    }
  }
  return min(dp[query_row][query_glass], 1.0);
}
```

算法复杂度：时间复杂度为O(n^2)，空间复杂度为O(n^2)。其中n为金字塔的高度。