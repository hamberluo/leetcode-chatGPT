题目编号：524

题目：通过删除字母匹配到字典里最长单词

难度：中等

考察范围：字符串、排序、双指针

题干：

给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果没有，则返回空字符串。

示例 1:

输入:
s = "abpclefg"
d = ["ale","apple","monkey","plea"]

输出: 
"apple"

示例 2:

输入:
s = "abpclefg"
d = ["a","b","c"]

输出: 
"a"

解题思路：

首先，我们需要对字典进行排序，排序规则为字符串长度从大到小，如果长度相同则按字典序从小到大排序。

然后，我们遍历字典中的每个字符串，判断该字符串是否可以通过删除给定字符串的某些字符来得到。具体实现可以使用双指针，一个指针指向给定字符串，一个指针指向当前遍历的字典字符串。如果两个指针所指的字符相同，则两个指针都向后移动一位；否则，只移动给定字符串的指针。最终，如果字典字符串的指针指向了字符串末尾，则说明该字符串可以通过删除给定字符串的某些字符来得到。

最后，我们返回长度最长且字典顺序最小的字符串。

解决方案：

```dart
String findLongestWord(String s, List<String> d) {
  // 对字典进行排序
  d.sort((a, b) {
    if (a.length != b.length) {
      return b.length - a.length;
    } else {
      return a.compareTo(b);
    }
  });

  // 遍历字典中的每个字符串
  for (String word in d) {
    int i = 0, j = 0;
    // 使用双指针判断该字符串是否可以通过删除给定字符串的某些字符来得到
    while (i < s.length && j < word.length) {
      if (s[i] == word[j]) {
        j++;
      }
      i++;
    }
    // 如果字典字符串的指针指向了字符串末尾，则说明该字符串可以通过删除给定字符串的某些字符来得到
    if (j == word.length) {
      return word;
    }
  }

  return "";
}
```

算法复杂度：时间复杂度为 O(nlogn + n*m)，其中 n 为字典中字符串的个数，m 为给定字符串的长度；空间复杂度为 O(logn)，主要是排序所需的栈空间。