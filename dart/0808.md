题目编号：808

题目：分汤

难度：中等

考察范围：递归、动态规划

题干：有 A 和 B 两个汤，初始都是一升。在某些时刻，我们将一些汤分给另一个汤。具体地，假设我们在时间 t 把 k 升汤从 A 分给了 B，那么在时间 t+1，B 有 k 升汤多，而 A 有 k 升汤少。

汤的总量不能超过容量，且不能分出去汤的数量大于现有的汤。当两个汤中都只剩下一升汤时，我们想把一升汤分给另一个汤。此时，我们想知道在 t = 1000 时，A 中恰好有 V 升汤，B 中恰好有 W 升汤的概率。

解题思路：使用递归或动态规划，将问题转化为求解在 t = 0 时，A 和 B 中各有多少汤的概率。具体地，设 f(i, j) 表示在 t = 0 时，A 中有 i 升汤，B 中有 j 升汤的概率。则有以下递推式：

f(i, j) = 0.25 * (f(i-4, j) + f(i-3, j-1) + f(i-2, j-2) + f(i-1, j-3))，其中 i, j >= 0

边界条件为 f(0, 0) = 1，f(i, j) = 0 (i < 0 或 j < 0)

最终答案为 f(V, W)。

解决方案：

```dart
double soupServings(int N) {
  if (N >= 4800) return 1.0; // 特判，当 N >= 4800 时，概率接近 1
  int n = (N + 24) ~/ 25; // 将 N 转化为升数，向上取整
  List<List<double>> f = List.generate(n+1, (_) => List.filled(n+1, 0.0)); // 初始化 f 数组
  f[0][0] = 0.5; // 边界条件
  for (int i = 1; i <= n; i++) {
    f[0][i] = 1.0; // 边界条件
    f[i][0] = 0.0; // 边界条件
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      f[i][j] = 0.25 * (f[max(i-4, 0)][j] + f[max(i-3, 0)][max(j-1, 0)] + f[max(i-2, 0)][max(j-2, 0)] + f[max(i-1, 0)][max(j-3, 0)]);
    }
  }
  return f[n][n];
}
```

算法复杂度：时间复杂度为 O(N^2)，空间复杂度为 O(N^2)。