题目编号：956

题目：最高的广告牌

难度：困难

考察范围：动态规划、递归、记忆化搜索

题干：

你正在安装一个广告牌，并希望它高度最大。这块广告牌将会以两个完全相同的面板组成，每个面板的宽度为 w，高度为 h。我们采用了一种奇特的墙壁安装方法，将这个广告牌安装在墙壁上。

这种安装方法的详细描述如下：我们将广告牌调整到一个合适的高度，然后将下面的面板向墙壁方向翻转。这块面板将会和墙壁成一个角度为 θ 的斜面。然后，我们可以将上面的面板固定在下面的面板上。这样，广告牌就能被安装到墙壁上了。图中蓝色部分表示广告牌。

返回满足安装新广告牌所需的最小高度。如果无法安装广告牌，请返回 0。

解题思路：

这道题可以使用动态规划来解决。我们可以定义一个三维数组 dp，其中 dp[i][j][k] 表示前 i 个元素中，高度差为 j 的情况下，左右两边的高度之和为 k 的最大宽度。

对于每个元素，我们可以选择将其放在左边、右边或不放。如果将其放在左边，那么 dp[i][j][k] 就可以由 dp[i-1][j][k-heights[i]] 转移而来；如果将其放在右边，那么 dp[i][j][k] 就可以由 dp[i-1][j][k+heights[i]] 转移而来；如果不放，那么 dp[i][j][k] 就可以由 dp[i-1][j][k] 转移而来。

最终的答案就是 dp[n][0][5000]，其中 n 是元素的个数，5000 是一个偏移量，因为高度差可能为负数。

解决方案：

```dart
int tallestBillboard(List<int> rods) {
  int n = rods.length;
  List<List<List<int>>> dp = List.generate(
      n + 1, (_) => List.generate(10001, (_) => List.filled(1001, -1)));

  dp[0][5000][0] = 0;

  for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= 10000; j++) {
      for (int k = 0; k <= 1000; k++) {
        if (dp[i - 1][j][k] == -1) {
          continue;
        }

        // 不放
        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);

        // 放在左边
        if (j - rods[i - 1] >= 0) {
          dp[i][j - rods[i - 1]][k] =
              max(dp[i][j - rods[i - 1]][k], dp[i - 1][j][k] + rods[i - 1]);
        } else {
          dp[i][rods[i - 1] - j][k + j] =
              max(dp[i][rods[i - 1] - j][k + j], dp[i - 1][j][k] + rods[i - 1]);
        }

        // 放在右边
        if (j + rods[i - 1] <= 10000) {
          dp[i][j + rods[i - 1]][k] =
              max(dp[i][j + rods[i - 1]][k], dp[i - 1][j][k]);
        } else {
          dp[i][2 * 10000 - j - rods[i - 1]][k + j + rods[i - 1]] =
              max(dp[i][2 * 10000 - j - rods[i - 1]][k + j + rods[i - 1]],
                  dp[i - 1][j][k]);
        }
      }
    }
  }

  return dp[n][5000][0];
}
```

算法复杂度：O(n^3)