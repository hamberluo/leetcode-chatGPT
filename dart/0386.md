题目编号：386

题目：字典序排数

难度：中等

考察范围：递归、字典序

题干：给定一个整数 n, 返回从 1 到 n 的字典顺序。

例如，

输入: 13

输出: [1,10,11,12,13,2,3,4,5,6,7,8,9]

解题思路：本题可以使用递归的方式来解决。首先，我们需要明确字典序的规则，即按照每个数字的每一位进行比较，如果前面的位数相同，则比较下一位，直到出现不同的数字为止。例如，1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9 这些数字按照字典序排列后的顺序就是这样的。

接下来，我们可以使用递归的方式来生成这些数字。具体来说，我们可以从 1 开始，依次生成以 1 开头的所有数字，然后再生成以 2 开头的所有数字，以此类推，直到生成以 n 开头的所有数字。在生成以某个数字开头的所有数字时，我们可以先生成以该数字开头的所有十位数，然后再生成以该数字开头的所有个位数。例如，当 n = 13 时，我们可以先生成 10, 11, 12, 13 这四个十位数，然后再生成 1, 2, 3, 4, 5, 6, 7, 8, 9 这九个个位数。

解决方案：

```dart
List<int> lexicalOrder(int n) {
  List<int> res = [];
  for (int i = 1; i <= 9; i++) {
    dfs(i, n, res);
  }
  return res;
}

void dfs(int cur, int n, List<int> res) {
  if (cur > n) {
    return;
  }
  res.add(cur);
  for (int i = 0; i <= 9; i++) {
    int next = cur * 10 + i;
    if (next > n) {
      return;
    }
    dfs(next, n, res);
  }
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。