题目编号：375

题目：猜数字大小 II

难度：中等

考察范围：动态规划

题干：我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，才算游戏结束。

给定一个代表游戏规则的正整数 n，你需要给出一个最坏情况下你需要支付的最小金额。

解题思路：动态规划

这道题是一道典型的动态规划问题，我们可以使用 dp[i][j] 表示从 i 到 j 中猜出任意一个数的最小花费。

对于 dp[i][j]，我们可以枚举猜测的数 k，那么猜测的结果可能是猜中了，也可能是猜小了或者猜大了。如果猜中了，那么花费为 0；如果猜小了，那么需要继续在 k+1 到 j 中猜测，花费为 k+dp[k+1][j]；如果猜大了，那么需要继续在 i 到 k-1 中猜测，花费为 k+dp[i][k-1]。因此，dp[i][j] 的值为这些情况中的最小值。

最终的答案为 dp[1][n]。

解决方案：

```dart
int getMoneyAmount(int n) {
  List<List<int>> dp = List.generate(n + 1, (_) => List.filled(n + 1, 0));
  for (int len = 2; len <= n; len++) {
    for (int i = 1; i <= n - len + 1; i++) {
      int j = i + len - 1;
      dp[i][j] = int.maxFinite;
      for (int k = i; k <= j; k++) {
        dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]));
      }
    }
  }
  return dp[1][n];
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。