题目编号：403

题目：青蛙过河

难度：中等

考察范围：动态规划、二进制

题干：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。给定石子的位置列表（用单元格序号升序表示），请判定青蛙是否能够成功过河（即能否在最后一步跳至最后一个石子上）。开始时，青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2）。

解题思路：动态规划

我们可以用一个二维数组 dp 表示青蛙能否跳到当前石头上，其中 dp[i][j] 表示青蛙能否跳到第 i 个石头上，并且最后一步跳了 j 个单位。最后一步跳了 j 个单位，是因为青蛙只能跳 j-1、j、j+1 个单位，所以我们需要记录最后一步跳了几个单位。

对于 dp[i][j]，我们需要在前面的石头中找到能够跳到当前石头上，并且跳了 j-1、j、j+1 个单位的石头。如果找到了这样的石头，那么 dp[i][j] 就为 true，否则为 false。

最后，我们只需要在最后一个石头上找到一个能够跳到该石头上的石头，就说明青蛙能够成功过河。

解决方案：

```dart
bool canCross(List<int> stones) {
  int n = stones.length;
  List<List<bool>> dp = List.generate(n, (_) => List.filled(n, false));
  dp[0][0] = true;
  for (int i = 1; i < n; i++) {
    if (stones[i] - stones[i - 1] > i) {
      return false;
    }
  }
  for (int i = 1; i < n; i++) {
    for (int j = i - 1; j >= 0; j--) {
      int k = stones[i] - stones[j];
      if (k > j + 1) {
        break;
      }
      dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];
      if (i == n - 1 && dp[i][k]) {
        return true;
      }
    }
  }
  return false;
}
```

算法复杂度：时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。