题目编号：123

题目：买卖股票的最佳时机 III

难度：困难

考察的知识点：动态规划

题干：

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。

注意: 你不能同时参与多笔交易（即，你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。

典型解题思路：

这道题是股票买卖系列的第三题，要求最多完成两笔交易，因此需要对状态进行设计。

我们可以使用动态规划来解决这个问题，设计状态如下：

dp[i][k][0/1] 表示第 i 天，已经进行了 k 次交易，手上没有/有股票的最大利润。

其中，0/1 表示手上没有/有股票。

对于每一天，我们可以进行以下操作：

1. 不进行任何操作，即 dp[i][k][0] = dp[i-1][k][0]，dp[i][k][1] = dp[i-1][k][1]。

2. 进行买入操作，即 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])。

3. 进行卖出操作，即 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])。

最终的答案为 dp[n-1][2][0]，其中 n 为数组的长度。

解决方案（用 dart 语言）：

class Solution {
  int maxProfit(List<int> prices) {
    if (prices == null || prices.length == 0) {
      return 0;
    }
    int n = prices.length;
    int max_k = 2;
    List<List<List<int>>> dp = List.generate(n, (i) => List.generate(max_k + 1, (j) => List.generate(2, (k) => 0)));
    for (int i = 0; i < n; i++) {
      for (int k = max_k; k >= 1; k--) {
        if (i == 0) {
          dp[i][k][0] = 0;
          dp[i][k][1] = -prices[i];
          continue;
        }
        dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
        dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
      }
    }
    return dp[n - 1][max_k][0];
  }
}

算法复杂度：时间复杂度为 O(nk)，空间复杂度为 O(nk)。其中，n 为数组的长度，k 为最多交易次数。