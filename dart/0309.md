题目编号：309

题目：最佳买卖股票时机含冷冻期

难度：中等

考察范围：动态规划

题干：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你必须在卖出股票之前持有该股票。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

解题思路：动态规划

- 状态定义：dp[i][0/1/2] 表示第 i 天结束后的累计最大收益，其中 0 表示持有股票，1 表示不持有股票且处于冷冻期，2 表示不持有股票且不处于冷冻期。
- 状态转移：

- dp[i][0] 可以由 dp[i-1][0] 或 dp[i-1][2] 转移而来，即前一天持有股票或者前一天不持有股票且不处于冷冻期，今天买入股票。
- dp[i][1] 只能由 dp[i-1][0] 转移而来，即前一天持有股票，今天卖出股票并进入冷冻期。
- dp[i][2] 可以由 dp[i-1][1] 或 dp[i-1][2] 转移而来，即前一天不持有股票且处于冷冻期或者前一天不持有股票且不处于冷冻期。

- 初始状态：dp[0][0] = -prices[0]，dp[0][1] = dp[0][2] = 0。
- 最终结果：dp[n-1][1] 和 dp[n-1][2] 中的较大值。

解决方案：

```dart
int maxProfit(List<int> prices) {
  int n = prices.length;
  if (n < 2) {
    return 0;
  }
  List<List<int>> dp = List.generate(n, (_) => List.filled(3, 0));
  dp[0][0] = -prices[0];
  for (int i = 1; i < n; i++) {
    dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i]);
    dp[i][1] = dp[i-1][0] + prices[i];
    dp[i][2] = max(dp[i-1][1], dp[i-1][2]);
  }
  return max(dp[n-1][1], dp[n-1][2]);
}
```

算法复杂度：时间复杂度 O(n)，空间复杂度 O(n)。