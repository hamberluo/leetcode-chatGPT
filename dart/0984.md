题目编号：984

题目：不含 AAA 或 BBB 的字符串

难度：中等

考察范围：字符串、贪心算法

题干：给定两个整数 A 和 B，返回任意字符串 S，要求满足：

S 的长度为 A + B，且正好包含 A 个 'a' 字母与 B 个 'b' 字母；
子串 'aaa' 没有出现在 S 中；
子串 'bbb' 没有出现在 S 中。

解题思路：贪心算法

首先，我们可以将问题转化为构造一个字符串，使得其中不包含 "aaa" 和 "bbb"。

我们可以考虑贪心地构造这个字符串。具体地，我们每次选出剩余的 a 和 b 中数量较多的字符，尽量地多放入字符串中。为了避免出现 "aaa" 或 "bbb"，我们需要在每个字符后面插入另一个字符，使得相邻的字符都不相同。因此，我们需要记录上一个放置的字符，以便判断下一个字符应该是什么。

具体地，我们设当前还剩余 a 个字符和 b 个字符，上一个字符为 last。根据贪心策略，如果 a>b，则我们将字符 'a' 放入字符串中，并更新 a←a−1；否则，如果 a≤b，则我们将字符 'b' 放入字符串中，并更新 b←b−1。在放置完一个字符后，我们更新 last 为刚刚放置的字符。

在上述构造方法中，我们每次只考虑了当前 a 和 b 的大小关系，而没有考虑 "aaa" 和 "bbb" 的限制。但是，我们可以发现，只要我们每次放置字符时，都选择剩余数量较多的字符，那么在构造的过程中，任意时刻 "aaa" 和 "bbb" 的数量都不会超过 1。因此，我们最多只需要检查一次构造出的字符串是否合法即可。

解决方案：

```dart
class Solution {
  String strWithout3a3b(int A, int B) {
    StringBuffer sb = StringBuffer();
    char last = ' ';
    while (A > 0 || B > 0) {
      if (A > B) {
        if (last != 'a') {
          sb.write('a');
          last = 'a';
          A--;
        } else {
          sb.write('b');
          last = 'b';
          B--;
        }
      } else if (A <= B) {
        if (last != 'b') {
          sb.write('b');
          last = 'b';
          B--;
        } else {
          sb.write('a');
          last = 'a';
          A--;
        }
      }
    }
    return sb.toString();
  }
}
```

算法复杂度：时间复杂度为 O(A+B)，空间复杂度为 O(A+B)。