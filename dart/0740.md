题目编号：740

题目：删除与获得点数

难度：中等

考察范围：动态规划

题干：

给定一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1:

输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。

示例 2:

输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 获得 3 个点数，接着要删除两个 2 和一个 4。
之后，删除 3 获得 3 个点数，再删除一个 3 获得 3 个点数。总共获得 9 个点数。

注意:

nums的长度最大为20000。
每个整数nums[i]的大小都在[1, 10000]范围内。

解题思路：

本题可以使用动态规划来解决。

首先，我们需要统计每个数字出现的次数，然后对于每个数字，我们可以选择删除它或者不删除它。

如果我们选择删除它，那么我们就需要删除所有等于 nums[i] - 1 和 nums[i] + 1 的元素，这些元素的点数已经被计算过了，所以我们需要跳过它们。

如果我们选择不删除它，那么我们就需要跳过它。

我们可以使用两个数组 dp1 和 dp2 来记录选择和不选择当前数字时的最大点数。

对于 dp1[i]，表示选择第 i 个数字时的最大点数，它可以由 dp2[i-1] + nums[i] 计算得到，因为如果我们选择第 i 个数字，那么我们就需要删除所有等于 nums[i] - 1 和 nums[i] + 1 的元素，这些元素的点数已经被计算过了，所以我们需要跳过它们，所以我们需要使用 dp2[i-1] 来表示不选择 nums[i] - 1 和 nums[i] + 1 时的最大点数。

对于 dp2[i]，表示不选择第 i 个数字时的最大点数，它可以由 dp1[i-1] 和 dp2[i-1] 中的最大值计算得到，因为如果我们不选择第 i 个数字，那么我们就需要跳过它，所以我们需要使用 dp1[i-1] 和 dp2[i-1] 中的最大值来表示不选择 nums[i] 时的最大点数。

最终的答案就是 dp1[n-1] 和 dp2[n-1] 中的最大值。

解决方案：

```dart
int deleteAndEarn(List<int> nums) {
  int n = nums.length;
  if (n == 0) {
    return 0;
  }
  int maxVal = nums.reduce(max);
  List<int> sum = List.filled(maxVal + 1, 0);
  for (int num in nums) {
    sum[num] += num;
  }
  int first = sum[0], second = max(sum[0], sum[1]);
  for (int i = 2; i <= maxVal; i++) {
    int temp = second;
    second = max(first + sum[i], second);
    first = temp;
  }
  return second;
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(maxVal)。