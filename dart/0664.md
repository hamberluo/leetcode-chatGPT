题目编号：664

题目：奇怪的打印机

难度：困难

考察范围：动态规划

题干：有一台奇怪的打印机，它有如下两个特殊要求：

1. 打印机每次只能打印由 同一个字符 组成的序列。
2. 每次可以在已有的序列后面添加一个字符或者在中间插入一个字符，然后打印出新的序列。

给定一个字符串 s，你的任务是计算这个打印机打印它需要的最少次数。

解题思路：动态规划

首先，我们可以发现，对于一个区间 [i,j]，如果 s[i] == s[j]，那么我们可以将其缩小为 [i,j-1]，这样不会影响最终的答案。因此，我们可以定义状态 dp[i][j] 表示打印出 s[i:j] 的最少次数。

接下来，我们考虑如何转移。对于一个区间 [i,j]，我们可以枚举其所有可能的分割点 k，将其分为两个区间 [i,k] 和 [k+1,j]。如果 s[k] == s[j]，那么我们可以将两个区间合并，这样可以减少一次打印次数。因此，我们可以得到如下的状态转移方程：

dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1] + (s[k] == s[j] ? 0 : 1))

其中，dp[i][k] 表示打印出 s[i:k] 的最少次数，dp[k+1][j-1] 表示打印出 s[k+1:j-1] 的最少次数，(s[k] == s[j] ? 0 : 1) 表示是否需要额外打印一次。

最终的答案即为 dp[0][n-1]，其中 n 是字符串 s 的长度。

解决方案：

```dart
int strangePrinter(String s) {
  int n = s.length;
  List<List<int>> dp = List.generate(n, (_) => List.filled(n, 0));
  for (int i = n - 1; i >= 0; i--) {
    dp[i][i] = 1;
    for (int j = i + 1; j < n; j++) {
      dp[i][j] = n;
      for (int k = i; k < j; k++) {
        if (s[k] == s[j]) {
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]);
        } else {
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1] + 1);
        }
      }
    }
  }
  return dp[0][n-1];
}
```

算法复杂度：时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。