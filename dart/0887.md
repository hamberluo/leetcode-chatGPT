题目编号：887

题目：鸡蛋掉落

难度：困难

考察范围：动态规划、二分查找

题干：

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你需要确定这栋建筑物在最坏情况下，最少需要多少次才能找到鸡蛋恰好摔不碎的楼层。

在最坏情况下确保最少次数，并确定在最坏情况下找到确切的楼层。

解题思路：

这是一道经典的动态规划问题，但是直接使用动态规划会超时，因此需要使用二分查找进行优化。

首先，我们定义状态 dp[i][j] 表示有 i 个鸡蛋，最多可以尝试 j 次，最多可以确定的楼层数。

对于每一次尝试，我们可以选择在第 k 层楼扔鸡蛋，如果鸡蛋碎了，那么我们需要在下面的 k-1 层楼中继续尝试，如果鸡蛋没碎，那么我们需要在上面的 N-k 层楼中继续尝试。

因此，我们可以得到状态转移方程：

dp[i][j] = dp[i-1][j-1] + dp[i][j-1] + 1

其中，dp[i-1][j-1] 表示在第 k 层楼扔鸡蛋，鸡蛋碎了，我们需要在下面的 k-1 层楼中继续尝试，因此剩余 i-1 个鸡蛋和 j-1 次尝试机会；dp[i][j-1] 表示在第 k 层楼扔鸡蛋，鸡蛋没碎，我们需要在上面的 N-k 层楼中继续尝试，因此剩余 i 个鸡蛋和 j-1 次尝试机会；1 表示在第 k 层楼扔鸡蛋。

但是，这个状态转移方程的时间复杂度为 O(K*N^2)，会超时。因此，我们需要使用二分查找进行优化。

我们可以将状态转移方程改写为：

dp[i][j] = dp[i-1][j-1] + dp[i][j-1] + 1
         = dp[i-1][j-1] + dp[i-1][j-2] + dp[i][j-1] + 1 - dp[i-1][j-2]

其中，dp[i-1][j-1] + dp[i-1][j-2] + 1 表示在第 k 层楼扔鸡蛋，鸡蛋碎了，我们需要在下面的 k-1 层楼中继续尝试，因此剩余 i-1 个鸡蛋和 j-2 次尝试机会；dp[i][j-1] 表示在第 k 层楼扔鸡蛋，鸡蛋没碎，我们需要在上面的 N-k 层楼中继续尝试，因此剩余 i 个鸡蛋和 j-1 次尝试机会；1 表示在第 k 层楼扔鸡蛋；dp[i-1][j-2] 表示在第 k 层楼扔鸡蛋，鸡蛋碎了，我们需要在下面的 k-1 层楼中继续尝试，因此剩余 i-1 个鸡蛋和 j-3 次尝试机会。

我们可以发现，dp[i-1][j-1] 和 dp[i-1][j-2] 都是单调递增的，因此可以使用二分查找来确定最优的 k 值。

解决方案：

```dart
int superEggDrop(int K, int N) {
  List<List<int>> dp = List.generate(K + 1, (_) => List.filled(N + 1, 0));
  int m = 0;
  while (dp[K][m] < N) {
    m++;
    for (int i = 1; i <= K; i++) {
      dp[i][m] = dp[i - 1][m - 1] + dp[i][m - 1] + 1;
    }
  }
  return m;
}
```

算法复杂度：O(K*logN)