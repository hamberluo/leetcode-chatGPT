题目编号：898

题目：子数组按位或操作

难度：中等

考察范围：位运算、动态规划

题干：

给定一个由整数数组 A 表示的正整数数组，其中每个整数的二进制表示中都不含前导零。

返回可以由 A 中选出的任意个整数按位或后得到的结果不同的个数。

示例 1：

输入：[0]
输出：1
解释：
可选的数字是 [0]，只有一个 0，因此输出为 1。

示例 2：

输入：[1,1,2]
输出：3
解释：
可选的数字是 [1,1,2]，按位或操作的结果包括 [1,2,3]。这些结果都是不同的。

示例 3：

输入：[1,2,4]
输出：6
解释：
可选的数字是 [1,2,4]，按位或操作的结果包括 [1,2,3,4,5,6]。这些结果都是不同的。

解题思路：

本题可以使用动态规划来解决。

首先，我们需要明确一个结论：对于任意一个数 x，如果它的二进制表示中第 i 位为 1，那么它可以通过与 2^i 进行按位或操作得到。

因此，我们可以考虑对于数组 A 中的每个数，枚举它的二进制表示中的每一位，如果这一位为 1，那么我们就将它与之前的所有结果进行按位或操作，得到新的结果集合。

具体来说，我们可以使用一个集合 set 来维护当前所有的结果，初始时 set 中只包含空集，然后对于 A 中的每个数，对于其二进制表示中的每一位，如果该位为 1，就将之前所有的结果与 2^i 进行按位或操作，并加入到 set 中。最终 set 的大小即为答案。

解决方案：

```dart
int subarrayBitwiseORs(List<int> A) {
  Set<int> ans = Set();
  Set<int> cur = Set();
  cur.add(0);
  for (int x in A) {
    Set<int> nxt = Set();
    for (int y in cur) {
      nxt.add(x | y);
    }
    nxt.add(x);
    cur = nxt;
    ans.addAll(cur);
  }
  return ans.length;
}
```

算法复杂度：时间复杂度为 O(n * w)，其中 n 是数组 A 的长度，w 是 A 中元素的二进制表示的最大位数。空间复杂度为 O(n * w)。