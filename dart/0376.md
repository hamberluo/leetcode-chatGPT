题目编号：376

题目：摆动序列

难度：中等

考察范围：贪心算法、动态规划

题干：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如，[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

解题思路：贪心算法

我们可以通过观察摆动序列的性质，发现一个数列的摆动序列长度最长为 n，当且仅当这个数列的摆动序列为：a1,a2,a3,...,an，其中 a1<a2>a3<a4>...<an 或 a1>a2<a3>...>an。

因此，我们可以通过贪心算法来求解最长摆动序列的长度。具体来说，我们可以维护当前的上升子序列的最后一个数字 up 和下降子序列的最后一个数字 down，然后遍历整个数组，根据当前数字与上一个数字的大小关系来更新 up 和 down，并更新摆动序列的长度。

解决方案：

```dart
int wiggleMaxLength(List<int> nums) {
  if (nums.length < 2) {
    return nums.length;
  }
  int up = 1, down = 1;
  for (int i = 1; i < nums.length; i++) {
    if (nums[i] > nums[i - 1]) {
      up = down + 1;
    } else if (nums[i] < nums[i - 1]) {
      down = up + 1;
    }
  }
  return up > down ? up : down;
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(1)。