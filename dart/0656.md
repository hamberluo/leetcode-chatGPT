题目编号：656

题目：[金币路径](https://leetcode-cn.com/problems/coin-path/)

难度：中等

考察范围：动态规划

题干：

给定一个数组 A（下标从 1 开始）包含 N 个整数：A1，A2，...，AN 和一个目标值 S。现在有一个在整数数组上移动的机器人。机器人从数组索引 i 移动到索引 j（i < j）上所需的代价为 A[j] - A[i]，也就是机器人从位置 i 移动到位置 j 需要消耗的硬币数（注意，如果 i >= j，A[j] - A[i] = 0）。

当机器人移动到数组中的某个位置时，它会把一个硬币放在这个位置上，然后继续移动。当机器人到达数组的最后一个位置（即它移动到索引 N-1 上）时，它会把剩余的所有硬币都放在这个位置上。

给定数组 A 和一个目标值 S，请你找出移动机器人的最少代价，使机器人移动到数组的最后一个位置，并且机器人在移动过程中放置的所有硬币恰好为 S 个。

如果无法移动机器人到数组的最后一个位置，则返回空数组。如果有多个代价最小的方案，则返回字典序最小的方案。

解题思路：

本题是一道动态规划问题，我们可以定义一个 dp 数组，其中 dp[i] 表示机器人从位置 i 移动到位置 N-1 所需的最小代价。我们可以从后往前遍历数组，对于每个位置 i，我们可以枚举它能够到达的位置 j，然后更新 dp[i] 的值。具体来说，我们可以枚举 j∈[i+1,n−1]，并将 dp[i] 更新为 A[j]−A[i]+dp[j]，其中 A[j]−A[i] 表示从位置 i 移动到位置 j 所需的代价，dp[j] 表示从位置 j 移动到位置 N-1 所需的最小代价。最终，dp[1] 就是机器人从位置 1 移动到位置 N-1 所需的最小代价。

在更新 dp[i] 的同时，我们可以记录一个 next 数组，其中 next[i] 表示从位置 i 移动到位置 N-1 所需的最小代价对应的下一个位置。具体来说，我们可以枚举 j∈[i+1,n−1]，如果 dp[i]=A[j]−A[i]+dp[j]，那么我们就更新 next[i]=j。最终，我们可以通过 next 数组从位置 1 开始依次往后走，得到一条代价最小的路径。

解决方案：

```dart
List<int> cheapestJump(List<int> A, int B) {
  int n = A.length;
  List<int> dp = List.filled(n, -1);
  List<int> next = List.filled(n, -1);
  dp[n - 1] = A[n - 1];
  for (int i = n - 2; i >= 0; i--) {
    if (A[i] == -1) {
      continue;
    }
    for (int j = i + 1; j <= min(i + B, n - 1); j++) {
      if (dp[j] == -1) {
        continue;
      }
      int cost = A[i] + dp[j];
      if (dp[i] == -1 || cost < dp[i]) {
        dp[i] = cost;
        next[i] = j;
      }
    }
  }
  if (dp[0] == -1) {
    return [];
  }
  List<int> path = [];
  int i = 0;
  while (i != -1) {
    path.add(i + 1);
    i = next[i];
  }
  return path;
}
```

算法复杂度：时间复杂度为 O(nB)，空间复杂度为 O(n)。其中 n 是数组 A 的长度，B 是题目中给定的参数。