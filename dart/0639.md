题目编号：639

题目：解码方法 II

难度：困难

考察范围：动态规划

题干：

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*' 了，字符 '*' 可以被当做 1 到 9 中的任意一个数字。

给定一条包含数字和字符 '*' 的加密信息，请确定解码方法的总数。

同时，由于答案可能会很大，请你输出答案对 10^9 + 7 取余的结果。

示例 1：

输入："*"
输出：9
解释：这一条只包含一个字符 '*'，可以被视为任意一个数字 1 到 9。

示例 2：

输入："1*"
输出：18
解释：这一条包含一个字符 '*'，可以表示数字 1 到 9 中的任意一个，所以可以解码为：11、12、13、14、15、16、17、18、19。

示例 3：

输入："2*"
输出：15
解释：这一条包含一个字符 '*'，可以表示数字 1 到 9 中的任意一个，所以可以解码为：21、22、23、24、25、26、27、28、29。

解题思路：

这道题是一道动态规划的题目，我们可以定义一个 dp 数组，其中 dp[i] 表示前 i 个字符的解码方法总数。

对于第 i 个字符，我们需要考虑以下两种情况：

1. 如果第 i 个字符是数字 1-9，那么它可以单独解码成一个字母，也可以和前面的一个数字组成一个字母，即 dp[i] = dp[i-1] + dp[i-2]。

2. 如果第 i 个字符是 *，那么它可以单独解码成一个字母，也可以和前面的一个数字组成一个字母，即 dp[i] = 9 * dp[i-1] + 15 * dp[i-2]。

其中，9 * dp[i-1] 表示第 i 个字符单独解码成一个字母的情况，因为 * 可以表示 1-9 中的任意一个数字，所以有 9 种情况。

15 * dp[i-2] 表示第 i 个字符和前面的一个数字组成一个字母的情况，因为 * 可以表示 1-9 中的任意一个数字，所以有 9 种情况，另外，如果前面的一个数字是 1，那么 * 可以和它组成 11-19 中的任意一个数字，所以有 9 种情况；如果前面的一个数字是 2，那么 * 可以和它组成 21-26 中的任意一个数字，所以有 6 种情况。因此，总共有 15 种情况。

最终的答案就是 dp[n]，其中 n 是加密信息的长度。

解决方案：

```dart
int numDecodings(String s) {
  int mod = 1000000007;
  int n = s.length;
  List<int> dp = List.filled(n + 1, 0);
  dp[0] = 1;
  if (s[0] == '0') {
    dp[1] = 0;
  } else if (s[0] == '*') {
    dp[1] = 9;
  } else {
    dp[1] = 1;
  }
  for (int i = 2; i <= n; i++) {
    if (s[i - 1] == '0') {
      if (s[i - 2] == '1' || s[i - 2] == '2') {
        dp[i] = dp[i - 2];
      } else if (s[i - 2] == '*') {
        dp[i] = 2 * dp[i - 2];
      } else {
        dp[i] = 0;
      }
    } else if (s[i - 1] >= '1' && s[i - 1] <= '9') {
      dp[i] = dp[i - 1];
      if (s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6')) {
        dp[i] = (dp[i] + dp[i - 2]) % mod;
      } else if (s[i - 2] == '*') {
        if (s[i - 1] <= '6') {
          dp[i] = (dp[i] + 2 * dp[i - 2]) % mod;
        } else {
          dp[i] = (dp[i] + dp[i - 2]) % mod;
        }
      }
    } else {
      dp[i] = 9 * dp[i - 1];
      if (s[i - 2] == '1') {
        dp[i] = (dp[i] + 9 * dp[i - 2]) % mod;
      } else if (s[i - 2] == '2') {
        dp[i] = (dp[i] + 6 * dp[i - 2]) % mod;
      } else if (s[i - 2] == '*') {
        dp[i] = (dp[i] + 15 * dp[i - 2]) % mod;
      }
    }
  }
  return dp[n];
}
```

算法复杂度：时间复杂度为 O(n)，空间复杂度为 O(n)。