题目编号：600

题目：不含连续1的非负整数

难度：简单

考察范围：位运算、动态规划

题干：给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含连续的 1 的个数。

例如，输入 5，返回 5，因为 5 的二进制表示为 101，其不包含连续的 1；输入 8，返回 6，因为小于等于 8 的非负整数中，其二进制表示不包含连续的 1 的个数分别为：0、1、10、100、101、110 和 1000。

解题思路：动态规划

我们可以用 dp[i] 表示 i 位二进制数中不包含连续 1 的个数。那么对于一个 i 位二进制数，它的最高位只有两种情况：0 或 1。

如果最高位是 0，那么剩下的 i-1 位可以是任意的，所以有 dp[i-1] 种情况。

如果最高位是 1，那么第二位只能是 0，剩下的 i-2 位可以是任意的，所以有 dp[i-2] 种情况。

所以，我们可以得到状态转移方程：dp[i] = dp[i-1] + dp[i-2]。

解决方案：

```dart
int findIntegers(int n) {
  List<int> dp = List.filled(32, 0);
  dp[0] = 1;
  dp[1] = 2;
  for (int i = 2; i < 32; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  int pre = 0, res = 0;
  for (int i = 31; i >= 0; i--) {
    int val = 1 << i;
    if ((n & val) != 0) {
      n -= val;
      res += dp[i];
      if (pre == 1) {
        break;
      }
      pre = 1;
    } else {
      pre = 0;
    }
    if (i == 0) {
      res++;
    }
  }
  return res;
}
```

算法复杂度：时间复杂度 O(log n)，空间复杂度 O(log n)。