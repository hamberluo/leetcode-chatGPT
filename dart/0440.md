题目编号：440

题目：字典序的第K小数字

难度：困难

考察范围：数学、字符串

题干：给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

解题思路：首先我们需要了解什么是字典序。字典序就是按照字母表顺序进行比较的方式，例如 "apple" 和 "banana"，按照字典序比较，"apple" 就排在 "banana" 前面。

对于本题，我们可以将 1 到 n 的数字按照字典序排序，然后找到第 k 个数字即可。但是这种方法的时间复杂度为 O(nlogn)，无法通过本题。

我们可以通过前缀树（Trie）的方式来解决本题。我们可以将 1 到 n 的数字构建成一棵前缀树，然后从根节点开始进行深度优先搜索，每次搜索到一个节点时，我们就将该节点的值加入到结果中，并继续搜索其子节点。当结果中的数字个数达到 k 个时，我们就可以返回结果了。

具体实现时，我们需要先计算出以某个前缀为前缀的数字的个数，然后根据这个数字个数来判断我们需要搜索哪个子节点。例如，对于前缀 1，以 1 为前缀的数字有 10 个（1、10、11、12、...、19），以 2 为前缀的数字有 0 个，以 3 为前缀的数字有 0 个，以 4 为前缀的数字有 0 个，以 5 为前缀的数字有 0 个，以 6 为前缀的数字有 0 个，以 7 为前缀的数字有 0 个，以 8 为前缀的数字有 0 个，以 9 为前缀的数字有 0 个。因此，如果 k <= 10，我们就需要搜索以 1 为前缀的数字；如果 10 < k <= 20，我们就需要搜索以 2 为前缀的数字；以此类推。

解决方案：

```dart
class Solution {
  int findKthNumber(int n, int k) {
    int cur = 1;
    k--;
    while (k > 0) {
      int steps = getSteps(n, cur, cur + 1);
      if (steps <= k) {
        cur++;
        k -= steps;
      } else {
        cur *= 10;
        k--;
      }
    }
    return cur;
  }

  int getSteps(int n, int n1, int n2) {
    int steps = 0;
    while (n1 <= n) {
      steps += min(n + 1, n2) - n1;
      n1 *= 10;
      n2 *= 10;
    }
    return steps;
  }
}
```

算法复杂度：时间复杂度为 O(logn)，空间复杂度为 O(1)。