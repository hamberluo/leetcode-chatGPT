题目编号：761

题目：特殊的二进制序列

难度：困难

考察范围：字符串、递归

题干：

一个字符串的二进制序列被称为是一个 特殊的 二进制序列 当且仅当满足以下条件：

- 0 的数量与 1 的数量相等。
- 二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。

你给出一个字符串 s，你需要将它分割成尽可能多的特殊的二进制序列。

编写一个算法使得分割的数量最少，并且返回分割后特殊的二进制序列的数量。

解题思路：

题目要求将字符串分割成尽可能多的特殊的二进制序列，那么我们可以考虑使用递归的方法来解决。

首先，我们需要找到特殊的二进制序列的定义，即 0 的数量与 1 的数量相等，且每一个前缀码中 1 的数量要大于等于 0 的数量。那么我们可以将字符串 s 分割成若干个子串，每个子串都是特殊的二进制序列。

其次，我们需要找到如何分割字符串 s。我们可以使用一个计数器 count 来记录当前子串中 0 和 1 的数量，当 count 的值为 0 时，说明当前子串是特殊的二进制序列，我们可以将其分割出来，并递归处理剩余的字符串。具体实现可以参考下面的代码。

解决方案：

```dart
class Solution {
  String makeLargestSpecial(String s) {
    int i = 0, count = 0;
    List<String> res = [];
    for (int j = 0; j < s.length; j++) {
      count += s[j] == '1' ? 1 : -1;
      if (count == 0) {
        res.add('1{makeLargestSpecial(s.substring(i + 1, j))}0');
        i = j + 1;
      }
    }
    res.sort((a, b) => b.compareTo(a));
    return res.join('');
  }
}
```

算法复杂度：时间复杂度为 O(nlogn)，空间复杂度为 O(n)，其中 n 为字符串 s 的长度。