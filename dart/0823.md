题目编号：823

题目：带因子的二叉树

难度：中等

考察范围：二叉树、动态规划

题干：给出一个含有不重复整数元素的数组，每个整数均大于 1。

我们用这些整数来构建二叉树，每个整数可以使用任意次数。

其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

如果值之间的乘积不等于任何给定的元素值，则使用该值。

总而言之，我们从下面的数组构建了一个数组树：nums = [2, 4, 5, 10]

```dart
        10
       /  \
      2    5
       \
        4
```

解题思路：动态规划

对于每个节点，我们需要找到它的左右子节点，使得它们的乘积等于当前节点的值。我们可以枚举左右子节点的值，判断它们的乘积是否等于当前节点的值，如果等于，就将它们作为当前节点的子节点。

但是这样会有很多重复的计算，因此我们可以使用动态规划来优化。我们可以先将数组排序，然后对于每个数，我们找到它的因子，如果因子在数组中出现过，就将它作为当前节点的子节点。

具体来说，我们可以使用一个哈希表来记录每个数是否在数组中出现过，然后对于每个数，我们枚举它的因子，如果因子在哈希表中出现过，就将它作为当前节点的子节点。

解决方案：

```dart
class Solution {
  int mod = 1000000007;

  int numFactoredBinaryTrees(List<int> arr) {
    arr.sort();
    Map<int, int> dp = {};
    for (int i = 0; i < arr.length; i++) {
      dp[arr[i]] = 1;
      for (int j = 0; j < i; j++) {
        if (arr[i] % arr[j] == 0 && dp.containsKey(arr[i] ~/ arr[j])) {
          dp[arr[i]] += dp[arr[j]] * dp[arr[i] ~/ arr[j]];
          dp[arr[i]] %= mod;
        }
      }
    }
    int ans = 0;
    for (int val in dp.values) {
      ans += val;
      ans %= mod;
    }
    return ans;
  }
}
```

算法复杂度：时间复杂度为 O(n\sqrt{n})，空间复杂度为 O(n)。